(47) Master Design Patterns & SOLID Principles in C# - Full OOP Course for Beginners - YouTube
https://www.youtube.com/watch?v=rylaiB2uH2A

Transcript:
in this comprehensive and beginner-friendly course you'll learn all the tools that you need to become an advanced objectoriented programmer writing clean code and maintainable software you'll learn fundamental oop Concepts the solid principles all 23 gang of four software design patterns and more experience developer Danny Adams created this course welcome to mastering design patterns and solid principles in cop so let me first give you a quick introduction on what you will learn in this course and what you
need to know before getting started so the aim of this course is to teach you how to design maintainable and reusable objectoriented software and this is achieved first of all by learning the objectoriented programming principles such as encapsulation abstraction inheritance polymorphism and coupling you'll also learn the five solid principles which are the single responsibility principle the open closed principle the list off substitution principle the interface agregation principle and the dependency inversion
principle you'll also learn unified modeling language which is a way to graphically represent your software systems so you can model classes and objects and the relationships between those classes and objects in a graphical way and you can do this before you actually code out a solution and you'll also learn the main 23 design patterns from the gang of four book The Gang of four design patterns consists of 23 design patterns from the original book design patterns elements of reusable objectoriented software written by four
guys in the 1990s and these patterns can be grouped into three categories so there are creational design patterns which are the different ways to create objects there are structural design patterns which are the relationships between those objects and there are behavioral design patterns which are the interaction or communication between those objects so upon completion of this course you will understand all 23 ganga 4 design patterns and where to and where not to apply them in real applications and you'll also learn the solid
principles and some more advanced objectoriented programming Concepts and these are all of the 23 design patterns from the gang of four book that we will be covering in this course so you can see that there are five creational design patterns seven structural design patterns and 11 behavioral design patterns so what are design patterns and why should you learn them so design patterns are essential in software development for several reasons and first of all they help to promote and provide proven solutions to recurring
problems in software design so instead of Reinventing the wheel developers can Leverage The these patterns to solve common issues efficiently for example to implement an undo feature in an application developers could reach for the momento design pattern design patterns establish a common language for developers to communicate efficiently and effectively about software designs and this common vocabulary enhances collaboration and understanding among team members design patterns also promote scalable designs by providing flexible
and AD aable solutions they allow systems to evolve over time without extensive rework or architectural overhaul and using design patterns often results in more maintainable code AS patterns encapsulate design decisions and promote modular Loosely coupled architectures making it easier to understand modify and extend code bases and some design patterns can help to improve performance by optimizing resource usage producing overhead or facilitating efficient algorithms design patterns serve as a form of documentation for software
designs so by employing well-known patterns developers can convey design intent more effectively making code bases easier to understand for both current and future contributors design patterns embody best practices and principles of software design they encapsulate years of collective knowledge and experience guiding developers towards uh solutions that are more robust reliable and maintainable and many design patterns are agnostic of programming languages or domains so they can be used across different programming languages
essentially and they can they can be applied across different Technologies and IND Industries making them valuable tools for developers working in diverse environments so overall design patterns fa itate the creation of highquality maintainable software systems by providing reusable solutions to Common design problems and promoting best practices in software development and just as a note don't worry too much if you don't quite understand everything I've said so far and as everything will become much more clear as we Implement
and discuss each of the design patterns and objectoriented programming principles during the course for example many of you right now won't understand the difference between extending a code base versus modifying a code base and all of these things will be revealed during the course so here are some things that you should understand before starting this course so this course is for developers that have at least a very basic knowledge of objectoriented programming and want to learn design patterns to become better more complete
developers so here are some things that you should understand before starting this course so you should understand what classes are you should understand how to create objects from classes access modifiers such as public private and protected class Properties or fields and class methods so as you can see you just need to understand the very basics of objectoriented programming to find Value in this course any other objectoriented programming Concepts such as abstract classes polymorphism and capsulation will be fully explained in the course
and of course you will learn the very important objectoriented programming solid principles so all the examples in this course are in CP so it will be helpful if you understand understood the basic syntax of C as I won't be explaining the basic syntax however there are plenty of free and great videos on YouTube to help you get started with C in very little time so a little bit about me I am currently a freelance software developer that builds full stack web applications Shopify apps mobile apps WordPress plugins and themes
and I'm also a technical writer that enjoys writing technical blog posts books and making videos and courses so here are some links where you can find me so I have a YouTube channel uh I have a Twitter account I sell some products such as posters and PDFs on gumroad uh I have a free code Camp blog where I write posts for free code camp and I also have a Blog on dev 2 there is also a full book version of this course available and it includes everything that is covered in this video course and having the book can help to make
revision of these topics much easier as you can quickly look up certain topics principles and Concepts skim through and remind yourself of what we covered in this video helping these topics to stick in your head and if you're a heavy notetaker like me then it will also save you a lot of time as everything we cover in this video will be written down here for you so if this book sounds like it would be helpful to you to better learn these Concepts then you can get the book from Amazon in Kindle ebook and physical
print format and there's also a pdf version available from gumroad and there should be links to those down in the description below so for every design pattern or solid principle or object oriented programming principle that we cover in this course we will go over an example or two and usually each example will include a bad example which violates a certain principle and then we have a good example where we usually refactor the bad example to satisfy the principle that we are covering and all code examples for this course can be found at
this GitHub repo okay so I'm now going to show you how you can set up your computer so that you can follow along with the examples in this course so this course is all in C so we need to set set up a sort of CP environment so for me I'm going to use Visual Studio code as the text editor and I've provided a link to a guide here to get you started and set up so let's have a look at this guide so if you click this link it will take you through to this getting started with C in vs code guide and it tells you everything
that you need to download and then everything that you need to do to create a new C application or project so first of all you need to download Visual Studio code if you don't already have it so you can download it here um and then you need to download the cop devkit extension for vs code so you can download that by clicking this link and you can install the C devkit extension you can also do it from vs code directly so if you come into the extensions uh sort of tab and then you can search for C devkit and then you can
install I've already got it installed so I don't need to do that and the next thing you need to do is to download the net software development kit and you can download that from Microsoft so you can download that here so that's everything that you should need to get started uh developing with C so once you've done that you can then create a new C application so if we come into Visual Studio code here we've just got a blank uh you know no folders open so what we can do is let's create a new
C project using the extension the C devit extension that we installed earlier so you can press shift command P to open up the command pallet and then we can see we have some options here so you can type in net uh co1 and then new project and you can see you can click net new project and then we want to select console app because we're going to create a very simple console app for all of our examples in this course and that's just an app where we can basically log things to the console so select console app and then you need
somewhere to actually store this project so I'm just going to store it on my desktop for now so I'm going to open that and then I need to name the project I'm just going to call it test because I've already created the actual project that we're going to use uh you can call this something like um design patterns in C uh tutorials or course or something like that whatever you want and then we just click create project and you can see it's created this project in my desktop folder so if
we come to the file explorer now and we go into our program.cs file we can see that we have console. right line hello world and we can just run this file or this application and we can see that we get hello world logged to the console so that is how you set up with Visual Studio code for net and this is how I will be uh doing all of the examples in this course but just as a note feel free to use whatever text editor or setup that you want if you already have something set up for C before we start learning any design
patterns it's important that you understand some fundamental objectoriented programming principles so here are some Concepts that you'll understand by completing this next section of the course so you will understand encapsulation abstraction inheritance polymorphism coupling and composition so let's get started so the first objectoriented programming principle that we're going to take a look at is encapsulation which is a fundamental principle of objectoriented programming that involves bundling the
data or attributes or fields and the methods or behaviors that operate on that data into to a single unit called a class and encapsulation helps in hiding the internal implementation details of a class by only exposing the necessary functionalities to the outside world so if that doesn't make too much sense don't worry because we're now going to go through a simple example demonstrating encapsulation and we'll first go through a bad example with no encapsulation and then we'll refactor that example to use encapsulation so
first of all we're going to create a new class called bad bank account and this is going to have a single field uh called balance and this is a public field and then inside of our program.cs field so this is going to be a Class A program class is going to use or be a client of this bad bank account class so we're going to say bad bank account and we'll call this bad account equals new bad bank account and we're going to set the balance uh equal to 100 so initially the balance is going to be 100
and let's just log that to the console and let's run our program to make sure everything's working correctly and we can see we get 100 logged to the console so the issue with this solution is that because this is a public Fe Feld all clients or so all classes that use this class can just directly uh change this balance field to whatever value they want so if I change this to minus 50 and then run the program we should get no issues okay now this is actually a problem because let's just say that in
our program Bank uh bank accounts should not uh balances should not allowed to be should not be allowed to be negative okay so this is actually violating our program's logic so in all of our clients because we can just directly access this field in all of our clients we then have to provide some sort of uh conditional statement so we'd have to say like if the uh the amount that we want to set the balance to is negative then we can maybe throw some error or you know display the user some issue and we
wouldn't want to have to do this inside of every single client that uses bad bank accounts okay so you can see that we have some issues here because we can set this to whatever we want because this is public so let's now use encapsulation to solve this problem so let's create a bank account class and we're actually now going to make the balance field private so that it can't be accessed outside of this class uh so let's actually create a Constructor now so that we can set the initial balance of the bank account and
we'll say decimal balance and what we're going to do is we're going to provide a method now called deposit and then we can set the balance in here okay so let's create a method called deposit and we pass this an amount that we want to deposit and then here what we can do is we can check that if the amount that we're trying to deposit is negative then we can throw an error because it doesn't make any sense to deposit a negative amount of money you don't deposit minus $50 into a bank
account you only deposit positive numbers so we can say if amount is less than or equal to zero then we're going to throw a new argument exception and we will say that deposit amount must be posit positive so deposit amount must be positive okay so that is preventing now users of this class from depositing negative amounts of money and that actually solves our issue of whenever of actually having a negative balance because we now can't have a negative balance when we deposit money okay so what we can do now is just add the
amount onto the balance so we can say balance this. balance plus equals the amount so let's also create create a method for withdrawing money from the bank account so currently we can deposit money but we also need to get money from the account so let's create a withdraw method so we can say public void withdraw and then we need to provide an amount that we want to withdraw now again we need to make sure that balance can't be negative and so we need to make sure we don't try to withdraw uh an amount greater than our
balance so first of all we can check if the amount is less than zero so we can't withdraw a negative amount because that doesn't make any sense so we're going to say if amount is less than or equal to zero uh then we're going to throw a new argument exception and we'll say withdrawal amount must be positive so we'll say with drawal amount must be positive okay and we also need to check to see if the amount that we're trying to withdraw is greater than the amount that we have in the account because that
shouldn't be possible so we're going to say if amount is greater than the balance then we can throw invalid operation exception and we can say insufficient funds insufficient funds okay otherwise if we get down to here then we can just subtract the amount from the balance so we can say this do balance minus equals the amount okay and it would also be nice to uh for the user to be able to actually see what their balance is so let's provide a geta method so a geta method is just a method that essentially allows
the user to see a private the value of a private field so we can say public uh decimal and then by convention what you do is you just basically prefix get onto the name of the field that we're trying to get so we say get balance and we're just going to return the balance okay so now let's take a look at how we would use this new bank account class where we have encapsulated the logic and the fields within this class and not made them available publicly to all users of this class so we're going to first of all
let's just remove everything from in here and we're going to say bank account and bank account equals new bank account and we need to provide an initial amount so we'll say 100 okay and let's actually log the balance to make sure that that has worked correctly so we can get balance and let's deposit uh an amount so let's just say uh bank account.
deposit and we'll deposit say uh $50 and we'll log the balance there so let's put that up there and then let's actually withdraw some money so withdraw let's withdraw 100 and then log to the console the balance so that should be bank account okay so let's make sure that this is all working correctly so initially the balance should be 100 so we can see here that's correct then we deposit 50 so we now have 150 then we take out 100 and we now have 50 so let's check if we actually try to initialize
the account with a negative amount of money so we should get an exception thrown it shouldn't allow us to do that and as you can see we get an exception the deposit amount must be positive so that's working correctly what if we try to withdraw more than we have in the account so here we have 150 in the account let's try to withdraw $200 and we should get an exception because we're trying to withdraw more than we have in the account and the withdrawal amount must be positive so you can see here we're trying to
withdraw a negative amount I wanted to actually withdraw a positive amount there so let's just check that and it says it it tells us that we have insufficient funds so that is all working perfectly so in this example the bank account class encapsulates the account data so the balance um and all the related methods so deposit and withdraw into a single unit this bank account class is the sort of single unit and the data members the balance are marked as private uh encapsulating them within the class and preventing direct access from outside of
the class and geta methods so get balance are used to provide controlled access to the private data member the balance class uh field in this case and methods deposit and withdraw are used to um manipulate balance ensuring that operations are performed safely and according to the business rules so we can see here we have checks to make sure that nothing uh incorrect so the sort of program logic can't actually be violated from outside of the class and the main method or inside of this program.cs file we are
demonstrating how to create an instance of bank account and interact with its properties and methods without needing to know the internal implementation details so we can see that the user or so this program uh class here the user of B the bank account class uh can't directly access the balance field as it's marked as private so the data is encapsulated within the class and methods dictate the rules for how this data is can be accessed and modified ensuring that our programs correct rules and logic can't be
violated by users or consumers of the bank account class for example it's no longer possible to withdraw more money than is in the account and encapsulation of logic inside of the methods in bank accounts also means that users don't need to worry about uh the implementation details when we're interacting with a bank account object for example the user doesn't have to worry about the logic involved in withdrawing money um they can just call uh the withdraw method and the implementation details of withdrawing money are hidden
from the client and encapsulated and if the user tries to do something stupid like deposit a negative amount of money then the program will throw an error and the user will be notified and encapsulation of logic within methods in bank account allows users to interact with bank account object without needing to know or understand the internal implementation details of how withdrawals or deposits or other operations are carried out users of the bank account class can interact with it using simple intuitive methods like we draw and deposit without
needing to understand the complex logic behind these operations so encapsulation abstracts away the complexity of the implementation details allowing users to focus on the higher level functionality provided by the bank account class so users only need to know the public interface of the bank account class in other words the public methods or properties to use it effectively while the internal implementation details remain hidden so in summary encapsulation allows for a clear separation between the public interface
and the internal implementation of a class providing users with a simplified and intuitive way to interact with objects while hiding the complexity of those of how those interactions are handled internally abstraction is an objectoriented programming principle that is used to reduce complexity by hiding the unnecessary details of a class to a user of that class so a good example of this is the when you press a button on a TV remote you don't have to worry about or interact directly with the internal circuit board so for
example within a remote there will be electrical impulses firing through a circuit board and then some electromagnetic waves will uh come out of the remote and be received by the television but you don't really need to understand any of that or you if you want to change channel to channel 2 you just have to press uh the two and it'll change directly it'll change to channel two and you don't have to worry about any of the complex uh details of how that happened uh all those details are abstracted away so I've created an
email service class here to demonstrate uh abstraction So currently this class has no abstraction really uh we are we have just a load of public methods that are available to any user of this email email service class so if we want to send an email um we create an email service object and then we have to connect to the email server authenticate send the email then we have the user has to remember to also disconnect from the server once the email has been sent or once we've finished um you know sending any emails or doing what we're doing
with this email service class so the issue of this solution is that all users of this class have to follow all of these steps in a specific order and um for example if any uh if we add another uh method to the email service class such as uh log some information um then all of the users of this class would then have to add an extra step such as log okay and we couldn't just change uh this in one place we would have to edit all of our classes that were sending an email so a better solution uh to this would be to make uh these methods
private and only expose one method to users of this class and that would be the send email uh method so what we can do here is we can call all the methods all the the steps that are involved in sending an email we can call them in the send email uh method and then we can see we have an error now because these uh methods are no longer available they are now private methods so we only now have to call the send mail uh method so if I just show you this you can see that the only method available now is send email and if we run the
program we get the exact same thing as we got before but now users of the email service class um now don't have to worry about the internal implementation details involved in sending an email all the complexity has been abstracted away and encapsulated within this email service uh class so now the user can send emails without having to know any of the details or any of the complexity uh and without ex scash uh without abstraction you can you saw that the user had more decisions to make because whenever we looked at the
methods on this email service object there was uh you know three more methods to choose from whe it was connect authenticate or disconnect and so the user then has more decisions to make whereas this it's very simple we can just call send email it's very obvious how to send an email so without abstraction the user needs to know more information and understand the internal logic involved in sending an email and importantly if any of those private methods are changed EG uh for example they take another parameter so let's say
uh when connecting we added um another parameter such as uh I don't know a URL to an email server then all classes using the email service would then have to change uh they would all have to add this extra parameter and all those classes would have to be modified and you risk adding bugs into previously working code whereas of this um with this solution where these methods are all kept um abstracted away uh we could just add the uh parameter to one method we would only have to change the send email and say
connect method inheritance involves creating new classes based on existing classes so uh the new classes that we create are often called subclasses or derived classes and they are based on the existing classes which are known as super classes or base classes so a subass inherits properties and behaviors from their super class and can also add new features or override existing ones inheritance is often described in terms of an is a relationship for example we may have a shape class which could be a base class or a super class and a shape
class could have uh subclasses which inherit from shape so uh and that relationship would be represented uh by inheritance pretty good because a a uh for example a circle is a shape okay so shape could um inherit uh sorry a circle could inherit a shape so here's an example where uh a a car or a bike class can inherit from a parent vehicle class so we have a vehicle class here which has some properties some C Properties for the brand of the vehicle the model of the vehicle the year of the vehicle and some methods that can start
or stop the vehicle so all vehicles um whether they are cars bikes planes or boats will have all of the these kinds of information so what we could do is create a car class and have all of these properties and methods in car class uh so we could literally copy and paste them all in here like so and then we also have a bite class and we could have again repeat everything and have the brand model your start stop methods all within bike but we're going to have to repeat ourselves a lot with this this and if for example vehicles um we need
some extra functionality for a vehicle um that all vehicles have then every single vehicle we would have to add a new method and also if we changed for example the way we start a vehicle then we would have to change that method in all of the vehicle classes rather than just in one place so what we can do is we can use inheritance we can see here that car is inheriting vehicle so the way that you uh inherit a class in CP is by using this colon so car inherits vehicle and we can also make bike inherit inherit vehicle as well so now
in our program.cs file we are going to say uh we'll create a car object so we'll say car equals new car and that automatically gets imported and we can say car let's first of all actually have a look at the Shared uh properties so bikes and cars now because they both inherit vehicle have access to all of these uh Properties or methods within the class so let's have a look at the Shared stuff first so we can say car do uh brand uh o sorry that should be lowercase and we can say car.
start and car. stop and then also we can see that cars also have their own properties which are only available or only accessible on car objects such as the number of doors for example because bikes don't have doors so we cannot put that onto the vehicle class because bikes don't have doors so that shouldn't be available on a bike uh class or a bike object so then we can say the unique uh properties and methods to a car such as the number of doors um so so now when we run this program we can see the vehicle is
starting and the vehicle is stopping uh so these uh are the inherited methods shared by bike and car or whatever vehicle we have and we also have some unique methods which are uh individual or unique to the individual uh type of vehicle so now if we change this to a bike object let's just change it to a bike object you can see we got an error because number of doors doesn't exist on bike but these start and stop uh methods and also the brand are all available because they are inherited from this vehicle class so uh uh one of the
advantages of using inheritance is that it means that we don't have to write the commonly used fields and methods for every single type of vehicle and also if we want to change the start method then we only have to change it in one place because we aren't writing the start method onto every single type of vehicle it's all it's just one method inside of the uh vehicle class meaning that we only have to change it in one place and another great thing about uh inheritance is that it allows for another very important object oriented
programming principle which we're going to look at next called polymorphism polymorphism is the ability of an object to take many forms so poly means many and morph meaning forms so I've got an example here where we have a parent vehicle class which stores the brand model year and has a couple of methods for starting and stopping a vehicle and these are virtual methods which in c means that these methods can be overit by any uh subclasses or child classes and we have a a car child class which extends vehicle meaning that it uh sort
of um inherits these properties and methods from vehicle and then what we're doing is we are over riding these start and stop methods in car um because for example starting a car involves some different uh logic than say starting a motorcycle or starting a plane so motorcycle is also a vehicle and it overrides these uh start and stop methods but there are different steps in starting a motorcycle so we have to implement this these methods in inside of the motorcycle class so you might be wondering why do we bother extending
vehicle with these start and stop methods when we are just uh when we're having to implement them or specify them within each individual type of vehicle doesn't really make sense and the reason for this is because it allows us to use polymorphism uh which essentially allows us to treat uh these objects in uh in the same way so let me demonstrate what I mean by what this means so if we create a list of uh any objects so this can be any object this list of vehicles and then we just add some vehicles to this list so
we H we add a new car object and we um give it a brand of Toyota uh cam model of Camry year 2020 and then we add a new motorcycle so let's just call this uh harleydavidson and let's give it a uh model of uh let's see sport fer and let's give it a year of 2021 okay so now we have a a list with two uh of these vehicle uh classes but in this list we can have any objects so we can add you know a banana or a person even though we've called it Vehicles we can actually add anything to this list
because it's just a list of objects so let's say we want to perform some sort of uh vehicle uh in inspection so what we need to do is we need to Loop through this list of objects so we can say VAR vehicle in vehicles and let's say we want to start the vehicle so we want to test starting the vehicle so we can call vehicle.
start but the start method isn't here which is unexpected because all these are all vehicles so far we were expecting to be able to call this start method but our program has no idea it's not it's not guaranteed that a start method exists on one of these objects because they're just any objects they're not they're not Vehicles so what we would have to actually do is we'd have to actually check what the type of this object is before we can call any methods so for example we would have to do this if
vehicle is of type car we then have to cast this object into a car object okay so we we do uh we can say VAR car equals car vehicle so we're casting it into a from a generic object into a object of type car and now it's a car object now we know that it's a car object we can then call car. start okay but then if we want to also uh test uh we also need to account for testing motorcycles and planes so we then have to do another elsif statement to say uh check if the vehicle is a motorcycle for example and if it is we can say uh we
can cast the uh the object into a object of type motorcycle and once we know it's a motorcycle object we can call the start method and then we would also have to do the same for plane and the issue with this is first of all it's hard to read we have to have a lot of if uh and else if conditional statements and also if we add more uh vehicles to our program such as uh a boat for example then we also have to keep on modifying our um our uh client classes the classes that are using these vehicle objects have to be modified which is not
good we don't want to have to keep on modifying our code every time we add a vehicle we just want to be able to add a vehicle and not have to keep on modifying our uh vehicle inspection logic okay so how do we fix this so first of all rather than having a list of objects we know that all of the uh objects in this list are of type vehicle because they're all extending the vehicle class so we can say uh that this is a list of vehicle objects and now when we Loop through this list of vehicles we know because
they're of type vehicle and we know that all vehicles have this start and stop method uh start and stop methods we can simply just call vehicle. start and that's it it's that simple so we've actually used polymorphism here because we're actually treating different types of objects uh as the same we're just treating them as Vehicles okay we're not worrying about whether it's a car or a motorcycle or a plane because there are all vehicle classes which have these methods we can just call the method
directly and treat them all the same okay so in this example let's just sum things up uh we have a list of vehicles containing instances of both car and motorcycle and then we iter iterate through each vehicle in the list and perform a gen General inspection so we're just starting the vehicle that's just a simple inspection um and despite the vehicles being of different types polymorphism allows us to treat them all as instances of the base vehicle class the specific implementations of the start and stop
method methods for each vehicle type are invoked dynamically at runtime based on the actual timee Tye of each vehicle and because the list can only uh contain objects that extend the vehicle class we know that every object will share some common fields and methods meaning that we can safely call them within the client code uh without having to worry about whether each specific vehicle has these fields or methods so this demonstrates how polymorphism enables code to be written in a more generic and flexible manner
allowing for easy extension and Main maintenance of new types of vehicles as they are added to the system so if we add another type of vehicle we don't have to say alfe vehicle is type of boat and then cast it to a boat and then call the start method whatever the start method may be called on that boat because it we have no uh reason to actually call it start we could call it start boat and then we could call start boat it doesn't even have to be called start if we don't uh extend the vehicle class the vehicle class ensures that all
vehicles have this start method and we can treat all vehicles the same uh within our client code coupling refers to the degree of dependency between different classes um so high coupling means that classes are tightly in interconnected making it difficult to modify or M uh maintain them independently whereas low coupling indicates loose connections between classes allowing for greater flexibility and ease of modification if classes are tightly coupled then modifying one class could break the other which could break the whole
program so first of all let's consider an example of uh where we have high coupling and then we will improve this example by reducing the coupling so let's first of all create a a bad example so we're going to create a uh email sender class and within this email sender class we're going to have a a method called send email which takes a string message and we're going to have some email sending logic such as connecting to the uh email server um uh authenticating all that kind of stuff uh but we're not going to worry
about that we're just going to log sending email and then we're just going to concatenate the message okay so then let's let's say that we have some sort of e-commerce application where a user can can place orders they can order certain items and once they've ordered an item they get an email to say that the order was placed successfully so let's create this order class and let's give it a uh method called place order and then we have some place order Logics and first kind of logic will be
inserting the order into the database uh reducing the uh stock quantity of items that have been ordered processing payment all that kind of stuff but we don't need to worry about that and then once all that's been done we can send a um email to the user to say that the order has been placed successfully reassuring the uh user so we can send email and give them a message to say order placed successfully okay then let's simulate uh let's simulate a user actually um placing an order so we can say order equals New
Order and we can say order. place order okay so let's run this program and as we can see the order is placed successfully and the user gets an email to say that the order is placed successfully so this all looks okay but in this example the order class is tightly coupled to the email sender class because it directly creates an instance of the email sender class okay we we're calling the new keyword this means that we're we're directly creating an instance of email sender which makes the order class dependent on the
implementation details of email sender and any changes to the email sender class may require modifications to the order class okay so uh if we make a change to email sender we may have to also make modifications to the order class okay and it just means that we may you know if we change one class and also have to change another class it means that we are risking introducing bugs into this class we'd rather not have to modify this class if we change the implementation details of email sender it should just be all contained within
here we shouldn't it shouldn't affect the order class so let's now discuss how we can reduce the uh coupling so to to reduce coupling we can introduce an abstraction or an interface between the the order class and the email sender class and this allows the order class to interact with the email sender class through an abstraction or an interface making it easier to replace or modify the implementation of email sender without affecting or the order class okay so if that doesn't make too much sense uh we will we'll go through
an example now and it should make more sense so let's create an interface called I notification uh service and all classes that implement this interface should have a send notification uh method which takes a uh message string so now what we can do is we can go into email sender and we can say that email sender implement notification service okay and what we can do is if you can press if you press command and then dot you can implement the interface uh on Windows that's I'm guessing that's control and
Dot and what we can do is we can copy and paste this send email logic into this send notification method and we can get rid of send email okay now in our order class we can see that we we have an issue now because the send email class doesn't exist so what we could do is call uh send notification but you can see that this order class is still tightly coupled to this email sender uh for and the problem with this is it's not very flexible because for example let's say that the user um wants to be uh send a text
message once the order has been placed successfully there's no way of doing this because the email send it is is just hardcoded into this placeholder method there's no way of switching out the way that we uh send a notification to the user so let's actually make that possible so what we can do as we can add a private field private read only uh field of type I notification service and we'll call this notification service we'll create a Constructor so whenever we create a new order object we have to pass in the
notification service that we want to use and we can set that notification Service uh field here and then what we can do in the place order method rather than having this email sender we can just call notification service do send notification and of course what we can do here is uh we can pass this a message of order placed successfully successfully okay so let's have a look how this now uh works so we have an error here because we actually need to pass a notification service to any uh order objects when we are creating order
objects so we can pass um an email sender and then place the order and as you can see we are sending email order placed successfully okay so let's say that the user wants to uh have uh a notification by text message so SMS so we can create an SMS sender uh and then what we will do this needs to implement the I notification service interface we can implement the method and what we can do is we can just say uh SMS message and then we can just concatenate on the message so now what we can do if if um the user wants to be notified by SMS we
can just say new SMS sender now the reason we can CH switch out uh what kind of notification service we use is because in the order class we're saying that we have to pass any type of notification service and because we now have this abstraction this interface SMS sender and the email sender are both of type or implement the notification service so we can treat them uh in the same way here we can pass either an SMS sender or we can pass an email sender so now we place the order you can see here we're sending an email
we're now passing an m sms sender and let's see what happens we get an SMS message okay and we we were able to switch out this SMS uh we were able to switch the uh type of notification service that we used without having to modify this order class so in this improved example we have decoupled the order class from the specific implementation of the notification service allowing different implementations for example email sender or SMS Notifier SMS sender whatever to be easily substituted without modifying the order class uh and
this reduces coupling and improves the flexibility and maintainability of the code base composition involves creating complex objects by combining simple objects or components in composition objects are assembled together to form larger structures with each component object maintaining its own State and behavior composition is often described in terms of a has a relationship so let's go through an example to show you what composition looks like so first of all we have a load of uh sort of items or parts that
make up a car for example a car has a sh chassis and here we just have a method called support so it just says chassis is supporting the car we have an engine with a start method uh we have seats with a Sit method and we have some Wheels with a uh rotate method okay so these are all the parts that a car is composed of so now if we have a look in the car class we can see that H we have a car class here that uses composition it is essentially uh composed of these different uh different parts and I mentioned earlier that
um uh composition is often described in terms of a has a relationship well we can see here that a car has an engine uh a car has wheels uh a car has a chassis so you can see this is a good example of a composition relationship and uh in this example the car class uses composition to assemble it it components the car class is composed of all of these items where each component um for example the engine or the wheels is a separate class responsible for its own functionality and the car class contains instances of these component classes and
delegates tasks to them and you can see here in this uh start car method you can see that this car class is delegating work to these component classes it's saying engine start Wheels rotate chassis support seat sit it's delegating that work to those classes rather than doing that kind of work itself uh and so to start a car all we have to do is create a car object and I believe it is this one and we run the start car method and we run this uh this program and we can see that all of this work is has been has been delegated to
each of these component classes so as you can see in summary we have a car class which is composed of multiple components and it delegates work to each of these components so let's now take a look at the differences between composition and inheritance and when you should probably use composition and when you should probably use inheritance so let's first have a look at when you should use uh composition so you should use composition when you need more flexibility in constructing objects by assembling smaller reusable components
so a good example for this is a car class which is built from multiple components or multiple smaller objects such as an engine uh Wheels chassis uh its seats its dashboard uh GPS all these kind of things a car can be uh constructed from or composed from so um a composition provides us good flexibility and uh constructing objects from uh smaller reusable components uh you should also reach for composition when there is no clear is a relationship between classes and a has a relationship is more appropriate so for
example a car is is a engine doesn't make any sense uh whereas a circle is a shape does make sense so maybe inheritance would be uh an okay solution there whereas uh with uh the car and the engine a car has an engine so composition would uh make more sense so that that seems to be a good solution to start with and you should also use composition when you want to avoid the limitations of inheritance such as tight coupling and also the fragile Base Class problem and this is a a problem which we are going to look into shortly but for now
let's take a look at the advantage advantages uh of inheritance and when you should probably reach for inheritance so you should reach for inheritance when there is a clear is a relationship between classes and subclass objects can be treated as instances of their superclass so for example a uh a circle or a square can be treated as shapes for example which is their superclass uh inheritance can also be used when you want to promote code reuse by inheriting properties and behaviors from existing classes and uh inheritance can be used
also when you want to leverage polymorphism to allow objects of different subclasses to be treated uniformly through their common superclass interface so the fragile Bas class problem is a software design issue that arises in objectoriented programming when changes made to a base class can inadvertently break the functionality of derived classes this problem occurs due to the tight coupling between base and derived classes in inheritance hierarchies so let's now have a look at what are the issues caused by the
fragile Base Class problem and then we'll look into why we should probably use uh what generally you should probably reach for composition over inheritance for uh most of your Solutions so let's first of all consider a a simple example so let's say we have a shape class which is our Base Class and let's say we have lots of different derived classes or subclasses uh which are going to be actual shapes such as a square rectangle circle triangle Etc okay so our shape class is our base class and then we have lots of
different derived classes so first of all one of the issues with using uh inheritance or having a fragile base class uh not necessarily inheritance but having the fragile Base Class is inheritance coupling so inheritance creates a strong coupling between the base class or the super class and the derived classes or the subclasses any changes made to the base class can potentially affect the behavior of all derived classes so if we change our shape class in our example it could affect the behavior of all of our
derived shape classes okay so another issue is limited extensibility so the fragile Base Class problem limits the extensibility of software systems as modifications made to the base class can become uh increasingly risky and costly over time developers May avoid making Necessary changes due to the fear of breaking existing functionality and this is kind of known as brittle software where making a change to one part of the program can cause uh all sorts of different parts of the program to uh break making it uh brittle so this is
kind of um if if we have like a base class where we hundreds of different uh uh subclasses or derived classes then you can kind of see that uh making changes to this base class uh becomes very risky because um it could have an effect on so many different uh derived subclasses and it could cause all sorts of uh issues and uh it can break a lot of the existing functionality and this is uh very much a good example of having a fragile Base Class where we have lots of derived classes over time and making changes to this Base Class becomes very
risky so how can we mitigate uh uh or prevent having a fragile based class in our uh software so to mitigate the fragile Base Class problem software developers can use design principles such as the solid open closed principle and they can also use uh the dependency inversion Principle as well as using composition over inheritance and these approaches promote loose coupling encapsulation and modular design reducing the impact of changes in base classes so generally it's often recommended to use composition over inheritance and the
reason for this uh is because composition results in less coupling and more flexibility and it's also easier to build classes out of various components than it is to try and find commonality between them and build a family tree as you kind of have to do with inheritance so uh there are still cases where inheritance makes more sense but generally it's uh recommended to reach for composition uh more so than inheritance due to uh those uh reasons so uml stands for unified modeling language and it is a language used to
model our systems or our relationships between our classes in our program and throughout this course I've decided to handdraw the uml diagrams uh as it's quicker for me and gives me more flexibility to annotate them uh but you could also use a web app such as this one that I have linked here and if I just show you this this one you can see that you can create your uml diagrams with a sort of uh GUI um but you can also handdraw them if you find that easier such uh and that's the case for me so first of all I'm
going to show you how you can represent a simple class using uml so let's say that we have a dog class a public class dog which has one field uh which is just a private string with uh of name and we also have a method called bark which returns void and just logs uh a wo woof so this can be represented inl as as this diagram so at the top of the uml diagram so we just have a sort of box here and then we have three sections and then we have the class name at the top we have the fields listed in this next section and then we have the
methods listed in the bottom section so if we have a look at this name field now we can see that this is a private field so first of all we specify the access modifier in this case it's a negative sign which means that this is a private field uh the name of the field which is name and then we specify the return uh sorry the type of the field after a colon which in this case it is a string and then we have the methods uh so we have one method uh and we have a plus sign here which means that it's a public
method and it's called bark and it has a return type of void so after the call one we can just leave a blank space which means that it returns void and if you use the modeling app that I referenced uh earlier and then it would look something like this so same thing just a computer computer drawn version so we've discussed all of this um and also I should just mention that if the access modifier is emitted so if I've left the access modifier out then you should just assume that fields are private and methods are public okay so
if I leave out the negative sign or the plus sign you can just assume that this is a private field and you should assume that this is a uh public uh method okay so that's just a kind of convention that I've used throughout this book um yeah so now let's have a look at how we can represent inheritance relationships using uml so inheritance relationships are represented by an arrow so we can see here that the dog class inherits from or extends the animal class so we have an animal class here and it is extending
and dog is extending or inheriting from the animal class okay so if we have a look at the uh how this would look in code we have a a public class dog and in cop we represent inheritance with a colon so we can see the dog inherits or extends the animal class and this is like um inheritance is kind of like an is a relationship so here we're kind of saying like a dog is an animal okay so that is inheritance uh composition is represented by by an arrow with a filled Diamond so here's the filled diamond and
here is an arrow and composition is kind of like a has at relationship so we're saying dog has a size okay so here's the sort of computer drawn version um so how is how would this look in code so we have our dog class and then we're saying that dog is composed of h a size class okay uh and here we have a field of size okay and if you if you're unsure on what composition is exactly uh and you know the difference between composition and inheritance then I will be covering that uh shortly Association relationships are
represented by an arrow and they're kind of similar to uh composition relationships however there is a difference between uh Association and composition so Association uh a good example example for this is a person has a car so a person has a field for uh owning a car but a person is not composed of a car a person holds a reference to a car so that it can interact with it but a person can exist without a car so this is an association relationship whereas with composition uh is when a child object wouldn't be able to exist without
its parent object for example a hotel is composed of its rooms or holds reference to its rooms and a hotel bathroom cannot exist without a hotel without the hotel class so if you destroy the hotel then you also destroy the hotel bathroom the hotel bathroom cannot exist by itself otherwise it's just a bathroom it's not a hotel bathroom also if a customer is destroyed they shopping cart and orders are lost too therefore a customer is composed of shopping cart and orders and if orders are lost then order details
and shipping info are also lost so orders are composed of shipping info and Order details so that is the main difference between Association and composition Association is where the uh if you destroy say a person uh class then the car class can still exist because a person isn't composed of or sort of made up of cars it's just that a person can own a car so so that so that the person can interact with the car whereas composition on the other hand is where um if you destroy the CL the sort of class that is made up of it of these uh
other classes or composed of these other classes then these other classes are also destroyed so that's the difference between Association and composition so now we're going to have a look at depend relationship which is represented by a dashed Arrow so here you can see that dog um depends has a dependency of documents okay so what does this mean so here we have a public class dog and we have a render method and we pass a document to this render method so you know presumably this means that we are rendering the dog onto some documents
and we can pass the documents uh into this render method so above documents is not a field in this class okay but it is used somewhere in the class in this case it's a parameter to this render method but it could it could also be a local variable defined in the render method So within this render method we could say VAR documents equals new documents and then that would also mean that dog has a document dependency so somewhere in dog class we have a reference or dependency to the document class okay and that is a
dependency relationship so essentially we have a parameter or a local variable in one of the methods and that is as um called a dependency relationship so uh that is all of the uml uh that I want to discuss for this course there are uh many other relationships that we could discuss but that is all we all that you need to know for uh studying uh design patterns so one final thing that you should understand before beginning to study design patterns are the five solid principles so here are the five solid principles and the design patterns that
we're going to learn in this course are very much based on both objectoriented programming principles that we covered earlier as well as these five solid principles so they're very crucial to understand so first first of all we're going to learn the S of the solid principle so this is an acronym in case you've not noticed and that is the single responsibility principle we're going to also learn the open close principle the lisof substitution principle the interface segregation principle and the dependency inversion
principle so by following these principles developers can create software designs that are easier to understand maintain and extend which leads to higher quality software that is more robust and adaptable to change so let's get started learning the solid principles so the first solid principle is the single responsibility principle which states that a class should only have one reason to change meaning that it should only have one responsibility or purpose and this principle encourages you to create classes that are more
focused and perform one single well- Define task rather than multiple tasks so by breaking up classes into smaller more focused units makes code easier to understand maintain and test so first of all what we will do is we will create an example that violates the single responsibility principle and then we will refactor that code so that it aders to this principle so first of all what we're going to do is we're going to create a uh user class and this is going to have uh two uh C Properties uh so we're going to have a
username and we are going to have an email uh property and we're also going to have in this user class a method for registering a user so once they sign up to our platform uh this should be register this method will be called once the uh while the user is signing up to our platform and at the top we're going to have some register user logic here so this logic would be uh stuff like fetching the user from the database by their email and if they already exist maybe we could redirect them to the login page uh all that kind of stuff
related to registering a user saving them to the database uh and then once all that's done we can send the uh user an email notification okay so we're going to create a uh an email uh sender class now for sending email notifications and this email sender is going to have a send email method which takes an email that we want to send the email to and we will have a message and in here we're just going to console log uh and we'll say sending email to recip uh let's see send an email to email and then we will put the
message okay so now we can uh use this class to send the user an email notification once they've signed up successfully so we can say email sender and then the message we'll say Welcome to our platform okay so in this example this user class is actually violating the single responsibility principle because it uh it manages user data okay so it contains uh all data related to a user such as their username or email and it also contains the logic for registering a user okay so this class has more than one reason
to change so you can see here that the single responsibility principle states that a class should only have one reason to change meaning that that it should only have one responsibility or purpose but this class has two reasons to change because if we change uh if we make modification to our user data management uh for example we might add more Fields here we might add first name gender Hobbies age all that kind of stuff uh if we add that to to our user we would have to modify this class we'd have to mod add more Fields
uh but another reason to that we we could modify this class um or another reason why this class uh would need to be changed is if we changed the logic of registering a user for examp example we may choose to fetch a user from the database by their username rather than by their email so we now let's refactor this class so that it uh satisfies the single responsibility principle so to do that we can create a separate class called user service so let's do that and in this user service class we will we will put all of the methods or all of
the business logic uh related to uh registering a user or maybe logging a user in or updating a user all those kind of methods can go into this user service uh but we do need access to certain user data so what we can do is we can just pass the user into this um method and then we can call user. email okay so in this refactored code the user class is now solely responsible for representing user data okay so it has one responsibility a single responsibility and the user service uh the user service class now handles user
registration uh and this class can contain all sort of business logic related to users So currently we only have a register function but we could also have a login method or an update method um to manage uh any sort of business logic related to a user um and this re this separation of responsibilities aders to the single responsibility principle and so it makes our code easier to understand maintain and extend the open close principle states that software entities such as classes modules or functions should be
open for extension but closed for modification and this principle promotes the idea that existing code should be able to be extended with new functionality without modifying its source code so and it encourages the use of abstraction and polymorphism to achieve this goal allowing for code to be easily extended through inheritance or composition so if that doesn't make much sense to you we're now going to go through an example uh where we have a shape class hierarchy that calculates the area of different
shapes and initially this is going to violate the open close principle because when we add any new shapes uh it requires modifying uh the existing code so first of all what we're going to do is we're going to create date and enom for uh our types of shapes okay so we're just going to support a circle and a rectangle initially and we're going to create a class uh for shape and this is going to be a class which stores the shape type uh and radius length and width so it supports lots of different
shapes okay so I'm just going to paste those in so we have a shape type so it going to be for example a rectangle or a circle so it's it has a radius so if the shape is a circle we're going to set the radius if it's a rectangle we'll set the length and width and then we're going to have a method for calculating the area of the shape and we're going to have a switch statement which takes in the type of the shape and it's going to look at the type of the shape so for example if the shape
type is C Circle we are going to return uh P pi r 2 which is the equation for calculating the area of a circle so math. po so this is just the radius squared radius to the^ of Two And if the shape type is a rectangle we are going to return the length times the width okay and if our uh shape type doesn't match any of the uh shape types here then we're going to throw an exception to say that we do not support this shape type okay so in this
example uh the shape class has a method for calculating the area of a shape based on the type of shape so if we add a new shape such as a triangle so if we added a triangle in here and then we wanted to support calculating the area of a triangle angle it would require modifying this existing shape class okay so if we add a new shape every time we add a new shape we have to modify this shape class we may have to add uh new properties to support triangles we may have to add things like the uh hypotenuse the um uh whatever the other sides of a
triangle or I've forgotten and then we have to calculate the area of uh a triangle okay so this this class is just going to keep on getting modified every time we had a new shape this calculate area method is just going to get bigger and bigger and bigger it's going to be hard to understand and every time we add a new shape we risk adding bugs into code that has been tested and we know and we know works so this is a really poor uh way to implement a uh this kind of uh application or functionality so let's now refactor this
code to adhere to the open close principle so that whenever we add a shape we don't have to modify any existing uh code so essentially we want to allow for extension which means adding uh new classes to our codebase for example uh we we can extend our code Base by adding a new shape but we don't want to modify our existing class existing source code so now let's refactor this code uh using inheritance and polymorphism so I think what I'm going to do is I'm going to Let's remove all of these properties
from the shape uh class and let's remove all of this and what I'm going to do is I'm going to make this class abstract meaning that we can create uh methods that essentially have no uh body okay like that so that when we in any classes that inherit this shape class now have to provide their own implementations of this calculate area method so what we're going to do now is we're going to create uh individual shape classes so we're going to create a circle class and this is going to uh inherit
shape and when you can see we have an error here so if I press command and full stop or I guess control full stock on Full Stop on Windows we can then implement this abstract class so we now override this uh calculate area method from the uh shape abstract class Okay so so this is an abstract class and then we are providing uh concrete um implementations of shapes okay so circle is a concrete implementation of the shape class and concrete basically meaning that it's not abstracted you know it's a proper normal
class so in here to calculate area we need to do p pi r squ so now we need to uh store a property for radius and here we can just return uh math. pi times math. power radius to the power of two okay so there's our Circle class and now we want to add a rectangle class so let's add that and a rectangle has a length and a width so we'll add properties for length and width and then to calculate the area of a uh rectangle we just return the length times the width okay but what we need to do here is make sure that we uh
inherit the shape now it gives us an error because the shape if we inherit shape it's forcing forcing all of the concrete shapes to implement the calculate area method so let's Implement Implement that and we just want to return the length times the uh width Okay so we've now refactored the code so that we have individual shape classes rather than having this shape class which kind of man manages multiple shapes and this actually also satisfies the single responsibility principle because the shape class now isn't
managing uh calculating the area well it isn't managing multiple different types of shapes and we now have individual shape classes rather than having the shape class manage all of the different types of shapes so in this refracted code we Define an abstract shape class with an abstract calculate area method and we Define uh concrete uh shape classes uh Circle and rectangle which inherit the shape class class and provide their own implementations of the calculate area method so now with this new solution
whenever we add a new shape such as uh a triangle it would involve creating a new class which inherits from shape and implements the calculate area method uh without having to modify any existing code so if we wanted to create a if we wanted to add a triangle uh shap shape and we wanted to add the ability to calculate an area we would just create a new triangle class uh with which extends shape and includes the calculate area method and that's it we just extend our code base we add a new class without having to modify any existing code so
we're not risking uh adding bugs into previously tested working code and that satisfies the open close principle by allowing for extension without modification so being able to add functionality without modifying existing code means that we don't have to worry worry as much about breaking existing working code and introducing books so following the open close principle encourages us to design software so that we can add new features only by adding new code and this helps us to build Loosely coupled maintainable software
the listof substitution principle states that objects of a super class should be replaceable with objects of its subass without affecting the correctness of the program so this principle ensures that inheritance hierarchies are well-designed and that subclasses adhere to the contracts defined by their superclasses and violations of this principle can lead to unexpected Behavior or errors when substituting objects making code harder to reason about and maintain so this is very confusing so let's consider consider an
example involving a rectangle class and a square class which inherit from a common shape class and initially this is going to violate the lisof uh substitution principle by not adhering to the behavior expecting uh expected from these classes and then we'll fix it to ensure that the principle is respected so first of all we're going to create a shape class and this is going to be an abstract uh class this is going to be this is going to sit at the very top of our uh sort of shape class hierarchy and we're going to create a public
abstract uh property uh for area and so all shapes should have this area property so next up we're going to create a concrete implementation of our abstract shape class so we're going to create a uh rect angle class and this is going to inherit shape and then we can press command full stop Implement abstract class and we can see vs code automatically uh implements this area property for us so if we look at a rectangle a rectangle has a width and a height so let's add properties for width and height
because we need those properties to be to be able to calculate the area of the rectangle and the area of a rectangle is very simply just its width times its height okay so that's a rectangle uh we're now going to create a square class and this is where things get slightly more interesting because the way we're going to implement the Square class is we are going to extend or inherit from the rectangle class and why are we doing this because well a a square is mathematically just a special type of rectangle where the width and the height
are equal to each other okay so that's our line of thinking we're just thinking right a square class is a special type of rectangle a square is a rectangle so let's actually inherit the rectangle class uh but we need to make a few modifications because if a square if we set the width on a square then we can't we need to make sure that it's equal to the height and if we set the the height on his uh square and we need to make sure that the width is also set equal to the height so that the side lengths are always the
same and a square always remains Square so let's actually do that so what what we can do is we can override the uh width property and we can say that uh the GAA Remains the Same we just return the width the base referring to our base uh class which in this case is rectangle and then we can update the seta so that the uh base dot width is equal to the base dot height which is equal to the value that we are setting to okay so the width and the height are always going to be equal and then we can do the same for the height and I'm just
going to save a little bit of time here and copy and paste that in so as you can see uh the GAA just Returns the the height and when we set we also set the width equal to the value that we are setting to okay so a square always remains Square okay so now what we're going to do is we're going to write a test um and in the test what we're going to do is we're going to make sure that our program is calculating uh areas correctly or as expected so we're going to create a rectangle and we're going to set the
rectangle's height equal to 10 and we're going to set the rectangle's width equal to five and then we can say that the expected uh area is going to be equal to 10 Time 5 which equals 50 okay and then we can log the actual area that the rectangle calculates um by calling re. area so if we' run this program we can see that the expected area is equal to the calculated area and this test passes successfully but now if we look at the lisof substitution principle uh objects of his super class should be replaceable with objects of
its subass so the super class in this CL in this case is rectangle and a rectangle subass is shap uh Square sorry because a square is a subass of rectangle in this case right it inherits from rectangle so according to the lisof substitution principle we should be able to substitute a rectangle for a square and our program should still be correct so let's see if that works so we we substitute it for a square run our program and we can see that the expected area is 50 but the calculated area is 25 because when we set the width it also
sets the height to five as well so then when it calculates the area it's going to be returning height time width which is 5 * 5 which equals 25 and this is not what we expected so we are here violating the list lisof substitution principle you you can kind of see how this makes it it easier for a program to contain books because if we treat a square as a rectangle which according to our code we should be able to we we shouldn't get any errors but we are getting errors this P this test no longer passes so let's um refactor our program
to to satisfy the lisof substitution principle so what we are going to do is we're going to modify our uh Square class so that it no longer inherits from rectangle okay so what we're going to do is we're going to inherit from shape okay we're just going to say a square as a shape and not a rectangle okay so and a square really it doesn't really feel feel very correct to store width and height properties on a square it doesn't really make much sense because a square just has a side length and all the side
lengths are equal it has four sides and each side is an equal length so really we only need to store one property called side length so if we create a public uh property for side length and also we can see here that we are getting an error because we need to implement the shape abstract class by providing an area uh property and the area is just going to be the side length squared or the side length times the side length Okay so we now have a rectangle and a square which are both shapes they both inherit the shape class so
so now let's create a test for our uh square and rectangle so what I'm going to do uh let's uh comment this out for now and we'll create a new test so we're going to just say shape rectangle equals new rectangle and I think what we'll do actually is we'll just set the uh width and height when we uh create the rectangle just to save a little bit of a few lines of code okay and then what we will do is we will log the uh area of the rectangle okay and then what we'll do is we'll also create a
um a test for our Square class and as you can see here both rectangle and square are shapes they are classes of type shape and we're going to create a new square and we will set the side length equal to five and then we can say area of the square is equal to square dot area okay so here we're expecting 25 because 5 * 5 is 25 and above we are expecting 20 okay okay perfect so now what we can do is we can essentially uh we've we've redesigned the square class to directly set the side length so now that uh so now a square is correctly
modled as a subclass of shape and it adheres to the lisof substitution principle because now all shapes are substitutable with each other and they they calculate their uh areas uh correctly okay or as expected so how does this satisfy the of substitution principle well we've created a super class called shape and subclasses rectangle and square okay and both rectangle and square maintain the correct expected behavior of a shape uh and in our case that is providing an area and they should both behave appropriately when interacting with
other parts of the program that expect shapes so we can now treat rectangle and square as shape uh of type shape and they both always uh calculate areas as we expect them to the expected area of a square here I mean we haven't logged what the expected area is but we could log that the expected area is going to be 25 and we here we could log that the expected area is going to be 20 okay and whatever we change the side length to whatever we set the side length to it's always going to uh give us the corre correct area Okay so shapes
now are always going to return the correct area we have no problems with substituting shapes with other shapes and then calculating their areas okay so now we are satisfying the lisof substitution principle and our program is less error prone okay less prone to introducing bugs and um uh less prone to unexpected Behavior the interface segregation principle states that clients should not be forced to depend on interfaces that they do not use and this principle encourages the creation of fine grained interfaces that contain
only the methods required by the clients that use them it helps to prevent the creation of fat interfaces that Force clients to implement unnecessary methods leading to cleaner and more maintainable code so this may sound confusing again but actually this principle is pretty straightforward so let's consider an example that involves 2D and 3D shapes and we'll initially we're going to violate this interface segregation principle and then we are going to refactor that code to adere to the principle so first of all we're going to
create an interface called I shape and this is going to contain a methods for calculating certain properties on a shape so such as as area or volume okay so now what we're going to do is we're going to create a uh Circle class a concrete Circle class uh and that's going to uh implement this I shape interface okay so we're getting a red red squiggly line here which means that we need to implement this interface or you know implement the methods on this interface so so a circle class is going to have a radius
property and what we're going to do is to calculate the area of a circle we just quite simply do pi r 2 so we do we're going to return pi times uh the radius to the power of 2 and then for calculating the volume well here we have an issue because circles don't actually have volumes because they are a 2d shape all 2D shapes don't have volumes they only have areas so here we've been forced to implement this volume method from I shape because I shape states that we must Implement a volume method otherwise
we'll get an error so what we're going to have to do here really is we're going to return an invalid operation exception and we'll say that volume is volume not applicable uh for 2D shapes okay so um so that is the circle and now we're going to uh create a 3D shape now called sphere so basically a ball and this is also going to implement the I shape class uh sorry the I shape interface and we press command full stop or control full stop and we're going to implement the uh methods on this
interface so to calculate the area of a sphere we have to do the uh radius uh to the^ of 2 * piun * 4 that's just the equation for calculating the uh area of a sphere so I'm just going to paste that in so we we have 4 * pi * the radius squar and then the volume of a sphere is this equation so it's uh four 4/3 or 4 over 3 * piun * the radius cubed Okay so so 4/3 pi R cubed okay so this all looks okay I think what we'll do next is we will create uh we will actually use this solution so let's create a circle if we
come into program.cs and we will create a new circle from the from here and we'll set the radius equal to 10 and let's log the area and let's also log the uh volume okay so according to vs code um we have no problems here this this code should be safe to run but if we run the code um we can see that we get an ex exception because volume is not applicable for 2D shapes we are uh in our program we are calling circle.
volume and VSS code even suggests that we can call this function uh this method and everything looks okay but when we run the code we have a problem so really this volume method should not exist on Circle because it really well all 2D shapes don't have a volume so it just doesn't make any sense it's making our code more prone to bugs by allowing us to call this method on a circle so it's it's easy to see that uh how violating this interface uh segregation principle can introduce bugs into a program because
above everything looks okay until we run the program and then we get the exception thrown um because this I I shape interface is forcing forcing us to implement volume methods on all of our shapes even when it's not relevant so how can we solve this problem so let's refactor our code so what we're going to do is we're going to we're going to segregate this I shape interface into two separate interfaces so we're going to create a i shape 2D and an i shape 3D so this actually can be changed to 3D because 3D shapes have
both an area and a volume so I'm just going to rename this file to I shape 3D and I'm going to create another interface called I shape 2D and 2D shapes only have an area they don't have a volume volume okay and again this should be an interface not a class okay so now we have we've segregated the ey shape interface into two separate smaller uh more sort of finely fine grained interfaces that are more specific okay rather than large and sort of general and now what this allows us to do is in our Circle class we can
implement the I shape 2D and we can remove this volume uh method because we are no longer being forced to implement a volume method and then in our sphere class we can implement the 3D uh interface and now if we go back into our program we can see if we try to call volume on a 2d shape we are now getting an error so vs code is straight away say this method uh does not exist basically and and it shouldn't exist because 2D shapes don't have uh volumes so as you can see the interface segregation principle ensures that
clients are not forced to depend on methods that they do not use clients can now depend only on the interfaces that they need promoting better code and reusability and if you are't sure on what a client is a client essentially just means classes that are using the uh shape interface okay so for example a circle is a client of the I shape 2D interface the dependency inversion principle states that highlevel modules should not depend on low-level modules both should depend on abstractions so dependency inversion is
the strategy of depending upon on interfaces or abstract classes rather than upon concrete classes this principle promotes decoupling between modules and promotes the use of interfaces or abstract classes to Define dependency uh dependencies allowing for more flexible and testable code so this probably doesn't make any sense whatsoever so we're going to start with an example that first violates the dependency inversion principle and then we are going to correct it so first of all I'm going to create an engine
class and the engine class is just going to contain a single method uh called start which is just going to log uh engine started okay and then we're going to create a car class and car is going to be built up from different parts and one of those parts is an engine a car of course would also have wheels and a chassis and all different uh other things that it will be built up from but we're just going to keep things simple for now and just include the engine and uh we're going to have a Constructor for this
car and in the Constructor we're just going to set the engine so we'll just say this. engine equals new engine so we have uh this car class which has a direct dependency on this concrete engine class and this car class is also going to contain a method for starting the car and to start the car we actually need to start the engine so we can start uh we can call engine.
start and we can just log car started okay so in this example the car class directly creates an instance of the engine class leading to a tight coupling between core and engine so if this particular engine class changes it may affect the car class which violates the dependency inversion principle so if I just show you the uml diagram what we have here we have a car class which depends directly on a concrete engine class okay so let's go back here so how can we fix this uh issue well first of all let's let me just uh
discuss what the issues with this Implement with this solution are so uh if we change the engine class then it could break the car class okay so that's uh a problem if we if we change the implementation details of this engine class it can affect the car class and another thing is is that this code isn't very flexible so if we go into program.
cs and we create a car uh that's not the correct one uh let's see okay uh we actually have no way when we when we create a new car we have no way of changing the type of engine that that car is built with so uh currently if we want to change the type of engine so say we have currently we only have one engine class but say we have another class called uh electric engine or I don't know V6 engine or some other powerful engine there's no way of uh changing the engine type when we create a new car you know we can't just
add the engine uh in here we have to change it within the car class okay so this isn't very flexible so if we wanted to say electric engine we would have to come in here and change it to electric engine and obviously we would need to create that class so this is not a very flexible or maintainable solution because we're having to modify uh existing source code in order to uh change the type of engine that a car uses so this isn't very good so uh we can fix this uh uh to adhere to the dependency inversion principle we
can introduce an abstraction or an interface between core and engine allowing core to depend on an abstraction instead of a concrete implementation so let's come into our uh folder and create an interface called I engine and in here we're going to have uh we're going to that all engines should have a start uh method then inside of our uh engine class we can say that engine implements I engine okay so an engine is an engine obviously and we don't need to do anything here because our engine class
already has a start method and then in core So currently we have core depend depending on the concrete implementation of an engine rather than an abstraction such as an interface or an abstract class so let's change this so we can say that rather than engine being this concrete engine we can say um we can say the engine is some some type of engine some abstract engine and then within the core Constructor we can specify we can actually pass a type of engine that we want the car to be built with so we can say this. engine equals engine
okay so the advantage of this method is that it provides us with a lot more flexibility because now whenever we create a new car we can at runtime we can pass in what type of engine that we want the car to be built with like so and currently we only have one type of engine but let's just say we also had another type of engine that implements the i engine interace face such as electric engine then we can create some sort of electric car we can build this car up uh with an electric engine okay so this is called dependency
injection where we inject the dependency into uh the class okay and this is a very popular term that you may have heard before uh Frameworks such as laral or spring boot uh use dependency injection throughout a lot of the framework so let me show you the uml so what this looks like so beforehand we had car which directly depended on engine whereas now we've added this kind of abstraction this interface between car and engine so car now depends on this abstract engine interface and engine implements uh the engine interface okay
so now we can create multiple different different types of engines each in uh implementing this interface so we could have um a V6 engine which implements this engine interface or an electric engine and we can then inject that engine whenever we create a new car object into car to be built with that type of engine so this has really improved the uh flexibility of our uh program so um a few uh advantages that I just want to mention of dependency injection or that uh dependency injection uh promotes loose coupling between
components by removing direct dependencies uh so that comp uh components rely on abstractions rather than concrete implementations making them more independent and easier to maintain and dependency injection simplifies unit testing by allowing components to be easily replaced with mock or stub implementations during testing this enables isolated testing of individual components without relying on their dependencies and as we discussed it improves flexibility because we can swap out dependencies at runtime uh and then one more thing that
I just wanted to uh mention so if we go to the dependency verion principle uh kind of definition it states that highlevel modules should not depend on low-level modules both should depend on abstractions so we saw that car and engine are now depending on abstraction and abstraction the i engine interface rather than on each other but which which of these is the high level module and which is the lowlevel module so um so the engine is actually considered the lowlevel module or the lowlevel abstraction because it deals with uh specific
detailed operations related to power generation whereas the car in this case would be considered the higher level uh abstraction or the higher level module because uh it encompasses a broader scope coordinating uh multiple components including the engine So currently we only have the engine but in a real car would of course have multiple components uh and to deliver the overall uh functionality of the vehicle so the car is the higher level module and the engine is the lower level module and the high level module no longer depends on
the lowle module they both depend on an abstraction and therefore our code is much more flexible and much more testable uh easier to maintain and that is g to uh the dependency inversion principle so now we can start looking at design patterns and there are three main groups of design patterns there are creational design patterns and these are related to the different ways to create objects there are Dru uh structural design patterns and these uh design patterns are related to the relationships between those objects and
then we have behavioral design patterns uh which are related to the interaction or communication between those objects and first of all we're going to have a look at the behavioral design patterns behavioral design patterns focus on how objects interact with each other and how they communicate to accomplish specific tasks these patterns address communication responsibility and algorithmic issues in objectoriented software design they help in defining clear and efficient communication mechanisms between objects and classes
these patterns help in making the design more flexible extensible and maintainable by promoting better communication and separation of concerns between objects and classes in the system each pattern addresses specific design issues and provides a standardized solution to common problems encountered in software development so if you're unsure on exact what exactly these words mean such as flexible extensible and maintainable then uh throughout this course I'm going to be using these words a lot and you're going to have um
they're going to become part of your uh sort of uh programming vocabulary uh as as you go along this course and yeah these are words that you're going to use uh quite often to describe uh the code that you are uh writing or or analyzing uh and here you can see that we state that these design patterns provide a standardized solution to common problems so for example if you need to uh uh Implement some sort of undo mechanism in your program then maybe you know the first design pattern that comes to mind could be something
like the M momento pattern uh so uh yeah these are design patterns are really nice tools and when you're also uh analyzing other people's code you you're probably going to rec recogize uh certain words or or certain uh yeah certain words that are used in class names and it's going to give you a sort of clue to the solution that the developer went with so that being said let's get started the momento pattern is used to restore an object to a previous state and a common use case for the momento pattern is when implementing an
undo feature for example most text editors such as Microsoft Word have undo features where you can undo things by pressing contrl Z on Windows or command Z on Mac so here are some things that you might want to do in a text editor so you want might want to add a title to the document such as test title you might want to write some text such as hello there my name is Dan and then you might want to update or change the title of the document to the life of a developer my M was and a simple way to implement this text editor in code will
be to create a single editor class and have a field for title and content and also have a field that stores each of the previous values for each field in some list so here we have the uml for a editor class it has a title field and a Content field both of uh type string and then we have a previous titles field which does a list of all of the previous titles so if we update the title it will push the current title onto to this list and then update the title and the same thing for Content okay we have a prev previous content list too uh so but the
problem with uh this solution is that every every time we add a new field such as author date or is published uh we have to keep storing a list of previous States or all of the changes for each of the new Fields so you can see that this editor class is going to become very bloated with a large number of fields and also how would we actually implement the undo feature with this solution because if the use the change the title then they Chang the content then pressed undo the current implementation has no knowledge of what
the user last did it doesn't know whether the title last changed or the content last changed and so when undo is pressed our solution doesn't really know whether we should undo the title or undo the content or both at the same time so this isn't a great solution so let's uh think of a better way of doing this so instead of having multiple fields in the editor class we could create a separate uh class to store the state of our editor at any given time so here we have our editor class title content fields
and now we have a list of previous state objects and this is a uh State object which stores the title and content of the editor at at any given time and note that this is a composition relationship uh represented by the diamond Arrow uh where editor is composed of or has a field of the editor State class and it has a list of editor States and this is a better solution because we can undo multiple times and we also don't pollute the editor class with too many fields we just have one field for storing a list of editor
States however this solution is violating the single responsibility Principle as our editor class currently has multiple responsibilities it is currently uh managing the state of the editor so it is storing a list of states and it's also providing the features that we need from an editor so what we should do is we should take all the State Management stuff out of the editor and put it somewhere else into some separate class and this is what we end up with so now we have a separate class called history which is basically managing the
uh list of states or list of previous States uh from our editor so here we can see that we have a create State method inside of the editor and the create State method simply returns an editor State object or the current state of the editor uh and that and that is represented by a dotted line L Arrow uh here so we can see that editor has a dependency of editor State because one of its methods is returning and editor State object which is the create State method uh is returning this editor State object and then we also have a history
uh class which has a field with a list of editor States hence the diamond Arrow or composition relationship uh represented here so um history this history class we have a backup method and the backup method whenever this is called it will add uh onto the list of states the current editor state so editor.
 create State Returns the current state of the editor and then we push or add it onto this States list okay which is storing our sort of history from the editor and then we also have an undo method in this history class which basically gets or uh yeah pops off the last state from the states list uh it then removes that state from the list and then restores the editor to that last state so that is how we sort of implement the undo feature now so um this is actually the moment momento pattern this uh kind of represented by this uml
diagram uh but let's have a look at how the momento pattern is represented in in the gang of four uh book so here are the abstract names that each class would be given in the gang of four book so um here we have the originator which is uh analogous to our editor class we have the momento which is basically our state object and then we have the caretaker which in our case is called the history object um and um we can see that our solution actually differs slightly from the uh original ganger 4 um uh momento pattern
as our caretaker uh our caretaker class which is the history class also has a field that stores a reference to the editor class so that the history class can restore the editor State when the user clicks undo so when the user goes into their history clicks undo then we have a reference to the editor class so we can actually call editor.
 Restore and pass in the state that we wanted to restore the editor too and that's just nice sort of convenient uh way of doing that and it works for uh our kind of program or our application so you can see that the with these design patterns they are not you don't have to follow them exactly you can uh change them slightly it's just the general uh shape or idea that um we can um we can kind of follow okay so you don't have to follow them exactly they can be uh customized or slightly changed but the general
shape is still there this is still the momento pattern okay so now what we're going to do is we're going to implement this uh solution in code so that it makes more sense to you so first of all we are going to create our editor class or using the gang of for abstract name that would be the originator so let's come into here and create a new C Class called editor and I'm just going to make a note to say that this is the originator okay so our editor has uh currently just two Fields it has a public uh string
field sorry it has a property it has a public public property uh for title which can which has a getter and a Setter and it has a public property called content and we have a geta and Setter for that and we're now going to create um the uh momento or the editor State uh class okay so let's come into here and create a new SHP class called editor State and editor state is just going to uh store two Fields so it's going to have two private fields and I'm going to make these read only so that once the
editor state is created uh it cannot be changed so that's going to just add to the robustness of our code because once the editor State uh has been created once we've took a backup of our editor then we shouldn't then be able to uh edit that okay it should just be sort of constant so let's create a field for title and a private readon string for Content okay so now what we're going to do is we're going to create a Constructor and in the Constructor we can pass in the title and content
and then we're just going to set our title and content uh and then what I want to also do is create a geta for title so that we can actually uh retrieve the uh title uh for this current state so we'll create a method called get title and that is very simply just going to return the title and we'll also create a gter because we will need access to the content if we're going to restore uh the content and the title to previous States uh we're going to restore the editor to a previous state then we need to be able to actually get
the uh the title and the content from this editor State object so let's create another geta called get content and we're just going to return the content and what I'm also going to do here is in this editor State object I'm going to add uh some State metadata okay and I'm going to make it private read only and I'm just going to store the date that the state was created at and I'm going to call the state created at and what I'm going to do is when a uh editor State object is created we can
set the state created at uh field equal to datetime do now so whenever we create a backup we're kind of storing the date and time that the backup was created okay so it's just like a little bit of extra metadata uh to give us a little bit more information about the state or when the state was backed up so let's also create a geta for this get uh for this date um field so this is going to return uh a date time uh piece of data and we're just going to return the state created at okay so that's everything we needed to do in our
uh momento object so I'll just make a note that this in the gang of four is referred to as the uh momento object the state object okay so now what I'm going to do is I'm going to come back into our uh editor class and I'm going to create a couple of Meth methods so I'm going to create a method called uh create state which is going to return uh an editor State object okay and this editor state is going to take uh the title and the content okay so whenever we create a state we're just simply returning the
current state of the editor the current title and the current content okay and then to restore the uh Editor to a previous state we can create a restore method which takes in an editor State object and we can just simply set the title equal to that state state title so we can say let me change this actually we'll we'll just call this State and we will say this is going to be equal to state.
tile so get title and then we'll set the content equal to state. getet content okay so that's everything we need to do in our editor class we have our fields in the editor uh we also have a method for creating a sort of backup or um a sort of State object of the current state of the editor and we also have a restore method for restoring the editor to any previous state okay so now what we're going to do is we need to take uh make our uh sort of history class or in the gang of four that would be referred to as our uh caretaker class
so we're calling we're calling it the history uh object or the history class and the history class stores a list of all the previous editor States and we're going to call the states and we'll just set it equal to a new list of editor States and in our case we're also going toore a reference to the editor class uh the editor object okay and then when we construct the history uh object we need to actually pass in the editor that the history class is uh referring to so let's create the uh Constructor and
we're going to pass an editor as a parameter and we're just going to set the editor equal to the editor that we pass into this history object upon object creation okay so now we need to add our backup method so let's create a public uh method called backup and all this is going to do is it's going to uh add onto the states list um the current state of the editor and we have a create State method which does that for us so that's pretty simple and we also need a uh undo method uh so this is going to allow us
to um restore the the editor to its last uh backtop state so what we need to do here is we need to just perform a check to say um to check if we actually have any backed up States so we can say if states. count equals zero then we can just return okay so if we don't have any backed up uh if we have no States in our states list then we can just return here there's nothing to undo otherwise we can get the last state from the editor so the previous state and that's going to be equal to states.
last we can then remove this uh state from the state's list so this is the equivalent of just popping the uh State off of the list off of the end of end of the list and then what we can do is we can call our editor and we can call the restore method and we can pass the last state or the previous state and the editor will be restored to its previous state and what I'm also going to do is a kind of nice uh method that we can add to this history class uh is one called show history where we basically list all of of the uh
all of the history all of the backed up states that we have of our editor so let's actually implement this I'm just going to put a new line here and I'm going to say history here's the list of mos and what we're going to do is we can Loop through all of the uh States and we can just console uh write uh state DOT get uh actually I think we need to add another method to the uh editor State uh class yeah cuz I wanted to call a method called get name but we actually haven't
implemented that yet so if we go back into our editor State uh class we're going to create a another method called get name and this is just going to return something that we can display on the console um to sort of represent the state so uh let's see so what we're going to do is we're going to log the the created ad date and we will also log the uh title okay so this is just basically going to be our kind of uh some way of uh a sort of unique identifier for the uh State object so if we go back into
history we can see the error has disappeared and now everything should be be ready to start using so now if we come back if we come into our program.cs file let's actually test out our momento pattern solution for this editor so I'm going to create a uh new editor I'm also going to create a history uh object and we're going to pass the editor into this history object and it says the name space is missing so let's see ah so we need to move that into here and let's see yeah so we just need to change the
name space here and hopefully that fixes things okay good and then what we can do is we can create a backup of our uh editor so we can call the backup method and then let's change the uh title to test and then let's also back up the editor okay so here we are backing up a sort of blank editor and then we are backing up uh the editor where the title is Chang change to test uh and then we can change the uh let's change the content to hello there my name is Dan and then we can back up again and then we'll change the title to
my momentos why not okay so now let's actually log out what the uh title of the editor is and let's also log the content okay so let's actually just check what is going on here so we can see the title is what we last changed the title to which is this the life of a Dev which is correct and the content is hello there my name is Dan so this is correct um and now what we can do let's test out our undo functionality so let's call history.
backup and uh sorry history. undo and let's actually log the uh title and the content here after undoing so let's see what we got here okay so the title is now test but the content has remained the same so is this correct so the last thing we did is we updated the title uh from test to the life of a Dev so the title should be test and the content should remain the same as hello there my name is Dan so that is correct so that's working correctly the state has been restored uh to its previous state and that is
working perfectly uh let's also test out our history show history function so if this was I don't know a web browser I guess this would allow us to view the list of uh histories I guess or a list of web pages that we have visited and you can see here the backups that we have of our editor uh or our list of momentos uh we can see here we have one where the title is test and one where the title is blank so this is working pretty good and finally let's call uh undo again and then log out the values and we can see the title is test
and the content has gone from uh this to nothing which is correct and then I guess if we do it one more more time we should just get a blank document okay perfect so our solution is working correctly so when should you use the momento pattern so the momento pattern can be used when you want to produce a snapshot of a of an object State and to be able to restore the object to a previous state it's a commonly used pattern for implementing the undo feature and so provides a common solution that a team of developers can quick
understand and get on the same page with so what are some pros and cons of the momento pattern so one of the pros is that you can simplify uh the originator code which in our case was the editor class uh by letting the caretaker or the history class maintain the history of the originator State satisfying the single responsibility principle and this kind of makes our code more easy or easier to understand uh and and improves the readability and also means that um uh our classes have sort of less reasons to change you know uh if we need
to change the way that we store history then we just need to update the history class we don't need to touch the editor class and uh one of the cons of this momento uh pattern is that it can consume a lot of uh RAM or random Access Memory if lots of momentos are created so if we have to create uh thousands of momentos and potentially each momento could be storing a large amount of data for example if we wanted to uh restore a video to a previous state if we had some sort of video editor application then
taking a backup of an a whole video would consume a lot of ram so taking lots of momentos of this would be uh potentially very bad because it could uh slow down the application or cause it to crash so um there are other design patterns that can be used to restore States uh if um the momento pattern is causing uh too much RAM to be consumed the state pattern allows an object to behave differently depending on the state that it is currently in so say that you are writing a BL post using the popular content management system
WordPress and the documents or post can be in one of three states so it can be in draft moderation or under review by an admin or it can be published and there are also three types of user roles within WordPress there are readers that can only read uh posts there are editors that can read or edit posts and there are admins that can read edit or uh create new posts or delete posts and only admins can publish documents okay so if a post is under moderation then only an admin can publish uh that document or that post I should
say so first of all we're going to create a simple solution that uses if else uh if else conditional statements to check the current state of the document to see whether the state of the documents should be upgraded so first first of all we're going to create an enom called document states which is going to store all of the uh possible States for our document or our post and we're going to have a draft State a moderation State and a published State and we're also going to create an enor to store our possible user roles
and we have readers uh editors and admins okay so now I'm going to create uh the document class or the post class and in here we are going to store a uh the current document uh state okay so this is going to be oftype document states which means that it's going to be one of these uh values either draft moderation or published and this is going to be a property so we're going to give it a getter and a Setter and we're going to do the same for user the user role okay so the current user role okay so now what we're going to do is
we're we're going to create our uh publish method so let's create that and this publish method is essentially uh responsible for updating or upgrading the state of the document to the next state so what we're going to do is we're going to write some conditional statements here so we're going to check if the state is in a draft State then we are going to upgrade the state to document states do moderation okay so we're going to upgrade from draft to moderation the next or sort of Step Up where the admin can uh review
the um the state of the document else else if the state is equal to the document states. moderation so if we are currently in moderation State then we need to check the user roles because only admins can publish a document from uh moderation to published so we here we can say if you kidding me keyboard's locked what are you doing okay so here we can say if current user role is equal to user roles do admin we can set the state of the document to
published okay otherwise we do nothing so if the current user is not an admin then they cannot upgrade the state of the document from this moderation state so we do nothing and then what we can say is else if State equals document states do published then we can basically do nothing because there's no higher uh state than published so technically we could get rid of this uh but we'll just leave it here so that uh it's clear that we are doing nothing if the uh document state is already published and one other thing
that we could also add up here uh is that if the document state is in a draft State then we could also check to see if the current user role is an admin and then just uh skip this moderation State and go straight to published that's something that we could do uh otherwise um if the user is not an admin then we go to this state so that's something that we could do but just for Simplicity we'll keep it as this okay so let's actually try to use this solution so if we go into program.cs and we create a new
document and we will need to import this from uh let's see should be from here and let's um set the document state to uh moderation and then let's set the current user role to admin and we will just log the document state okay so let's run this to see what we have and we can see that the document state is currently in moderation which is correct but now if we try to publish the document and we log the document state let's see what we get so the current
user role is an admin and the current document state is in moderation so the admin has moderated or checked that the document is okay they've then clicked the publish button and now the document should be in a published state so let's check if it is in a published State correct so the documents has gone from moderation to published but if we change the user role to uh something less than admin such as an editor editors can't publish uh documents they need to be checked by an admin before being published so now we should see
that the state is uh remains in moderation and that is correct we get two logs of moderation so that is all working correctly now can you spot the problems with the current document class okay so if you take a look at the document class Can you spot any issues uh is it violating any of the solid principles for example so if you uh check out this publish method we can see there's lots of if else conditional statements right um so what we're actually doing here is we are violating the open closed principle because if we add any other
states or user roles many of the document uh classes methods such as this publish method currently we only have one method but a real document would have multiple methods and we're going to have to modify all of these methods so if we add uh another user role we're going to have even more IFL statements right and this class is going to become extremely bloated uh with all of these if else conditional statements in every single one of its methods pretty much and uh yeah with more States this class is going to become uh bloated
unwieldy and difficult to understand and the code is very difficult to maintain because any changes in logic may require Changing State conditionals in every one of this document classes methods so let's see how we can improve on our solution and solve some of the issues that we encountered where by using the state Pat so the state Pat suggests that we should create State classes for each possible state of the document object now if you remember we have three possible States uh and those were draft moderation and published so that means
we should create three new uh classes for each of those possible States and extract All State specific logic out of this document class and into these individual State objects the document class will then store a reference to one of these State classes to represent the current state that the document is in then instead of the document implementing State specific behavior by itself it delegates All State related work to the state object that it has reference to so here is the uml diagram that we are going to uh
Implement in code so we have a document class which stores reference to a state uh object and it can be uh any one of these concrete State objects provided that these uh concrete objects uh implement the state interface okay so this is going to be a an object of of type state which can be any one of these State concrete State objects and we're also going to store reference to the current user role so uh then we just have a publish uh method which delegates All State related work to one of these uh concrete
State objects so we can see here above that document uh keeps reference to or is composed of uh represented by this diamond Arrow uh a state object and notice that we are using polymorphism as the State field uh in the document class can be any one of the concrete State classes so draft moderation or published as we are coding to an interface not concrete classes so we are coding to the state interface not these individual concrete classes and that improves flexibility in documents the published method calls state. publish and it
delegates the work to the concrete State object so why is this a good thing because our solution now satisfies the open close principle because if we want to add a new state so a new concrete State we create a new concrete State class that implements the state interface we essentially extend our code codebase uh in other words add new classes to our codebase without having to modify any of the current existing classes such as the document class and beforehand if you remember if we added a new state we we had to uh modify
existing code the uh methods in the document class whereas now we just have to extend our codebase by adding a new class that implements the state interface so here's how the state pattern is represented in the gang of four book with its abstract uh class names so we can see here that the uh our document class is the context object which is composed of a state object and then we have a load of concrete States so let's actually now implement this solution with the state pattern in code okay so first of all I'm
going to create the document class and I'm also going to create the state interface and the state interface uh just has a single publish method and if this was a uh a real document it would have more State dependent methods such as render but we're just going to keep it simple for this example with the one publish method so I think now what I'm going to do is I'm going to create the uh document uh class actually create it properly so let's uh give it a field bu uh or property for storing the current
state of the document and we're also going to have uh store the user roles as well uh say so current user role okay and then in the uh Constructor we are going to pass the the current user role and this should be a type user roles and we're going to set the state equal to new draft State and we have not actually made this uh class yet so we'll create this shortly and in here we're going to pass this uh document object okay so um by default what we're saying here is that
when we create a new document the uh sort of default initial state of the document is just going to be the uh draft State okay so then what we can do is we can also set the current user role okay so now we're going to add our publish method and in here we are just going to Simply call uh state.
 publish okay so we're delegating All State specific work to these concrete State objects which we are going to create uh now so let's create the draft State first of all and all states should implement the state interface okay so they all should have a publish method and all states also need to store reference to the uh document object so let's uh keep store a reference to that and then we need a Constructor and we can set the document in the Constructor so what we do here is so if we're in draft State and the uh user uh clicks publish okay so what we should do here
is we should uh change the state of the document to the moderation State we should upgrade from draft to moderation okay so that the admin can review the documents so what we can do here is we can return a new moderation State and we pass the documents okay and we need to pass the documents because each of these states need to have the ability to change the uh State field within the documents okay so now we get a red squiggly line here because we need to create this moderation State object so we create a new C Class called moderation
State and in here again we need to store for uh reference to the documents and we also again need to have a Constructor where we set uh the documents and then remember this uh needs to implement the state interface and if we Implement that interface we will need to implement a publish method and within the publish method we can uh add our logic so if we're currently in moderation state so if we have a look at the old solution we can see that if State equals moderation we need to check the current user role and if the current user role is an
admin then we can upgrade the state to published otherwise we don't do anything so that is the logic for uh when publish is uh clicked uh when we are currently in um in moderation state so what we can do here is we can say if document do current user Ro equal is equal to user roles dot admin then we can upgrade the document state to published published State and we pass the document okay so let's now create this published State and in here we need to implement
the uh State interface and we also need the same as before we need a reference to document and we also need to uh initialize the documents in the Constructor so let's do that we can just copy and paste that in and change the name of the Constructor okay so what happens when uh a user clicks publish if we are already in the publish State well we should just do nothing so we can just return or we can just leave uh this blank okay so we just do nothing basically so I'll just write a comment if already in published
State okay so that's pretty straightforward uh so let's actually now have a look how we can use this uh State pattern solution uh but before we do that what I'm just going to do is I'm going to change uh I'm just going to copy and paste this enom into our good Solutions folder so let's add this in here so this is a user rolles enum and we can paste those in and that should hopefully uh enable us to use this state solution State pattern solution so let's see so new documents and we need to import this so should be
that one and we're going to use user roles dot editor and we're just going to log the uh document state so dog doc. State and then we'll publish the documents and console log and then we'll publish again and log the doc. state so let's run this and we can see that initially we have a draft state so that is correct whenever we create a new document it is in draft State and then uh the user role for this document is an editor so when we publish a document that is in draft state it should then go to moderation
State and that is correct and if we publish again uh we should stay in moderation State because the user is not an admin so that is all working correctly and let's now change the uh user role from edit to uh admin so now we should go initially we should have the uh draft State then we should have moderation State and then we should have the uh publish State because admins can publish documents so let's see if that works and there we go that is all working correctly and it's also possible to actually change the state directly so
if we wanted to go back to draft state we can just simply add in the draft State like so and if we log the state of the document we can see here that we go back into draft state so now if we create any new States we don't have to modify the document class as its publish method is coded to an interface and so delegates the work to a concrete class and as you can see here the state class is coded to an interface not a concrete State class which means that the document class can use polymorphism to delegate the work to
any of the concrete State classes uh and this gives our program good flexibility so let's now have a look at the pros and cons of the state patent so the state pattern can actually be Overkill or over engineering for example consider a simple stock watch that has two states so it has a running state is running or it has a is running State equals false so it's either running or it isn't running it's stopped and if um this is a very very simple uh class and we can be pretty certain that the stopwatch isn't going to get more
complex uh we're not going to have any more States than either stopped or started and so using the state pattern and creating more classes here adds uh unnecessary complexity so this class even though it has a few uh conditional statements in its click method it's pretty straightforward and there's not really any need to go ahead and create a l you know separate State classes just for this stopwatch it's pretty straightforward as it is and there we're not going to add any more states in the
long run um so when to use the state pattern so a good indication uh that you should use the state pattern is if you have a class that behaves differently depending on its state and you have a large number of conditionals or if else statements in the methods so like we did before in this document class we started it started to get pretty bloated we were having lots ofl statements to check the current state and then do some particular Behavior Uh and this is a good indication that we should abstract this um this sort of St
dependent Behavior into it into their own uh classes um uh so the state pattern can be used with uh abstract classes to reduce duplication uh so in our case we used an interface we use the state interface but you could also use an you could also have used an abstract class uh where we kind of keep um you know maybe some fields or a few uh methods that are sort of shared between the concrete State objects so it's also possible to use abstract class uh classes to reduce uh code uh duplication and you can also
create a hierarchy of State classes and Abstract common code into these abstract base classes so the pros and cons of the state pattern so some of the pros are that a the state pan improves readability and simplicity of the context class by eliminating conditionals it satisfies the single responsibility principle by abstracting state specific logic into separate classes and it satisfies the open close principle because we can introduce new states without modifying existing classes so our code is open for extension but closed for modification
and one of the uh cons of this pattern as we have just discussed with the stopwatch example is that this pattern can be Overkill if there are only a few States or if State logic rarely changes for example uh this class here the strategy pattern is used to pass different algorithms or behaviors to an object so first let's consider an application that stores videos before storing a video the video needs to be compressed using a specific uh compression algorithm such as mov or MP4 then if necessary uh apply and over
to the video such as black and white or blur let's create a video storage class to handle uh this situation so first of all what we want to do is create some enom for the compressor types that we have and also for the overlays so first of all let's create the uh compressors and this is going to be an enob and we have M moov MP4 web M and then let's create the overlays so we're going to have another enor for overlays and we going to we're going to have no overlay uh we're going to have black and
white and we're also going to have a blur overlay okay and the reason we create these enom is because it's uh it's better than it's better practice than using uh hardcoded values for example uh if overlay is equal to this should be just overlay by the way um see will it let me if overlay is equal to mov so this is bad practice because we're hardcoding a literal string value into the conditional and the reason one of the reasons why this is a bad practice is because let's say we want to change
the name of this extension we would then have to search through all the code and change the values one by one whereas if we have an enor and we want to change you know the name of the mov extension to mvv for example then we can just use our uh vs code or our text editor and we can on Mac I can press function F2 and I can rename to mvv M ovv for example and that will change all through the program okay so that's why one of the good reasons why using an enom is good practice okay so now let's create our video
storage class so let's create a new class called video storage and a video storage class is going to have two Fields it's going to have a compressor field and I'm just going to give this an underscore because it's uh a sort of convention in C and we're going to have an overlay okay and now we need to create a Constructor where we pass H the compressor that we want to use and we also pass the overlay that we want to use but uh if the user doesn't want to use uh any overlay what we can do is by
default provide a default overlay of none okay so if the user doesn't Supply an overlay when they create the video storage object then we're just going to apply no overlay then in here we can just say compressor equals compressor overlay equals overlay so set the values of the fields and then I'm just going to create a couple of uh seta uh methods here so that once the video storage object is created we can change the uh compression algorithm or the overlay that is used in the video storage object to store videos so let's
uh create a gter called set compressor and this is going to take a compressor and we can just set the compressor and we'll also do the same for overlay so that the overlay can be updated so we can uh use the same video storage object with different uh overlays and compressors okay and then we're going to create our store method which will contain the logic for storing a video okay so this is going to take a file name and we're going to perform a check where we check if the compressor is equal to uh compressors do move
mov then we will have some Logic for compressing a video using moov but of course that's beyond the scope of this course so we're just going to log comp com pressing using mov okay and then we're going to have another conditional if it's an mp4 and then we can just copy this down and say compressing using MP4 and then we're going to have the same kind of thing for if the video is a web m if the uh compression algorithm is web M so this is all of our logic uh related to compressing the video and then we also need some Logic
for um applying an overlay to uh a video so I'm just going to write overlay logic here and then I'm just going to copy in this uh overlay logic to save some time so let's copy that in and I just need to change this to uh not all capitals okay and then at the end we can simply store the video to the file location so we will say storing video to uh file name and this should be here okay and then we can also uh uh concatenate on the extension as well so um compressors uh actually compressor dot
um yeah it's just the compressor isn't it okay uh so that will give us the file extension okay so that is our video storage class so let's now discuss some of the problems with this solution so first of all it violates the open closed principle because adding new compression algorithms or new overlays means that we have to modify the existing video storage class uh so this working and tested code has to be modified which risks introducing bugs to to previous ly working code and also developers could
get lots of merge compli uh conflicts uh in git uh as multiple developers may have to edit one big class for example if one developer is working on compression algorithms and another developer is working on overlays then both developers will be editing this video storage class which means that developers can sort of step on each other's toes and things can get kind of difficult to work with and messy okay so you can also see that this is a very bloated uh video storage class um this method is difficult to follow even
with just three overlays and three compressors so you can imagine the more compressors and overlays we had the more bloated and difficult to read this is going to be so let's now try to solve this problem using the strategy pattern so the uml below shows that when we create a video storage object we pass it to the concrete compressor and overlay objects that we want to use and this is polymorphism so video storage can accept many different forms of compressor and overlay objects uh video storage is composed of uh compressor and overlay
objects uh as represented by the arrow with a diamond and there are multiple concrete compressor and overlay implementations that extend the compressor and filter interfaces respectively so you can see here uh we have our video storage class which is composed of uh a compressor and an overlay and our video storage class is talking to or coded to an interface not a concrete uh implementation of a compressor or or overlay and this uh provides us with a lot of flexibility because we can very easy IL swap out um the compressor that
the video storage is using or the overlay as long as they implement the compressor or overlay interfaces okay so this is the strategy pattern and now I'm going to show you how it looks with the abstract class names from the gang of four book so you can see that our video storage class is known as the context and the context is composed of or stores a reference to a strategy okay and the strategy is represented by an interface and then we have concrete strategies um each with some sort of method okay so if we have a look at our
our solution our video storage is the context which has a reference to uh a strategy and currently we have two different types of strategy in our video storage class we have compressor and overlay Strat IES or algorithms I guess you could call them and then we have our concrete strategies which um Implement these imp interfaces okay and you can see here uh in the context or in the video storage uh class when we call one of the methods we we are now delegating work to a concrete strategy okay rather than actually doing the logic uh within the
uh context object itself with all the if uh else conditional statements we can just simply delegate the work to the concrete strategy object so let's let's now implement this in code so first of all let's create the interfaces for our two strategies uh our two strategies being the compressor and the overlay so I'm just going to create a new uh folder here called uh good example using the uh strategy uh design pattern and in here what I'm going to do is I'm going to create a compressor
interface called I compressor and in C it's generally considered good practice to start interfaces with with the letter I so prefix with the letter I so that it's clear that it's an interface and not just a class and in here we're going to have a single method called compress which returns void and then we're going to create another interface called I overlay and this is going to have a single method called apply okay so now we have our interfaces or our strategy um interfaces we can create the
concrete um our concrete strategy object uh classes and we have two strategies so we're going to need two sets of concrete uh strategy objects or classes uh first of all let's start with the compressors so I'm going to create a new C Class called compressor mov and this needs to implement the I compressor interface and then we can implement this interface and what we're going to do is we're just going to log uh compressing video using mov okay and then we're going to do the same for MP4 and webm so let's quickly
do that so we can say compressor MP4 and I'm just going to copy this in to save some time so it needs to implement the I uh compressor into face and then we can have our compress function uh method and then we're going to do the same for compressor web m okay so those are our concrete compressors we can now create our concrete overlay strategies so first of all let's create the black and white and this needs to implement the I
overlay interface and we can Implement that and here we can just put applying black and white inter overlay okay and then we also need a overlay for the blur strategy and then we need a uh and then let's actually call this make sure that we prefix with compressor and the reason I like to do this is because then uh they all kind of Stay Together in vs code so let's just change the name of this and we just need our compressor for uh sorry overlay for
none actually this should be overlay sorry apologies and let's make sure this is correct okay and yeah what do we doing here so this should be I overlay okay so let's change this to apply get rid of this okay so that is correct and now we need our uh no overlay uh class so overlay none and this should be I overlay Implement and not applying overlay okay so now we need to create our uh
video uh storage class so what I'm going to do is I'm going to copy and paste the class from here and then we're going to refactor this class uh to make it uh sort of satisfy the strategy pattern so let's create a new class called video storage and I'm just going to paste in what we had before okay so how do we refactor this to uh satisfy our uh strategy pattern well first of all we need rather than um uh coding to these uh enom we're going to change this so that the compressor is coded to uh the compressor
interface and we're going to do the same for overlay and we also need to update this to I compressor and this needs to be updated to I overlay okay um and we also need to change this to I compressor this should be I overlay and now the biggest changes are going to be in our store method So currently all of the logic for uh compressing a um video is stored in this store method and also all of the logic for applying an overlay is in here so what we can now do is we can get rid of all all of this and we can delegate this work to
the concrete compressor and overlay objects so video storage will have no knowledge of the implementation details of each compression and overlay algorithm so we can say compressor do compress and we can say overlay do apply okay and um in a real application we probably need to pass the file name to uh the the this compress method and also the apply method so it you know can get or maybe pass a video object something like that but for now we're just going to keep things simple and we're just going to call the compress
and apply uh methods but as you can see we we no longer need to check what the compression algorithm uh should be um we also don't need to check what the uh overlay is that we are applying we just simply call the compress and then uh compress method and then we apply the overlay so this is way way more simple than we had before so let's actually now have a look at how a client would use this uh solution so we can create a video storage uh object and should be this one and then we can pass in a compressor so let's uh let's
just pass in a uh mov compressor so we want to compress toov and for the overlay let's do black and white okay so let's actually call the uh store method and let's pass the file name so let's just say the file location is videos slash uh some movie okay and then let's see what happens here okay so we've compressed the video using mov applied uh black and white overlay and then the video has been stored okay so that's good and uh because we um added seta uh methods onto the video storage uh
class so if I just go back into here we can see we we added set compressor and set overlay methods so that allows us to uh change the um compressor or the overlay that we use uh within the video storage class we don't have to create a new video storage object just to use a different compressor for example so say we wanted to use a MP4 this time and the overlay we wanted no overlay so if we just said overlay none uh oops sorry this should be just the compressor and then we can call video storage.
set overlay and pass overlay none and then and we call video storage. store and then we pass some uh location videos some movie we can actually uh compress and O set an overlay for the same video but we can use a different compression algorithm and a different overlay just by calling these set methods okay so these seta methods give us a little bit more sort of flexibility with the way that we use the video storage uh object okay so so this is great so this solution follows the open closed principle for example to create a new uh
compressor so a new concrete compressor um we simply create a new class that extends the I compressor interface uh which is this and our code is extended so our code base is extended meaning that we've just added a new class and not modified meaning that we we don't have to uh modify any existing classes to add a compressor and same for overlay so now we can just extend our code base so we can add a new overlay or add a new compressor and we don't have to modify any existing code to to do that so you may be wondering
what is the difference between the strategy and state pattern because the two patterns probably seem quite similar to you and the truth is the two patterns are actually similar and the difference between them varies depending on who you ask and some popular answers uh to this question are that states store a reference to the context object that contains them whereas strategies do not states are allowed to replace themselves in other words to change the state of the context object to something else while strategies are not and strategies
only handle a single specific task while states provide the underlying implementation for everything or almost everything that the context object does so when should you use the strategy pattern A good rule of uh thumb for when it might be a good time to reach for the strategy pattern is when you have a class with a large number of conditional statements the switch between variants of the same algorithm so in our video storage class um we saw that there were a large number of conditional statements that switch between variants of the same
algorithm so the algorithm being a compression algorithm and the variance being uh mov or MP4 and uh we could see that by switching to the strategy pattern we got rid of all of those uh kind of bloated messy conditional statements and the algorithm logic can be extracted into separate classes that implement the same interface and that is what we did with our solution we extracted the compression logic as well as the overlay logic into separate classes that implemented either a compressor or overlay interface and the context object in our
case the video storage class then delegates the work to these classes instead of implementing all of the algorithms itself so the pr pros and cons of the strategy pattern so the pros it satisfies the open close principle because we can add new strategies without modifying the context or class and we can swap algorithms used inside an object at runtime so it provides lots of flexibility uh and some of the cons of the strategy pattern are that clients have to be aware of the different algorithms and select the appropriate
one so in our program.cs file we had to pass the uh appropriate well we had to pass the strategy uh the compression algorithm or the overlay object that we wanted to use and if you only have a few algorithms that rarely change then using the strategy pattern may be over engineering because we're creating uh potentially lots of new classes um and it's not really necessary if there are only a few algorithms that aren't going to be changing often the iterator pattern provides a way of iterating over
an object without having to expose the object's internal structure which may change in at some point in the future so changing the internals of an object should not affect its consumers so this probably doesn't make too much sense to you so let me show you what this means with an example so here we have a shopping list class which stores a list of items and we have a push method to add an item onto the list a pop method to re uh remove the last item on the list and then return it and we have a get list uh
method which Returns the whole shopping list and as you can see here the list the shopping list is of type list it is a list data structure and each item in the list is of type string so let's actually use this shopping list in our Pro program.cs file so I'm just pasting in here where uh to create a new shopping list called list and then we're just pushing a a few items onto the list so milk bread and steak and now what we want to do is I want we want to Loop over each item in the shopping list and log each of the
items so we can create a for Loop starting from zero and uh the loop will keep running until as long as the list as long as I is less than the uh list length and we can call count on here so uh let's see list.get list. count and we want to increment I by one so this is giving us an error cannot convert type in to BU so this should be be uh as long as I is less than the uh length of the shopping list okay so this is going to Loop over each item in the shopping list and increment I by uh one each time so let's have a
look at each item in the list and we can do that by um saying list do get list and we can um access the uh the nth or the e in this case uh item in the list and then we're just going to log this item okay so let's run this program and see what we get returned and as you can see we have milk bread and steak as expected so this looks like a decent solution uh however there is one problem and uh the clue if I give you a clue what the problem could be it's this sentence here so changing the internals of an object should not affect its
consumers so if we change the internals of the shopping list object meaning we change something within the shopping list class then it should have no effect on its consumers and currently this uh program . CS uh main method is a consumer of shopping list okay so uh let me show you what the issue actually is so if we changed the data structure inside of shopping list uh to a fixed length array so if we just comment this out for now and then we say uh private string so a string array list equals new string array and it's a fixed length
array of 50 items long so if we change the data structure used to uh store uh shopping list items and then let's just say that we updated all of these methods to uh push pop and return the list okay we're not going to do that for now because uh we we don't really need to but if we go into our program CS then it would actually cause an error because uh fixed length arrays do not have a count field and currently uh list.
 Gat list uh inside of our shopping list would return a a fixed length array okay it wouldn't return a list and a fixed length array does not have a count field so therefore it would cause an error it would cause our program to break uh in in this consumer it affects this consumer so by changing the internals of the shopping list object it would affect its consumers any consumer that is iterating over the list will break so uh we can fix this by using the iterator pattern so we can use the iterator pattern to ensure that changing the internals for example changing the
list data structure doesn't affect any of its consumers so we can do this by adding some methods to the shopping list class to allow iterating over a shopping list without uh knowing about its internal representation so here we have a uml diagram of the shopping list class and we can see that we still have our push and pop methods but we've added some extra methods to allow iterating over a shopping list and you can see here we have a next uh method a current method and a has next method so with what we've done here is
we've added these three new method methods to help consumers to iterate over the uh list uh data structure or the or just the object itself without having to have any knowledge of the internal data structures so the next method goes to the next item in the list the current method Returns the current item and the has next method checks if there is another item in the list and with this structure we don't know the internal representation of the list object so if we change the data structure used in shopping list to store items its
consumers wouldn't break or need to be changed we'd just have to perhaps update the iterator methods to account for the new data structure so the problem with the the above shopping list class is that it violates the uh solid single responsibility principle because shopping list is now responsible for list management using push and pop and it's also responsible for iteration using next current and has next so to follow the single responsibility principle we can put the iterator methods into a new class and that class
can be called iterator okay and as you can see the shopping list has a dependency on iterator and as you can see here we also have a method inside of our shopping list class called create iterator and the create iterator method returns an instance of iterator that allows consumers to iterate over shopping lists without knowing its internal details however we have another problem because if the data structure inside of shopping list changes then we will need a different iterator to manage it so iterator needs to be an interface and
then we can have concrete classes for each data structure that implements iterator to ensure that they contain the iterator methods the correct iterator methods and the interface determines the capabilities that we need from a real concrete iterator so the data structures could be an array a list a stack Etc so here is our uml representation we have our shopping list which has a create iterator method uh which returns a it an iterator uh an we have an iterator interface here and iterators should have a next current and has next method and
then we have our concrete representations of iterators and each concrete iterator uh can be used to iterate over specific data structures in this case we have a list iterator for iterating over lists and an array iterator for iterating over arrays so we can see here that shopping list has a dependency to the iterator interface uh as we discussed because the create iterator uh method returns an object of type iterator and the concrete iterator classes extend iterator and Implement its methods so here's how how the solution
uh looks using the gang of four abstract class names so we uh have a collection uh class which uh contains the create iterator method and obviously this is our our shopping list class in our example we have the iterator interface okay and create iterator returns an object of type iterator and then we have our concrete uh iterators okay so now uh let's implement this in code so let's now implement the uh shopping list using the iterator pattern so I've created a good example folder here and I've copy and pasted the
shopping list from earlier into this new folder and we're going to refactor this to uh satisfy the iterator pattern so first of all what we need to do is create an interface uh for the iterators so I'm going to call this I iterator and this needs three methods so we need a method called next uh we need a has next method which has a return type of Boolean and we also need a current method which Returns the current item in the loop So currently um this current uh method only works with strings and current that's fine for our
shopping list because we have a list of strings however what if we wanted to Loop over a list of orders or customers or integers so this iterator uh interface isn't very flexible it can only work with lists of strings so what we can actually do to make this more flexible is use a generic type and pass this uh to the current uh method and if this doesn't make sense to you it will make more sense when we use this uh I iterator interface uh shortly so what we now need to do is create our concrete iterator classes so
we're actually going to create these as nested classes inside of this shopping list class um so let's create a a uh nested uh iterator and I'll explain why this is nested uh soon so we're going to create a private class called list iterator and this is uh a concrete class which is uh going to iterate over lists so currently that's what we are rep that's the data structure that we are using for our list and this needs to implement the I iterator interface and we can just pass a string data type to that now as you
can see we get an error because we haven't implemented this interface so let's do that and let's now um um create some fields in this concrete uh iterator object so we're going to have a shopping list uh field because that's what we are looping over and we will also have a uh an index so the current position in the loop and then we also need a Constructor which takes a shopping list and we assign it to the shopping list field okay so now let's update our current method so this should return the
current item in the uh list so we can return the shopping list do list and then we can uh just pass the index like so and this will return the item at the current index in the loop and then next uh let's implement this next uh method so all next needs to do is increment the index by one so we can just say index equals index + one and then the H next method needs to check if we are basically at the end of the list so we can return uh index is less than shopping list. list.
 count and here we do have access to the uh count field because we know that we are iterating over a uh list because this is an A List iterator okay so we just need to put colod one there okay so this is all looking okay and then in the uh in our shopping list class we just need to do one more thing and that is is to create a new method called create iterator which is going to return the correct iterator okay so in this case we need a list iterator because we are using a data type of list so let's uh create this method and
this has a return type of iterator which allows us to use uh multiple different types of concrete iterators so we can return any concrete iterator and it isn't going to cause our clients to break so here we're going to pass a string because we are iterating over strings and we can call this create iterator and this needs to return new list iterator and we pass the current uh shopping list okay so um that is all looking good so let's actually test this solution out so uh we are no longer going to need
this so let's remove that and let's create our new iterator so we can say I iterator uh in fact let's just do this we can say VAR iterator equals um hold on a second so okay so we can say V iterator equals uh list. create iterator so now we have our iterator and now what we can do is we can create a while loop so we can say while the iterator has next we we can um console uh write iterator do current so get the current item in the uh iteration cycle and then we just call the iterator do next uh method to it to go to the next
uh item in the list so let's log this out and as you can see we still get milk bread and steak as we would expect and and the advantage of this is now we can safely change the data structure in shopping list and the code in all of our consumers will still run because if you look at our shopping list currently we have a list of strings but if we change this to a fixed length uh array we could create a new class called uh fixed length array iterator which implements the I iterator uh interface and it provides these
methods and then in our program.cs file this would still work because we're just interacting with the methods that are specified on this interface so because we are effectively coding to an interface we now don't have to worry about the specific internals of the object that we are iterating over so when should you use the iterator pattern so it's a good idea to employ the iterator pattern when you're collect possesses a complex internal data structure or a data structure that is likely to change so that clients can
iterate over the collection without any knowledge of the data structure so if the internal data structure uh of an object or of a of a class changes then it shouldn't affect the clients so what are the pros and cons of the iterator pattern so one of the pros is that it satisfies the single responsibility principle because the traversal logic is abstracted into a separate class or separate classes and it also satisfies the open close principle because you can create new Collections and iterators without breaking the code that uses them
and one of the cons of the uh iterator pattern is that it can be over engineering if your app only works with simple collections the command pattern is a behavioral design pattern that encapsulates a request as an object object allowing you to parameterize clients with cues requests or operations it enables you to decouple the sender from the receiver and provides flexibility in the execution of commands and supports undoable operations so that probably makes absolutely no sense so let's uh make it make sense by going
through an example so we're going to create a remote control that is connected to a light that can either either be switched on or off so first of all let's create the light so this is going to be a standard class with two methods and it's going to be uh one method called turn on and we're just going to log uh light is on and then we're going to create a another method called turn off and we're just going to log light is off okay so this is the receiver class this is receiving um from the uh remote okay and then
we're going to create the remote control class okay so this is going to be like our invoker class this is invoking some command uh to the light which is receiving the command so so in here our remote control is going to store a uh reference uh to the light and we will set the light in the Constructor and then we're going to have a method called press button so it's going to be a very simple remote with one button for now and this is going to have uh one parameter which is a Boolean and this is whether if it's true then we want to
turn the light on if it's false then we are going to turn the light off so we're just going to have a simple if statement so if turn on then we will call the turn on method on the light otherwise we just turn the light off and let's now have a look at how a client would use this solution so in remote control we pass the light object that we want to control okay and then we can call remote control do press button and if we pass true we should turn the light on and if we pass false we should turn the light off so
let's run this program and we can see that we got light is on and then light is off okay but there actually uh are some issues with this solution so in this example there are control class uh directly calls methods on the concrete light uh object okay so we pass a light object to the remote control and we are directly uh calling methods on this concrete light class because here we can see we're calling light turn on and light turn off so this direct coupling between remote control and light makes it challenging to extend the
functionality or introduce new commands without modifying the remote control uh class so for example uh suppose that we want to add the functionality to dim the light in addition to being able to turn the light on and off so if we were to uh continue with this implementation then we would need to modify the remote control class directly uh so to if we wanted to add a method to dim the light then we would need sorry if we wanted to add functionality to uh be able to dim the light light then we need to edit this remote control class for example
we'd create a method called uh dim light and we would call light. Dim light for example this doesn't exist at the moment but this is you know something uh what we what we could do so this actually uh violates the uh solid open close principle and it makes it challenging to extend the functionality without having to modify existing code and as you've already seen multiple times by now this isn't ideal so here is the uml for our current solution so we have a remote control which is composed of a light uh
object and it's tightly coupled to this concrete light object because it's calling uh methods directly uh that are contained within this light object um so light is tightly coupled to remote control if we want to add new features then we have to modify uh remote control so let's have a look at how we can improve this solution and make it satisfy the open close principle so that we don't have to uh modify existing code to add new features we can ideally just create some new class or extend our code
base so we have a look at the command pattern uml we can see here that rather than having remote control talk directly to the light uh object object instead we can pass a command to remote control and then whenever the uh button is pressed we can simply call command. execute and we can see here that this command is an interface so the remote control is now talking to an interface rather than concrete objects and this provides us with a lot of flexibility because now we can create multiple uh concrete commands
and we can pass any of those commands as long as it implements this command interface to the remote control and the remote control needs no knowledge of the specific uh command that it is working with okay and then we can see here that the commands have an association relationship to light so that they can interact with the light so for turnon it just needs to call the light.
 turn on method so using the command pattern we can decouple remote control so this is the sender class from the light class which is the receiver and then to add new functionalities such as dimming the light we can extend our code Base by adding a new dim command without having to modify the remote control class so if we created a dim class we could then in the client just pass this command to remote control without having to modify the remote control and the remote control is composed of a command as we just discussed and the
concrete commands turn on and turn off Implement command and store a reference to light so let's Implement our remote control and light uh sort of example using the command pan so I've created a new folder called good light for so we're going to use the command pattern here so this is going to be like a good example and first of all we're going to create the command interface so let's create a new interface called I command and this is going to have a single method called execute and we are also now going to
create our remote control class and our remote control class or our invoker class is now going to store a reference to a command so it's going to be composed of a command object and we're going to code to an interface here so that we can use polymorphism and we're going to pass a command in the into the Constructor okay uh and then what we're going to do is we're also going to add a uh set command method so this is going to allow the uh client to swap commands at runtime so we're going to create a
public void method called set command and this is going to take a command object so any command object any command that implements the I command interface and here we can just set the command and we're also going to uh have our uh press button uh method and now all we have to do is call the execute uh method on the command object and this will execute whatever whatever command we have passed to our remote control okay so let's now create the receiver or the light uh class and this is pretty much the same
as we had before so I'm just going to copy those methods in so you can see here we have a turn on turn off and I've also added a dim method so that we can now dim the light as well uh and now we can create our concrete commands so let's go ahead and do that um so let's first of all create a turn on command and this is going to implement the I command interface so so if we implement this interface we have our execute method and uh what we need to do here is we need to store a reference to the object
that we are kind of controlling and in this case it is the light uh class so let's add that in and then we can pass that uh into the Constructor okay and uh the light here this light field can only be uh set in the Constructor we're not going to add any Setter methods uh so uh basically a command is a mutable so meaning that it can't be changed uh once it is created and for our execute method we can now simply just call the turn on method on the light uh object okay so let's also create our turnoff
command so again we're going to implement the I command interface okay and it's going to be pretty similar to the turn uh off command so sorry the turn on command and let's copy that in and we just need to change this to turn off so we pass a light object into the Constructor of the turnoff command and let's also create our dim command and again it's going to be pretty similar so but we just need to rename the Constructor and we also need to implement the I command interface and call light.
dim okay pretty straightforward uh so let's now have a look at how a client would use this solution so if we go into program.cs and create a light and let's also create our remote and actually we don't need to import that so it's seeing here we as you can see here it's telling us that we need to pass uh some command object so initially I think it's a good idea to actually turn on the light so let's pass the turn on command and we also need to pass the light to the command okay and now let's press the
button so if we press the button we've passed a turn on command so the remote is just going to execute this turn on command so let's call the press button and if we run this you can see that we got the light is on so the light is being switched on and now if we want to say uh dim the light so it's too bright we can call remote.
 set command and we can pass the dim command and then if we press the button and run this we can see that we get the light is dim okay so we have lots lots of flexibility now in in in terms of what command we use and whenever we want to uh create a new uh command or new functionality for our remote we can simply extend our code Base by creating a new concrete command class without having to touch our invoker class or our uh remote class the command pattern is also commonly used in UI Frameworks especially for handling user interactions with buttons or menu items
uh each button or menu item can be associated with a specific command object allowing the framework to execute the appropriate action when the user interacts with the UI elements and this decouples the UI components from the actual operations that they perform form which provides F uh flexibility and maintainability in UI development Additionally the command pattern facilitates features such as undo or redo functionality and event loging in UI applications so here's how a UI framework that implements the uh command
pattern M look so above this green line we have the framework and we have a button class which is like our invoker and this is composed of a command and you can see the button or the UI component is talking to the command interface not a concrete uh command class or and it's also not talking directly to the receiver so um we also have our concrete commands here so we currently we just have an add user command but we could also have things like delete user or update user and then this talks to a user service
which actually performs the uh business logic related to adding a user so the framework would be the code that you couldn't edit so for example some a UI package and the app part is the part that you would create so the so custom code your actual app that you are building and you will create concrete commands that extend the command interface uh that that is found in the UI package and your concrete commands keep a reference to a class that contains the B business logic as we discussed such as a user service and this contains
the methods related to adding updating or deleting users so this is going to be uh maybe interacting with your database uh a simpler solution so if we didn't use the command pattern uh and and we sort of come up with a sort of more obvious solution uh and this would be to create a load of button subclasses uh for each place where a button is used and these subclasses would contain the code uh that should happen when the button is clicked so here we have some sort of abstract button class this might be from uh maybe the UI framework and
then our code uh or in our application we would then create a load of button subclasses uh where each subass contains the logic that should happen when for example a button is clicked and the problem with this approach is that we could end up with a huge number of subclasses and this would be okay if there was no risk of breaking the code in these sub classes every time that the base button class is modified uh but if we update our UI library and that includes a breaking change to the button class then it could break all of our
button subclasses so this is a very uh fragile solution and also uh some operations such as copy need to be called from multiple places for example a user can click the copy button uh press contrl C or right click click and then select copy from a context menu um with this solution we'd either have to duplicate the copy logic in multiple places uh or make shortcuts and context menus dependent on buttons which is a very bad solution so the command pattern solves this issue by essentially breaking the app into layers
following the good software design principle called the principle of separation of concerns so the command pattern has broke the app into two layers we have the guei and the business logic and the guei is responsible for rendering things on the screen capturing user input and showing results then when it comes to the important stuff such as validating the info from a contact form and sending an email the guei delegates that task to the underlying layer of the business logic so if we have a look at the gang of for uml you can see here that we have
a our light class or our sort of button class this will be called the invoker class in the gang of for book we then have our Command interface with some sort of execute uh method and we usually I think have a single execute method in the sort of command interface then each command will uh implement this command interface uh and have a execute command and then we have a receiver uh where the the concrete commands sort of delegate the work to this receiver class and we can see that the invoker is completely decoupled from the receiver and this
provides us with lots of flexibility because we can now use polymorphism to pass different command objects to the invoker and the invoker needs no specific knowledge of the command that it that it's being passed another advantage of the command pattern is that it gives us the ability to implement undo functionality so for example say we have a text editor like VSS code that allows the user to highlight some text then the user could click a button and make uh make some text in the HTML document italic which just means uh
slanted so here we have the uml diagram uh for implementing uh this undo functionality so above we create a new interface called undoable command which extends the command interface and this is because all undoable commands are still commands they're just special types of commands that can execute both forwards uh or backwards with the execute and onexecute command uh methods so why not add the onexecute method to the command interface itself uh well it's because not every command is undoable for example making text italics
is undoable but saving a document or zooming in or out is not and if you can remember the uh solid interface segregation principle it basically States that uh classes should not be forced to implement methods that they do not need so it's much better to create this separate undoable command interface so we then Implement uh these methods in the concrete command classes so for example here we have an italic command which implements both the execute and unexecuted methods from the undoable command interface okay so we can also use use
the momento pattern which we discussed earlier to implement undo mechanisms but what's the difference between momento and the command pattern when it comes to undo operations so with the momento pattern if you can remember we store the changes in the state of an object so in other words we store multiple snapshots of the state over time and sometimes storing these snapshots can be expensive for example videos are Lar files that take up lots of memory and in those situations it's better to use the command pan because every command knows
how to undo itself so we don't have to store multiple snapshots of an object for example think of the resize operation if a user resizes a video we only have to store the previous dimension of that video we don't have to store the entire snapshot of the video object so here's how we will implement the command pattern with with undo capability so here we have some slightly confusing uml uh but we have a an undo command uh a new class called undo command that we have created to handle all undo operations so the way this works is that
it pops the last command from history and then calls the onexecute method on that command as all commands know how to onexecute themselves so this is kind of confusing to talk through and just look at the diagram so it's going to make much more sense when we go through this in code so let's do that okay so I have created here a an undoable um folder where we're going to uh put our code solution in here so first of all let's create a HTML document class so in this class this is where we are going to implement our business
logic so this class will know nothing about uh commands it simply TS it's simply the business layer of our application okay so let's first of all uh create a uh property for the content of the HTML document and we will have a getter and a Setter and we'll also include here now a public void make italic method and this is how where we're going to have our business logic so so basically the HTML document knows how to make itself bold so what we can do in here is we can set the content equal to uh the content wrapped in HTML italic
attacks okay like so so what we will do next is we will create the command interface with the X cute method and we'll also create the undoable command interface which uh extends the command interface and this extends command Okay so that means that it gains the execute method from command and we will also add an onexecute method and um undoable command extends command which means that every undoable command is actually also a command object okay so next up we're going to Comm create
our Command history class which is going to which is a class that's going to keep track of of the commands that we've applied so let's create that class called history and in here we're going to store a uh list of undoable commands and we'll just call this commands and we will set it equal to a new list and then we're going to create a push method so we're going to create a few method methods which will allow us to easily interact with the uh history class so we'll create a method called
public void push and this is going to take an undoable command and we can just call commands. add command and we'll also create a pop method for removing the last item on the uh uh commands list and this returns that last item so we get the last command from the list then we remove it from the list and then finally we return it okay so we pop it off the list and remove it from the list then we return that last item and we're also going to have a method called uh size for getting the
current length of the uh commands list and this is going to be useful in another class uh a little bit later on so let's create this and we just want to return uh commands. count okay so what we're going to do here with this size method is we just simply uh check that we have some commands in the commands list and if we do then you know we can onexecute them for example so that's why we are using this we're sort of adding in this size method so what we can do now is we can create our concrete italic command uh class so
let's go ahead and create a new class called italic command and this needs to implement the undoable command interface so let's Implement that interface so we have an execute method and an unexecuted some Fields up here so we need to store reference to the HTML document so let's um sort of reference to that we also need um a field for the previous content and we'll initialize that to an empty string and we also need to store reference to the history object okay so we're going to need to to create a Constructor now to set these
values and what we need to do is we need to pass the history object as well okay and then we can IM uh Implement our execute and unexecuted what we want to do is we need to get the current content in the HTML document and set it to previous content we can then uh make the document italic and we can push uh this command object so this command object onto the history class okay so we are getting the uh current content from the document storing it into previous content we then make the document italic and then we
push this command object onto the history list so let's do that so we can say previous content is equal to doc. content and then we can say doc. make italic and we are delegating this work uh to the doc business object okay so we're not doing this work within the command we are delegating to the uh document business object and then we call history do push and we want to push this command onto the uh history list now for unexecuted all we need to do is we call Doc do content equals previous content okay so we go back to what the content
was before we executed the command so that's pretty straightforward uh but we're now going to create a a new class called undo command and this is going to sort of manage all of um the undoable commands so this is going to make more sense uh shortly so stick with me so let's create a new class called undo command and this is going to implement the command interface and what we need to do here is we need to store dra a reference to the history class and we can pass this into the Constructor so in the execute method
what we want to do is we want to check if the history has uh any item any commands in its list so if it does then we can pop the last item the last command off of the list and then we can call its own execute method so let's do that so we can say if history do size is greater than zero so if we have any commands on the list then what we can do is we can pop the last item off the list and we want it this should be history.
poop and we can say last command. execute uh sorry onexecute okay so we unexecuted command um and again here we are delegating the uh this undo logic to the undoable command object so this is going to make a little bit more sense when we actually use this solution so let me show you how this is used in a client so first of all let's create a HTML documents and let's also create our history object and we don't need that and let's set the HTML documents content equal to hello world and let's just log what the
content is okay so let's run this program see what we get and we get hello world as expected so what we want to do next is let's try and make the content um italic so to do that we can create an italic command and object and we pass in the HTML Doc and the history object okay we can then call the execute command on the itell command sorry the execute method on the itell command so um let's actually log the content now so we would expect this hello world to now be wrapped in italic HTML tags so let's
run this and see what we got and as you can see it's working correctly so it's executed the italic command and made the content in the HTML document italic so the last thing we need to test out is the undo command so what we can do here is we can create a new undo command so undo command equals new undo command and in here we need to pass the history object that we are working with and we can call undo command.
execute and then we can log the uh content so we would expect um the content now to have no italic tags around it so you can see here that we are back to having uh just regular text that isn't italics okay so that's pretty good so you can see here let's have a look at this undo command so undo command that we call undo command.
 execute um so if we have a look at this execute method we are getting the last command from history so if we have a look at our uh history first of all we create this new ellic command which is an undoable command and we call execute and when we call uh execute this command is going to be pushed onto the uh history class uh the history list and then when we call the undo command it essentially pops this uh command that we just executed off of the history and calls onexecute on this command to essential uh revert the content to what it was
previously so when should you use the command pan so you can use the command pattern when you want to implement reversible operations the command pattern is probably the most popular pattern for implementing the undo or redo functionality and it uses less Ram than the momento pattern which has to back up the whole state of the object and the command pattern is great when you want to cue operations or schedule their execution as command objects can be serialized which just means converting the objects into Strings and
then you can store them in databases or send them over networks then at a later time these can be converted back into objects and executed so what are the pros and cons of the command pan so first of all it's satisfies the single responsibility Principle as classes that invoke operations are decou coupled from classes that perform these operations it also satisfies the open close Principle as new commands can be added to the code base without having to modify existing code uh one of the uh negatives or cons
of the command pattern is that code can become more complex as you're adding a new layer between senders and receivers so if your program is fairly simple uh with not too many uh operations then using the command pattern can be Overkill or over engineering the template method allows you to define a template method or skeleton for an operation the specific steps can then be implemented in sub classes so suppose we are designing some software that will be installed on a machine that makes hot beverages at the beginning we just had
tea and coffee but after some feedback from customers we needed to add some more beverages such as calt so we started out pretty simple making a separate class for each hot beverage but the number of beverages but as the number of beverages grows we see a lot of code duplication uh so if we have a look at this uh example here we have um tea coffee and chamomile each with a make beverage method and we can see inside of the make beverage method we are calling the boil water method and a pour into cup method and these uh methods are
actually uh or these steps are used in tea coffee and chamomile in fact they're used in all beverages all hot beverages require Bo boiling water and pouring that water into a cup uh but we also have some methods that differ between the different beverages for example The Brew method uh may require different amounts of time and the add condiments method uh May will differ as well because different beverages will require different condiments for example uh tea it might be possible to add say milk and lemon whereas with coffee uh it may be
possible to add cream so uh so one of the issues is with this solution as is is that as the number of beverages grows we see a lot of code duplication so we are duplicating this boil water and pour into cup uh um uh logic in each uh of the Beverages and we also have no way of ensuring that each class follows a particular structure which means that the client code will have have to include lots of if else conditional statements to pick the proper course of action depending on the particular beverage class so I have made a te class
and we're just going to add some methods for uh boiling water pouring the water into the cup and Brewing the tea so we also need a uh method to see if the customer wants condiments and then we need to add those condiments to the beverage or to the tea so let's create a method called uh uh called add condiments and what we're going to do here is we're going to check if the customer wants condiments so we're actually going to create a method called customer wants condiments and if they do then we're
just going to add some lemon to the tea so let's create this customer once condiments method and this is going to be a method that returns a Boolean value so what we're going to do is we're going to log to the console uh a question so we're going to say would you like lemon with your te and the user is going to be able to input yes or no okay so now what we need to do is we need to read the users's input from the console so we can say console do uh read line okay and then we can simply return
the input dot to lowercase so we input uh we take the user input so either a pro it should be either a y or a no and we make it lowercase and we check if it is equal to to yes so if the user inputed y for yes then this will return true meaning that the customer wants condiments and so we add some lemon to the tea okay so pretty straightforward so now we just need to make one final uh method and that is going to be called make beverage and this is where we basically uh call all of these methods in the correct order to make the T so
I'm just going to paste those in to save some time okay so we boil the water pour it into the cup Brew the tea and then check if the user wants condiments and if so we add them to the tea so pretty straightforward so let's actually go ahead and test this out so let's clear out our program.
cs file and we're going to create a new T OB uh object and we're going to call t. make beverage okay so let's see how this works so we have boiling water pouring water into cup Brewing tee for 3 minutes and then it says would you like lemon with the OT so if I UT y whoops so if I come into the console at Y and enter let's see what we get here okay so it says adding lemon to the te so this is working correctly if I say put no so n let's see what happens okay nothing happen so that's perfect okay so this is working
correctly so now let's also go ahead and create a uh coffee class for creating coffee beverages so okay so let's now also create a coffee class for making coffee so what I'm going to do is I'm just going to paste in these methods for making coffee just to save some time because it's largely the same as the tea class so as you can see we have boil water pour water into cup so these methods are identical to the methods in in uh this tea class and then we have the Brew method which Brews the coffee
for 5 minutes so slightly different to brewing tea and we also uh have the add condiments where rather than adding lemon we add cream to the coffee so we can see that we have two methods that are identical to the ones in t so the issue is that the more of these beverages that we create we're having uh to create we're having a lot of code duplication so there are two good ways to solve this issue of code duplication and they are polymorphism and inheritance so first of all we're going to use polymorphism which actually leads
to a design pattern that we covered earlier so let's see if you can spot which design pattern that is so here we have uh our solution using polymorphism so here we provide a common beverage inter face to force all concrete beverages to follow a specific structure we then have a beverage maker class that manages preparing the different Beverages and this beverage maker class includes the common operations for making all beverages such as boiling water and pouring it into a cup and it also includes uh operations
specific to each beverage uh but these operations are delegated to each of the the concrete beverages so this beverage maker actually talks to a or is coded to a beverage interface meaning that we can use polymorphism so we can pass different concrete uh beverages into the beverage maker and then this beverage maker can simply call beverage.
 prepare it doesn't actually care um about the specific uh concrete be uh beverage class that's been passed to it because it's coded to an interface it can just call prepare so we are essentially using polymorphism to make things nice and flexible and um so now when we create a new beverage so if we get some more feedback from a customer that we need to uh and we want to add a new beverage we want to start selling a new beverage then uh we can just create a new concrete beverage class that implements the beverage interface okay and we only
have to include in these concrete classes codee that is specific or unique to that beverage because the um sort of shared code is placed inside of this beverage maker class so by using polymorphism here we have inadvertently used the strategy pattern so you can see here this is the strategy pattern uml where our context object is the beverage maker and we have a strategy interface and in our case this is the uh the beverage interface and then our concrete strategies or our beverages let's now implement this
strategy pattern or polymorphism uh solution into code so first of all I'm going to create an interface called beverage and I'm going to add a prepare method okay so now let's create our TCL class that implements the beverage uh interface so this beverage uh interface is kind of like our uh command interface uh sorry our strategy interface okay and then we're going to create our concrete strategies which are basically our concrete beverage classes so first of all let's cre create the uh T class and this is going going to
implement the beverage class so let's implement this uh interface and what I'm going to do is I'm just going to copy and paste in uh some of the uh methods that we had before so we had the Brew method and the add condiments uh method and also the customer wants condiments method so let's add those in and these are the kind of methods that are unique to this specific concrete uh beverage okay so now what we can do is we can inside of the prepare method we can call brew and add condiments okay so if you can remember
before if we go into T beforehand we we also had a boil water and pour into cup method before we called brew and add condiments but now we're going to create a separate class so that this kind of uh these two steps can basically be shared between all of the beverages to reduce uh code dup uh duplication so let's continue and let's create a uh coffee class so this is another sort of concrete uh strategy uh class and this implements our uh strategy interface which is the beverage interface so if we
Implement that and I'm just going to copy and paste uh The Brew add condiments and the customer wants condiments methods into uh this class to save some time and let's see what did we do here okay so I think that's okay yeah okay so now in the prepare method we can call brew and add condiments okay so we can also do the uh same for chamomile so let's create a chamomile class so this is another uh concrete beverage and this needs to implement beverage and I'm just going to uh for
for cam mile let's say chamomile is very simple because all we really have to do of chamomile is put the uh tea into the cup and Brew it we don't really have to um we don't really have to um add condiments to C mile okay so we can just call the Brew method so let's create a brew method and let's just Brew camomile for three three minutes okay so to prepare cam mile all we need to do is Brew it basically uh that's the only specific step to Camile Brewing it for 3 minutes so now we can create our
beverage maker uh class and this is going to contain our sort of shared code so first of all we need a field for referencing the particular beverage that we are going to be making and this is coded to the beverage interface allowing us to pass uh different types of Beverage into the beverage maker class and then we're going to need a Constructor where we set the beverage and we also need a set beverage uh method so that we can easily change the beverage that we want to prepare and in here we are just going to
set beverage equal to beverage okay so next up we need a uh boil water and pour into cup uh methods so let me just copy and paste those in so okay so these are our shared methods or shared steps every be every single beverage we have to uh boil some water and then pour it into the cup uh so then what we can do is we can have a a method called make beverage and in here we can have our common operations though so the oper op ation or steps that every single beverage has to follow and those are boil water and pour into
cup and then we can call our unique operations by simply calling beverage. prepare and as you can see our beverage maker needs no specific knowledge of the particular beverage that is that it's preparing because we are coding to an interface using polymorphism we can just call the prepare method and it will call the prepare method on any of the concrete uh beverages okay so now if we go into uh a client and show how a client might use this solution so first of all we would create a beverage maker and in here we pass the beverage that we
want to make so let's say we want a cup of tea and we have the beverag maker. make beverage so let's see how this works okay so boiling water uh pouring boiled water into the cup so those are our shared methods which are actually inside of the beverage maker class so you can see here when we say make beverage we call these common operations from within the make beverage sorry the within the beverage maker class and then we call the unique operations so in this case we Brew the tea for 3 minutes and then we
ask the customer if they would like lemon with their tea I do and I get lemon in my tea perfect so um let's say we want to now make a coffee so we say beverag maker do set beverage and we can say new coffee and we can call beverag maker. make beverage now this time it will call the two shared methods and then it will call the methods uh specific to make making a coffee so uh first of all it's making the tea so let's do the tea and then it makes the coffee and it asks if I want cream with the coffee yes and let's see
it adds cream to the coffee so this is working perfectly so let's just uh summarize what we have done here so inside of Beverage maker we Define the common behavior for making a beverage and that is boil oil water and pour water into cup and we have a an interface called beverage and uh this has a prepare method and we also have our concrete beverage implementations for chamomile coffee and tea all of which implement the beverage interface and this allows us to treat all beverages the same way in the beverage maker uh class
and from here from the beverage maker uh class uh we specify the beverage uh when we create uh the beverage maker object or we can set the beverage here and then we are delegating or uh forwarding the execution of tasks related to making a specific beverage to a concrete beverage object and this is the strategy pattern so we've just solved this problem using polymorphism which actually led to us using the strategy pattern uh but we could also solve this problem using inheritance so tea coffee and chamomile have things in
common so we we can create an abstract class called beverage that implements the prepare method but after we've boiled the water and poured it into the cup what happens next is unknown in the abstract beverage class as it depends on the particular beverage and these beverage specific steps will be determined later on when the beverage class is extended by the concrete classes so we can provide a base abstract class called beverage that contains all common operations for making a beverage and we can provide
methods called brew and AD condiments which can be implemented or overridden in the concrete beverage classes so you can see here we have our beverage class with a prepare method and you can see we have the brew and AD condiments methods which are sort of dled out in Gray which is implying that they are uh not implemented in this in this beverage class they are abstract uh methods which need to be implemented in the concrete um tea coffee and carom mile classes so you can see here this prepare method is known as a template method so
it's providing a template for the steps involved for prepar in a beverage so we have the boil water and pour into cup methods which are defined um in the beverage class itself okay because these are our shared methods that are used by all Beverages and then we have brew and AD condiments which are to be defined later on when this beverage class is extended so this prepare method is acting as a template method okay and this is known as the template method pattern so the beverage class has a template method that
provides the common setup and structure uh for preparing a beverage and here's how the template method pattern is shown in the gang of four book so we have an abstract class with a template method a public template method which calls the um some abstract methods in a particular order okay so then we have our concrete methods uh sorry our concrete classes that Implement those um those methods uh and the template method will call those methods in a particular sequence so we have an abstract class with a concrete implementation of the
common shared template method and the abstract methods that will be implemented within the concrete classes can be used to alter the behavior of the template method and we can also give the primative operations a default implementation and leave it up to the subclasses to either take them as they are or override them in this case we refer to these methods as hooks or hook operations so you can see here in this abstract class the um these sort of methods that are to be implemented in the concrete classes are not dled out
anymore so they're basically we're providing a default implementation for these methods and it is now optional in these concrete classes whether they are uh sort of overridden so we have uh method one and Method two here with default implementations within this class and we've just decided in this concrete class in particular uh in this example we're just overriding method one and leaving method two to its default implementation within the abstract class so we're not going to bother to overwrite it we're just going to take it
as it is and we refer to these kind of methods as hooks so let's now implement the template method pattern in code so here we have our base beverage class and currently we have our template method with all of the steps involved in creating a beverage now if you remember the boil water and the pour into cup steps are shared between all of the concrete beverage classes so we can actually Implement these two steps inside of this beverage class so let's copy and paste those in just to save a little bit of time so here we boil the
water and pour into the cup so those are the first two steps that every beverage has now in this template method we can now provide a uh we need to provide a brew and add condiments uh methods so I think for brew what we will do is we will make it a uh virtual uh method so in fact actually we'll make it an abstract method which means that all uh subclasses must uh implement this Brew method okay so every uh every concrete Brew needs to specify how long to brew the beverage for so what we will do is we will create a uh
protected uh an abstract void brew and it will just be like this so we must provide this uh Brew method inside of all of our concrete beverages now we can see that we are getting an error because this class now needs to be an abstract class because we have it has a it has an abstract method now let's also create this ad condiments method so the ad condiments method what we're going to do is we're going to create um this method with a default implementation so we will say protected virtual meaning that it can optionally
be uh overridden in in its sub classes and what we're going to do is we're going to provide a default implementation of an empty body which basically means that uh we don't add any condiments by default okay so that's our base uh abstract beverage class so now what we can do is we can create the concrete classes so let's start off with the T class and T needs to inherit from beverage and we also need to implement this AB abstract class so the only method that we have to implement is this Brew uh method because it's an abstract
method and in here we can just say uh Brewing t [Music] for three mens okay and then optionally we can provide a uh add condiments method here so we can override this default implementation so this is essentially a hook method so I think what we're going to do is we'll just copy this from inside of uh what we did before so let's copy and paste that in and what we need to do is we need to say that we are overriding this method from the beverage class and we have an error here let me check um oh yeah so we need to make sure
that this is protected to match the uh method signature from the beverage class okay so that all looks okay and just to save some time I'm not going to make the coffee class but I'll just make the camomile class because that is a little bit different to uh the tea class so camomile and again we need to inherit from beverage and then we need to implement the abstract class so here we'll just um we'll say Brew camk M for three mins and this is uh all we need to do for the cam mile class because cam miles
don't have any optional uh condiments so that is everything we need to do there so let's now have a look at how a client would actually use this uh solution so if we go into our client and we create a uh T beverage and let's make sure we're using the correct namespace here so this is the template method and we can just call T do prepare and then run this program and we can see we got all these are the two shared steps the boiling the water and the pouring into the cup then we have our uh sort of concrete class
specific uh logic here uh Brewing the tea for three mens and it asks us would you let lemon with your tea and we get lemon in our tea and then for the cam mile we can do the same thing pretty much and there are no optional condiments so it just makes the beverage automatically without uh us having to answer any questions so this is a nice and simple solution for clients to make beverages uh all beverages provide a simple API a simple and consistent API uh where with a prepare method and the rest of the complexities are abstracted away as the
clients require no knowledge of those uh complexities let's now have a look at the differences between the template method pattern and the strategy pattern as we've just previously used both to solve the same problem so you can use the template method pattern when you have an algorithm with a fixed structure but with certain steps that need to be customized or implemented differently by subclasses and this pattern is ideal when you want to define a common algorithm skeleton or in other words the template method in a base class and
allow subclasses to selectively override specific steps to provide their own implementations of those specific steps and the template method pattern is suitable when the over overall algorithm structure remains consistent but specific parts of the algorithm can vary based on different requirements or contexts and for the strategy pattern you can use the strategy pattern when you want to define a family of interchangeable algorithms or behaviors and encapsulate each algorithm into its own class and the strategy pattern is ideal when you
need to dynamically select and switch between different algorithms at runtime depending on the situation or context and the strategy pattern is suitable when you want to decouple the client code from specific algorithm implementations allowing for greater flexibility and extensibility so in summary if you primarily need to customize or override specific steps of an algorithm while keeping the overall structure intact the template method pattern is a good choice on the other hand if you need to encapsulate entire algorithms or
behaviors as interchangeable components that can be dynamically selected or replaced the strategy pattern is probably more appropriate so both patterns have their strength and are used to address different design scenarios the choice between them depends on the specific requirements and design goals of your application so when should you use the template method pattern you can use this pattern when you want to allow clients to implement only particular steps in an algorithm and not the whole algorithm it's a good
pattern to use when you have a bunch of classes with the same logic or algorithm but with differences in a few steps so if the algorithm changes it only has to be modified in one place and that is the base class so the pr uh pros and cons of the template method pattern so the pros uh we can reduce code duplication by having the sort of shared logic or methods in the base class that can be inherited and clients are only allowed to modify certain steps in an algorithm which reduces the risk of breaking clients if the algorithm changes and
some of the cons are that some clients may be limited by the provided template and template methods can be hard to maintain if they have a lot of steps The Observer pattern involves an object known as the subject maintaining a list of dependent objects called observers and notifying them automatically of any state changes so that may not make too much sense to here so let's go through an example to learn the Observer pattern so here we have an Excel document with two spreadsheets spreadsheet one and spreadsheet 2 and in
spreadsheet one we have a data source which is essentially do just a two column table with City in the left hand column and number of dogs in each of those cities in the right hand column and then we also have a bar chart with dogs on the Y AIS and the city name on the x axis and this bar chart is essentially um uh built from this data source and then in spreadsheet two we have um a sum so we have one of the cells is basically summing up the number of dogs to get the total number of dogs in all of the Cities so let's first of
all come up with a naive or sort of obvious uh solution to this problem so uh we have a data source object which has a list of observers so The Observers are going to be sheet two so spreadsheet two which is calculating the total uh number of dogs and we have a bar chart which is uh um producing a bar chart um from the the data source so uh here uh we we also have the values of the data source and a getter and Setter for getting and setting the values in the data source now the problem with this solution is that we
have tight coupling to the concrete Observer objects which are spreadsheet 2 and the bar chart meaning that we need conditional statements to check the object type before we actually update The Observers so this will probably make a lot more sense as as we implement this solution in code so let's do that so first of all let's create a new folder for the Observer pattern and what we will do in here first of all is create our spreadsheet 2 class so our sheet two will have a field for storing the total it will also Al have a geta which
just Returns the total and then we'll have a method for actually calculating the total and this will take a list of integers and we'll keep track of the sum in a uh variable called sum and we'll initialize that to zero and what we're going to do is we're going to Loop through each uh value in this values list and uh we're going to add it to this sum uh uh variable so we can do sum plus equals value and then let's just log what the value is and return the total at the
end okay so that's everything we need in spreadsheet this spreadsheet 2 class so let's now create our bar chart class and then here we're going to have a single method called render and this is going to take the list of integer values from the the uh data source and we're just going to keep it simple and log rendering bar chart okay so obviously if this was a proper bar chart we'd need to pass in um probably an object with keys and values or some sort of dictionary where we have uh the key as maybe the city and the
value as the value but we're just going to keep things simple for now and just pass a list of in integers because we're not actually going to be drawing a bar chart so finally we can create our data source class and this class is going to store a list of uh the dependent objects or essentially The Observers uh that rely on the data uh data source and those being sheet 2 and bar chart so that when the values in the data source are changed ER the data source can uh update those dependent objects so let's
create the data source and in here we're going to have a list of uh values so this is kind of analogous to our uh number of dogs in each of the Cities basically and we'll create a new list of integers and we'll also create a list of dependent objects or our Observer objects and these are just going to be sort of uh of type objects we're not going to specify uh the exact type of object so that we can pass in uh either bar charts or or sheet twos or any object that needs to be updated when the data source uh values are changed so
we're going to call this uh dependence we could also call it a observers but dependence we'll do for now and we'll just initialize that to a list of objects so next up we're going to create a uh geta for the values so that the other objects can uh get the values and we just return the values there and then we'll also create um a seta uh method called set values and this needs to be a list of integers and we just set values equal to values now in here whenever we update these uh values we also need to notify
our bar chart and Sheet two so that the bar chart can render itself with the new values and Sheet two can recalculate the uh total so what we're going to do is we are going to uh loop through all of our dependents or all of our dependent uh Observer objects so we can say for dependent in dependence and this needs to be for each Loop sorry and in here we need to check uh the type of the dependent the object type so we can say if dependent um is sheet two then we can uh cast the uh dependent to a sheet 2 object by writing dependent as sheet two
and this will allow us to uh recalculate the total and then in here we need to pass in the new values okay and we also can check if if the dependent is a bar chart and if it is a bar chart we can then cast the dependent object to a uh object of type bar chart uh bar chart and we can call the render method to reender the bar chart with the new set of values okay so that's actually everything we need to do uh for this set values method uh but now we also need to a way of um adding dependence to our data source so that we can actually
control uh which objects are going to observe this data source so for that we can create a method called add dependent and in here we can pass any object and we quite simply just uh add this on to our uh list okay and we also uh want to create a method for removing dependence and in here we can pass the object that we want to remove and we can call dependent do remot move and pass that dependent okay so that's everything that we need in data source so we have our sheet 2 and by chart observers and we also have our data source so now let's
have a look at how we could use this solution in a client so let's clear this out and create a new data source object and let's also create create our uh sheet 2 and barart observers and now we need to add these um these objects to the data source as dependents so we can call data source dot add dependent and pass in sheet two so this can be any object and we can also add our bar chart okay and then what we can do is we can set some values in the data source and in here we're just going to
pass a simple uh list of integers so we can say five five 1 10 and let's actually run the program now to see what we get so you can see here when we called set values it has actually uh updated the total in the sheet two and it's it's the total is 21 which is correct and it's also rendered the bar chart with these new values so if we then call uh the set values uh method again and we just set the values to say 1 2 3 run the program and we should then um get a new total and we should also get the bar
chart rendered which we do so this is all working uh perfectly however there are some issues with this solution so can you uh see what solid principles uh we are violating so maybe take 30 seconds or a minute to have a look at the solution that we've just come up with and see if you can spot uh what solid principle uh principles of being violated and the two of the most obvious uh principles that we are violating are first of all the single responsibility principle because this data source class actually has two
responsibilities it is storing data so managing data storage and it is also uh managing the dependent Observer objects so it has two reasons to change and we also are violating the open close principle because every time that we create a new Observer object we have to modify data source so if we create I don't know pie chart we then have to modify data source uh we have to come in here and check if the dependent is of type pie chart and then call the appropriate method to actually update that pie chart with the new values so we
are uh violating the open close principle and this is because because we are uh programming to concrete objects rather than to a generic interface so how do we solve the issues that we spotted uh in our last solution so we were violating the single responsibility principle and we were also violating the open close principle so to solve the single responsibility principle we could actually create a separate class for managing the dependent Observer objects and to solve the open close principle we can ensure that all of our Observer objects so
sheet 2 and bar chart in this example Implement a common interface so that they provide consistent methods allowing us to use polymorphism in the data source class so it's now time to introduce the Observer pattern so for the Observer pattern we have an abstract class called the subject and in the subject we have some methods for managing Observers so this is like our separate uh class for uh managing the dependent Observer objects and in here we have a method for adding an observer for removing an observer and
for notifying The Observers or updating The Observers we then have our uh data source class which uh manages the values and the data source as well as a geta and a Setter for those values and we can see here that the data source is is inheriting uh the Observer uh methods from this subject class we then have the subject talking to uh an observer interface which has a single update method and we can see here that the subject is composed of uh Observer objects so this will store a list of Observer objects okay and you
can see here that this abstract subject class is coded to an interface and not the concrete Observer classes and as you can see here we have our two concrete observers the sheet two and bar chart which implement the Observer interface allowing us to use polymorphism okay because this subject class when it notifies The Observers doesn't have to check what type of object we're dealing with because it knows that they are of type Observer it can just call the update method without knowing the specifics so this actually
uh uh this solution now follows the open close Principle as we can extend our application by adding new Observer classes without having to modify the data source class so for example tomorrow we may may want to add another spreadsheet that finds the average of the data source values and to do that we can just create a new sheet three class that implements Observer and the data class doesn't care it just talks to The Observer server interface and set values in um the data source will uh simply Loop through all of its observers and
call the update method on each and this is polymorphic Behavior a different update method will be called depending on the Observer but data source doesn't care or it doesn't need to know what the specific concrete observers are each concrete implementation figures out how to update themselves so if we have a look at the gang of four Observer pattern here we can see that we have the abstract subject class with three methods for managing The Observers the list of observers and we have an attach detach and notify so that's basically
the same as what we had up here add remove and notify or add detach and notify then we have our Observer interface with its update method and we have our concrete subject and our concrete observers so very similar to the solution that we have up here so um The Observer pattern is also known as the Pu uh Pub and sub pan so the publish And subscribe Pan and the subject uh which is the publisher publishes changes in its state and the subscribers or The Observers subscribe to those events so let's now refactor
our code to use The Observer pattern so let's now refactor our code using the Observer pattern so first of all we're going to create an observer interface and in here we give it a single method called update and then we can refactor our concrete observers so we have bar chart which needs to implement Observer and we can see here we get a red squiggly line indicating that we have an error because we are not implementing The Observer update method so here we can simply change this method to update but we
still get an error because we are not actually uh using the same uh method signature so if we go into this Observer interface we can see that update doesn't have any parameters so we need to remove this parameter but we still need a way of getting the values from the data source so what can do instead of passing them to this update method we can store a uh field of type data source and pass the data source object into the Constructor whenever we create a new bar chart okay so that's everything we need
to do for our bar chart class so let's now go into to our second Observer which is sheet 2 so again we need to implement the Observer interface and then we also need to implement the methods so we should we get an update method here so what do we need to do in this update method so I'm just going to move this up a little bit so let's move it to here and what we want to do is we want to set the total to the sum of the uh values So currently we don't have any way to uh access the values so again
let's uh create a new field for the data source and we'll pass that via the Constructor and now what we can simply do is set the total uh field equal to calculate total and we can pass the values by getting them from the data source object so here we can just say total is equal to calculate total and then we can get the values from the data source object which we have passed into this object okay so that is everything that we need to do for the uh sheet two class so now what we can do is we can create a uh our subject
class which is going to be the class that manages observers so let's create that class and here we need to first of all create a field for uh keeping the list of Observer objects okay so then we need to add our three methods for managing observers so we need a way of adding observers removing observers and also notifying All The Observers in the list that um our our sort of source object has changed so first of all let's create the ad Observer method and then here we pass the Observer that we want to add to the
list and we can just call observers do add Observer and then for the remove Observer and again we pass the Observer to this method that we want to remove and we just call observers do remove and we pass the Observer okay and finally we need a way of well we need a method to uh notify our observers so here we can see we're getting a suggestion for each Observer and observers and that's what we need to do and we can just call observer.
 update so we can call observer. update okay so here we can see we have uh we are using polymorphism to update The Observers this subject uh class doesn't need to know anything about the actual specific concrete observers that are in this list it just needs to know that they are some sort of Observer so that we can then use polymorphism and just call the update method so this is a nice flexible clean maintainable way of notifying The Observer objects even though they may be uh of different even though they are different types of objects so next we
need to refactor our data source class so in here we no longer are managing The Observers so we can remove this uh dependence list and let's see so we have our G values uh method so we want to keep this okay because this is used in our Observer uh in our concrete observers and the set value uh method can now be cleaned up so we can see before we were storing a list of just uh objects and we had to actually check the type of object and then cast it to the type that it that it was found to be so that we can uh could call the update
method on that object so what we can do now is we can actually get rid of this uh large block of code and simply just call the notify observers method but we can't do that yet because we actually haven't uh inherited the subject class so let's inherit that and now we will have all of the methods uh from this subject class so we've inherited them which means that we can just call notify observers so this is much cleaner and we also no longer need to have these add and remove methods because we're
this class is no longer managing The Observers so that is much cleaner so that should be everything that we need to do so let's now go into the program.cs file and let's change this to observer. good example so let's see what do we need to do differently here so we are creating a new data source so let's see uh let's actually start again here so we'll say data source uh data source equals new data source and let's create our observers so we'll create a sheet two and actually this should be uh our good
example sorry I'm not sure why we are getting an error here uh let's see so what did we do here let's see ah so we're using lowercase s here actually so let's just use a lower case s actually no we'll change this here to be correct so let's correct this so if I use function F2 let's change that to the correct casing and then come back into program.
cs there we go the error goes away so now for Sheet two this is in our first or second Observer I guess we need to pass the data source uh object into here and we also need to create our bar chart class and and again pass the data source into that object and let's see we yeah and what did we do here let's see H for some reason I decided to not use uh not uppercase the second word again let's see okay so hopefully that fixes that issue okay there we go so now we can add our observers to the data source object so let's do that okay so now if we set the values in
the data source it should then notify uh notify our Observer objects and uh cause them to be updated so let's try that and we're going to pass an array of values so 55 1 and 10 and let's run this program to see if our observers are notified and updated correctly so here the sum is 21 which is correct and we are rendering the V bar chart with new values so if we also uh if we change the values now to uh 1 2 3 so let's see what we get now we can see that the total is updated correctly and the bar chart is rendered
with new values so this is all working perfectly so we can see here let's have a look at how using the Observer pattern has improved our solution and made it more flexible and maintainable so if we look first of all in the data source uh class we can see that we this is now satisfying the single responsibility principle because data source is now only managing the values it is not managing observers The Observers uh methods and the Observer list are all managed by this subject class okay so now this subject class has a sole
responsibility for managing observers and one a good advantage of this is that this subject class could now be used for for any other class that needs to be observed so this is a much more flexible and uh maintainable solution and the second uh thing that we' have done is because we are now using an observer interface and forcing all observers to implement this Observer interface we can now use polymorphism inside of our uh subject class so we can see here that we can simply call observer. update and treat
all observers as as though they are uh the same object without having to check the type of object and then call that correct uh specific method on the Observer we know that they have an update method because they are implementing The Observer interface and we can just use polymorphism which makes our solution much more clean and flexible so we're now going to have a look at the different types of communication styles that can be used to when implementing The Observer pattern so beforehand The Observers get notified
of a change but they don't know what has changed and one solution is to add a parameter to The Observer update method and this is known as a push style of communication as the subject pushes the changes to The Observers so beforehand we actually the way that uh our observers got the values from data source is by actually storing the data source in a field within the class and then when we need to get the values from data Source we call a method on data source uh so a push style communication would be different so we wouldn't
actually store a field uh for the data source within the Observer and we would actually uh push the uh values to this update method so this update method would have some sort of parameter and that could be uh any um object or just some sort of gen generic type for flexibility so the push style has the advantage that the concrete observers don't depend on or have any knowledge of or coupling to the concrete subject okay so the problem with uh this solution with this push style uh solution is that what if each Observer
needs a different set of values and this is where we could use a pull style of communication where the Observer stores a reference to the concrete subject then whenever whenever it's notified of a change it pulls or queries the data it needs from the concrete subject and you can see here this is actually the solution that we used for uh our example where we have our concrete observers that keep a reference to the concrete subject and you can see here sheet two and our barart both have a field with reference to the concrete data source
object which is passed in Via a Constructor and then whenever it needs uh any values it can pull them or query them using this Gap values method uh so you can see the difference here between push style and pull style with push style we are pushing uh the uh values to the update method by uh passing them as arguments and this means that the concrete Observer doesn't need to be coupled to the concrete subject however it's not as flexible as the pulse style where the concrete Observer keeps a reference to the concrete
subject allowing it to query any of the values that it needs so again the concrete Observer stores a reference to the concrete subject in pul style and we give concrete subjects a get Value method so that the concrete observers can get the data that it needs and this gives us more flexibility however we do have coupling here between the concrete classes but this isn't actually a bad type of coupling a bad coupling would be between the concrete subject and concrete Observer so if we basically reverse this
arrow and this is because these observers could change in the future and we may also introduce more observers and the concrete subject would then have to keep reference to all of the different types of concrete Observer so this would uh not satisfy the open close principle because every time we added a new Observer we would have to update the concrete subject and we don't want to change our concrete subject class uh data source in our example every time there is a new Observer so in reality we never have zero coupling in software
what matters the most is the direction of the relationship and in this case the direction is okay so with p style communication we pass the concrete subject the data source to The Observer uh just like we did when implementing our Observer pattern for our data source with the bar chart and Sheet two observers the mediator pattern defines an object called the mediator that describes how a set of objects interact with each other therefore reducing lots of chaotic dependencies between those objects so let's go through an example
to uh so that you can understand the media a pattern in an easy intuitive way so let's say that we have a Blog that lists all of your blog posts and you can select a post then edit that post title so you can see here initially when the page loads we have state one where we have a sort of list of blog posts and none of those posts are initially selected so that's the initial State no posts are selected and then the user can select an article from the posts cont container so this is the post container
and in this case they've just selected post three and uh a sort of text input is then populated on the right hand side of the screen where with the title of the post and then the uh save button becomes enabled so the user can then update the title of that post within this text box and uh the save button is disabled if no title is provided so if the user deletes all of the characters from this uh text box then uh the post button is disabled and also if no post is selected then the save button is also disabled so you can see here the dis
save button is disabled because no title is provided so we need uh some components for this uh application so first of all we have a list box that contains the posts so this is the list box then we have a text box for editing the title and a button that can either be disabled or enabled and the above classes list box text box and button will come from a UI framework so that so we do not have access to the source code to these UI components um so uh again when when an article is selected from the list box the text box
should be populated and the button enabled and when we clear the text box the button should become disabled so the question becomes how do these classes talk to each other so they should be able to ideally uh be able to talk to each other without knowledge of each other and one solution would be to use inheritance so we can see here at the top we have our UI framework classes that we cannot touch so we don't have access to these this is just like an installed package and we have a list box text box and a button class and then we
can extend each of those classes to to create our own sort of custom versions of these classes so we can extend list box to create our own post L list box class then we have a title text box which uh extends or inherits from textbox and same again for button for the save button and then these uh sort of custom classes that extend the UI Library classes can then talk to each other uh like this so we can see here that posts list box holds a reference to the title uh text box then uh we can create an unselect method so that when a post is
selected from the list it calls uh uh it sets the text on the text box and enables the save button and then within title text box we have an unchange method so whenever the uh user type some characters into the box or delete some characters we check to see if the text is an empty string and if it is we disable the save button and we can see in save button it holds a reference to the title text box because when the button is clicked if the button is enabled then it will get the text from the text box and save it to the
database okay so the problem with this solution is that as our form gets more complex there becomes lots of dependencies or connections between these classes and also the logic for this form is spread all over the place it's spread between all of these classes so to see what's going on in this form you have to look at multiple classes and it's very difficult to understand and maintain so we can solve this problem using the mediator pattern and using the mediator pattern the UI components don't
need to know about each other as all of the interaction logic is in this dialogue box which is the mediator so whenever a UI component changes it notifies its owner which is the dialogue Box by calling the changed uh method and passing itself uh so each of these uh components are UI control components and it passes itself as an argument to this change method which then handles updating all of the other components so this will make a lot more sense as we implement this in code so let's go ahead and do that
so I've created a new folder called mediator and then first of all we're going to create our dialogue box mediator class okay so this class plays the role of mediator so every time a UI component changes its state it will call a its groups dialogue box so uh this is actually going to be an abstract class class so let's change that to abstract and we're going to provide a public abstract method called changed that will uh take a UI control or UI component and this hasn't been created yet so we are getting an error and you
might be wondering why this is actually an abstract uh class and not an interface and that is because in a re guey framework we would provide some concrete methods as well as these abstract methods so that is why I've created this as an abstract class so next of next up let's create this uh abstract UI control class so uh the abstract UI control class is going to ensure that each UI component gets put into a dialogue box and a dialog box is essentially just a group of UI components so we're going to
need a field called dialogue um of type dialogue box and we're going to call this owner so uh all UI components uh can be grouped into a dialogue box and know and can talk to their owner so this allows the owner to change all the the UI components accordingly so all the UI control components need uh a single uh dialogue box or mediator owner and we can now create a Constructor here where we can pass the owner to the UI control so we're specifying you know which class should be the owner okay so now we have our UI control uh
class okay so next up we can create our concrete UI components that extend the UI control class so first of all I'm going to create the list box class and this needs to extend UI control so let's actually uh generate a Constructor to satisfy this UI control uh class and you can see here what we are doing is we are passing a dialogue box or mediator owner to the list box instructor and setting the owner in the base UI control class so next up what we need to do is a list box um we need to be able to select
a post so what we'll do is we'll just simply store a private string called selection and set that to an empty string and then we'll create a couple of of Getters and Setters for setting the selected post um inside of the list box so let's first of all create a geta function or GAA method called get selection and this will just return the selection and then we'll have a set selection and we will set the selection and what we need to do here is we actually need to Now notify the owner that this class
has changed so if we uh select a title from the list box selection will be updated and we need to uh let the other components know that this class has changed so what we do is we notify the owner by calling owner. changed and then we pass this UI control class or object to the changed method and then within the owner uh the owner can see that this a this list box has changed and it can then update the other components so the text box and the button accordingly so next up uh next up we're going to uh create the concrete text box
class and this is going to again extend uh UI control or inherit from UI control and then we need to generate the Constructor so that it satisfies the UI control class and textbox is just going to have a simple text field initialized to an empty string and then we need to create again our Getters and Setters for this text field so we set the text and again we need to notify the owner uh which is a dialogue box a sort of mediator class that uh this class has changed so we call the changed method and we pass this text box
object and finally our final uh concrete UI control component is the button so let's create a class called button and this is going to extend UI control we then need to uh generate the uh Constructor just the same as before and a button class just needs to store a uh field just to uh State whether the button is en enabled or disabled and we need some Getters and Setters for this Ena um is enabled uh field and again we need to inform the owner that the button has
changed okay so here again we are telling the mediator that I this button object have changed so uh finally what we need to do is create the uh posts dialog box that's going to contain all of the UI components for our post title editing application and it's going to update these components depending on which component called the uh changed method so that's going to make more sense as we actually uh create this class so we're going to create posts dialog box and this class needs to extend dialog
box so this is kind of like our concrete mediator class so let's implement the abstract class so it needs to have this changed method and what we'll do first is we will create all of our fields for all the UI components so we need a list box a text box and a button uh we now need a Constructor so that we can pass all of our UI components to this uh concrete mediator the post dialogue box so let's create a Constructor and what we're actually going to do is we're just going to initialize them inside of the
Constructor rather than pass them so we'll say post list box equals new list box and if you can remember within each UI control uh component we need to actually pass the owner and the owner is just going to be this so then we do the same for all of the other components and also in the Constructor we're going to set the save button to disabled because initially the save button needs to be disabled so next up let's actually add the logic inside of our changed method so what we need to do in here is we need to check what the UI
control is so if the UI control is equal to a posts list box or the post list box then what we need to do is we're going to set the title text box so we'll say title text box uh do set text and we're going to set that equal to the post list box. get selection okay and we also need to enable the save button and what we should do is we should set enabl here okay so you can see that if the UI control is a post list box so if the post list box has changed then that means that a post has been selected so
therefore we need to update the title text box with the selected uh post uh title and we need to enable the save button okay so that is pretty straightforward uh then we need another conditional to say that if the UI control is equal to a title text box so this means that the title text box has changed so the user uh has entered a title or deleted uh the ti some characters from the title so what we need to do here is we check to see if the title is empty so we can create a Boolean so here we are checking if the title
text box is empty and then what we can do is we can set uh the uh we can get the save button and set enabled equal to the opposite of is title empty so if the title is empty then the save button will be disabled whereas if the title isn't empty then the save button will be enabled okay so that is all the logic we need however you can see that this is a little bit bloated this change method so let what we can do is we can create a couple of sort of helper methods now so it would be nicer if we could just call
handle post changed uh to handle the post list box changing and sort of abstract this logic into its own separate method so let's create a private void called handle and let's capitalize that actually handle post changed and we can paste the logic down here and let's capitalize this and let's do the same for our uh text box logic so handle uh title changed and let's cut this and put it all in its own separate method okay so that's a little bit tidier much clearer what is going on here and so now that is pretty much
everything we need to do so notice how clear it is now uh because all of our business Logic for our application is centered inside of this one post uh dialogue box our sort of concrete mediator so our sort of logic isn't spread out over multiple UI components so this is much more readable much more clear what is going on so let's um now create a method inside of this post dialogue box to simulate a user interaction so what I'm going to do is I'm going to create a method called uh simulate user
interaction and what we're going to do is we're going to essentially say that the user has selected a post and the post title is post two and we're going to uh log to the console the uh title inside of the text box and we're going to check if the button is enabled okay so this is just a sort of method to simulate a user interaction so the user selects a post from the post box and then we're just checking to make sure that the title text box is updated correctly so this should be post two and
we're also checking that the button is enabled so now let's go into our program.cs file and check that this all is working correctly so let's create a posts dialogue box and then let's simulate a user interaction and run this program and as we can see the title text box has been updated correctly it has been populated to post two which is correct and the button is enabled which is perfect so that's all working correctly uh so let's also test out that the user enters no title so if we come
back to our posts dialogue box and let's set the title to an empty string so essentially the user has selected post two and then they have deleted the title from the post uh from this uh title input box and then if we go to our program.cs file and run this let's see what we get so we can see that the title text box is empty which is correct and we can see that the button button is no longer enabled so that the user cannot save a post with no title so this is all working perfectly so here is the gang of fourl for the mediator
pattern so here we have an abstract class called the mediator and this uh was analgous to our dialogue box class in our example we then have a concrete mediator so this was like our posts uh dialogue box which extends the mediator class we then have an abstract class called colleague in our case we didn't make it abstract and our colleague class was the UI control uh class and you can see here the UI control class or the colleague uh is associated to or sort of stores a reference to uh it's mediate so
its owner and you can see here our UI control which is our colleague sour reference to the dialogue box or its owner which is the mediator class okay we then have our concrete colle classes so these are in our example were our UI components so text box list box and button and you can see here that we then have our concrete mediator so this was our posts dialogue box which stores uh reference to all of the UI components that it owns okay so the concrete colleagues are all unrelated or uncoupled from each other they talk to
each other indirectly via the mediator allowing them to be reused in different contexts for example we are not coupling a list box to a text box or a button the only coupling that we have is between the concrete mediator and the concrete colleagues and this is fine because in our example the posts dialogue box needs to know about all of its UI components so that they can interact with each other the mediator pattern can be used with the Observer pan so one problem with our previous solution is that the changed method on
the posts dialogue box can get bulky as we add more UI components which means that we'll have lots of if L conditional statements to see what components has changed so you can see here this was our changed component and we're checking what type of UI control has changed then handling it accordingly so you can see how this can get bulky as we have more UI controls in our uh dialogue box so to solve this we can actually implement the mediator pan using the Observer pattern so let's just remind ourselves of what
the Observer pattern looks like so we have an abstract class or which is called the subject and this has three methods so we have an attach detach and notify and this subject uh class will sort of manage a list of observers uh and then we have our concrete subject um which is the class which is being observed we then have an observer interface which has a single update method and we then have our concrete observers which implement this Observer interface and it each of these observers has an update method for updating the
Observer whenever the concrete subject has changed and whenever it changes the concrete subject calls this notify method it Loops through all of The Observers and um and calls this update method on each of The Observers so uh below now we have the UI controls which are our subjects so we have list box text box and button and these are our subjects okay so these are the uh components which are being observed and we then have our uh posts dialogue box in the middle here and this is the Observer so whenever a UI control changes the posts
dialogue box gets notified so let's actually implement this in code so that it becomes clear what is going on so I've created a new folder called mediator with Observer where we're going to create our new solution with the Observer pattern so let's also create a folder called uh UI framework and this is essentially going to be the code that we would not have access to within our application so it's some sort of UI library that we have installed and within here I'm going to create a delegate called event handler
so I'm going to first of all create this as a class and then we will modify it into a delegate so let's remove all of this and this needs to be a delegate and we need to return void so in cop we can use delegates to specify what an event handler or a callback method should look like so here we're saying that event handler methods should return void and receive no arguments and uh just stick with me because this doesn't really make much sense just yet but it will make more sense as we develop this solution further so next
we're going to create the UI control class which is our subject class from The Observer pan so let's just extend this out a little bit and we're going to create a class called UI control and yeah as I said this is the subject class from The Observer pan so this is going to basically uh manage our event handlers so it's going to keep a list of callback methods for updating the other UI components when a user interacts with them so let's create a list of event handers and we're going to need a method
for adding event handlers to this list okay so we add the event handler onto the list and we also need a method for notifying the event handlers or calling the uh event handlers I should say so we're going to call this notify event handlers and we are going to Loop through all of the event handlers and we're just going to Simply invoke each event handler method okay so let's just call this uh Handler okay so uh just to sort of explain what we're doing here so each UI component is going to extend this UI
control class uh meaning that we can add certain event handlers to each UI control components and whenever so for example the uh posts list box uh what we can do is we can give it or add an event handler to the this component and then whenever the post is selected we can call this notify event handlers method which Loops through all of the uh methods and calls them so in our case the posts whenever a post is selected from the post list box it should um update the title text box and enable the button so again this is going to make
more sense a little bit further down the line so just stick with me for now so now what we're going to do is we're going to create our uh concrete UI components so first of all let's create the list box and this needs to extend UI control and now what I'm going to do is just copy and paste the uh code that we essentially had before so here we have our selected post we have our getter and we have our Setter and whenever we whenever we set the selection we are calling this notify event handlers
method which we get from UI control so now let's create our text box and again we inherit from UI control and I'm just going to copy and paste this in because again it's the same as what we had beforehand okay so again we can set the text get the text and whenever we set the text we are going to notify the event handlers that have been attached to text box and our final concrete UI component the button class which inherits again from UI control and again I'm just going to copy and paste this in because it is the same
as what we had beforehand okay so again we have our set enabled method which notifies uh the event handlers or invokes the event handlers that are attached to the button okay so now that is basically all of the code that uh we need for our UI framework or the the code that we have basically downloaded or installed that we don't have access to so now we can actually create our custom code which is going to be our posts dialogue box so this is essentially now our application so we've create we've basically installed this framework and
now we are going to use this framework so in post dialogue box so I just want to mention actually before we uh create any more code that post dialog box is now going going to be both a mediator containing all of the business Logic for how UI components should interact with each other as well as being an observer which receives notice whenever a UI component changes so it's now both a mediator and an observer so first of all let's create uh declare the fields uh for the UI components and we can see here we need
to import these uh these classes from our UI framework folder and then I'm going to create a Constructor where we can initialize these um Fields okay and now what we need to do is we need to add our event handler methods to each UI component so before we do that we actually want to uh add our uh methods for handling uh events so if we have a look at what we did before in the mediator um example if we go to our posts dialogue box we have a handle post changed method and we also have a handle title change method so let's copy and
paste those in okay because these are going to now be our event handlers okay that we can attach to each of these UI components so now what we can do is we can call uh posts list box add an event handler and the event handler that we want to H to add is the handle post change events uh Handler or let's give it a better name of uh post selected okay and let's also add an event handler to the title text box and I'm going to change this to title changed okay so that's pretty clear what's going
on here so as you can see if we compare this to beforehand in our post dialogue box we had to uh check which UI control had changed whereas now because we are just adding event handlers to each of the uh UI controls we no longer need to check um which UI my control has changed so it's a lot tidier and as we add more components this is going to be a lot cleaner than the solution that we had beforehand so now what we can do is add a method to simulate a user interaction so let me copy and paste that in to save
some time so here we go so what we're doing here is we are uh simulating a post being selected from the post list box and we're then going to log out to check whether the title text box and the button has been updated correctly so now let's go into our program.cs file and test all of this out so let's create a posts dialogue box and there should be posts dialogue box um mediator with Observer and we then need to simulate a user interaction so we can call that method and then we can run the program
to test that all the components have been updated correctly and as you can see here the title text box is post to and the button is enabled so let's come back into our post text box now and basically uh simulate the user deleting the title and check that our other components have been updated correctly so as you can see the title text box is now empty and the button enabled is false which is exactly as it should be so let's now just take a quick look at what we have done to summarize what is going on here so you can see here in our
post dialog box Constructor that we set our components equal to uh our UI components and then we are adding event handlers to each of the UI components so let's have a look at this post list box we add an event handler called post selected and if we take a look inside of our list box we can see that whenever we set a selection um we are calling the notify event handlers method which comes from this UI control component and this uh method Loops through all of the event handlers that we attached and if you remember in post
dialogue box we just attached this post selected method and what we do is this uh method is then invoked so you can see here we call this method and uh this method then updates the title text box and the save button accordingly so this is great because we have now combined the mediator pattern with the Observer pattern and reduced the ugly bulky conditionals that we previously had in the post dialogue box the chain of responsibility pattern allows building a chain of objects to handle a request a request is passed
through a chain of handlers each capable of either handling the request or passing it to the next Handler in the chain so to understand this let's go through an example where we first create a simple naive solution then refactor it into something more maintainable using the chain of responsibility pan so let's say that we have a web page that contains some information that only admins of the website can access such as a page that allows an admin to manage the website's users for example create new users get information update user
information Etc so say that a user makes a requ request to the website server but before returning the web page the users's data must be validated so for example we could trim any Whit space around the user uh user entered data we need to authenticate the user so for example check their username and password are correct and then log some information onto the server about this request and if any of those steps fail then access denied is returned to the user so here is an illustration so we have the users request here which goes to the server
which validates authenticates and logs some information and if any of these steps fail so if the uh authentication fails then the user uh then access denied is returned to the user otherwise we can return the web page to the user so let's now code up a straightforward solution for this example so I've created a new folder called chain of responsibility for this example and we're going to first create the HTTP request class so in here we need a cou uh four Fields so the first two fields are going to be the user input Fields so that they
are going to be username and we're also going to create a a second field for the password of the user and these are going to be sent with the HTTP request and we're also going to provide a couple of other fields so these are actually going to be C Properties and one the first one is going to be validated username and that needs to be a string and the second one is going to be validated password okay so when these uh when the username and password pass through uh validation then they will uh these fields will be populated with the
validated username for example if username is a string with some white space at the front then the validated username will just be this without the whites space okay so it's essentially cleaning up the user input data so let's also create a Constructor so that the username and password can be set and we'll also create a get username uh method and also a getter for the password okay so that's everything we need in our HTTP request object so let's also create a class for the validator now which is
going to validate our um user input data that is attached to this request object so let's call this validator and we'll have a method called validate and this takes the HTTP request object and let's actually get the username and password from the request object and let's also get the password and then we're just going to do some simple validation um and in this case we're just going to trim the white space around the uh import strings for username and password so to do that we can uh call uh username do trim and
password. trim and then we can set that to the validated username and validated password on the request object okay so that's all we need to do in our validator class now for the authenticator so once the request has been validated we can pass it to the authenticator class so let's create that class now and let's get the username and password again and we're just going to keep it simple here and we're just going to
check if the username is equal to Dany and the password is equal to 2 3 and if so this will return true meaning that the user has been authenticated okay so that is everything we need for the authenticator class and finally the final step once we've been through uh validation and authentication we can perform some login so let's create a new class called logger and in here we will provide a uh s single method for logging to the conso okay and finally we need to create a web server class um so let's go ahead and do
that and this needs to have a method called handle which is going to handle the request so let's go ahead and create the handle method and this is going to take a HTTP request okay so now what we can do is we can actually uh put everything we have done together so first of all let's validate the request and we can call the validate uh method on the validator and we can pass the request so that will populate the request object with the validated username and password so in our case we're just trimming the username and
password and we we can now create the authenticator and for this we can call authenticator do authenticate and again we can pass the request object so in a sort of real web server we' perhaps um do something like uh throw an error if the um if the user wasn't authenticated or maybe we could um uh return a web page with access denied something like that but uh just to keep things simple for now we're just going to call the function uh call this authenticate method and not worry about whether it's true or false
okay and then finally we're going to uh create a logger a logger object and then we're just going to log and in here we pass the request object okay so that's everything we need for now so now now let's have a look at how we would actually use this solution in a client so first of all let's create our web server and let's also create our request object and it should be this one and I'm going to pass um the username name and password into this so this is kind of like our user input data
or perhaps some data that was stored in a in the user session and um this is the username and the password and in this case this would actually uh authenticate the user because we want to check if the password and username is Danny and 123 and it is in this case so that would be uh an authenticated user and then we can call the server.
 handle uh method and we can pass the request object so let's run this and see what we get okay so everything seems to be working okay the the log file has logged to the console so that all seems to be working okay now this seems like an okay solution um it's pretty straightforward however there are some problems with this approach so with this solution the order of operations so if we go into our main sort of web server class which brings everything together um we can see here the the order of the operations so we have validate authorize
and log are hardcoded inside the web server class so if in the future we wanted to disable login or or authentication for certain scenarios certain Roots certain web pages we cannot do so we'd have to come back and modify the code in in the web server class itself um and this violates the open close principle because if we wanted to uh change the order of the steps or add an extra step we'd have to modify some existing code and the chain of responsibility pattern uh solves this as we can build a pipeline with a chain of objects for
processing a request and the request can be of any type not just just a HTTP request uh another issue with this solution is that because of the new keyword so you can see here we're using the new keyword uh three times within this uh method inside the web server class um um we can see that the web server class is tightly coupled to these concrete validator authenticator and log implementation so to solve this we could extract interfaces from these classes and have our web server talk to I authorizer I validator and I logger interfaces and
this would make our web server class more flexible because if we wanted to use a different type of validator or a different type of authenticator we could then pass that into the web server so that it's not um sort of tightly coupled to these concrete implementations so let's now try to solve the problem using the chain of responsibility principle so instead of having all of our request processing logic inside of the web server.
 handle method we can create a processing pipeline or a chain of objects so uh here you can see that we have our request incoming request our HTT request uh HTTP request sorry and then we have a sequence of objects so first of all we have the valid data which validates the request and then this points to the authenticator and passes the request to the authenticator and if it's successful the authenticator points to the logger and passes the request onto the logger and if that is successful then the user can be directed to the web
page or the web page is returned to the user so here each object only knows about the next object in the chain so for example validator only knows that the next object in the chain is authenticator it doesn't know anything about the logger object for example uh so first a request is passed to the first object in the chain which in our case is the validator and if this request is successful it passes the request to the to the next object in the chain if it's not successful it will stop processing right there so that the
other objects aren't used so here's the uml for the chain of responsibility solution and you can see here we have our web server which has a handle method which takes the request and web server is composed of a Handler um which is an abstract class with a set next method for setting the next Handler so for example validator would we would set the next Handler as authenticator and then for authenticator we would set the next Handler as logger and uh each Handler need needs to have needs to implement a handle method which takes a
request object okay so uh we have an abstract class called Handler uh that has a reference to itself so it has a field called Next of type Handler so with this each Handler can know about the next Handler in the chain and this is essentially a linked list data structure and the handle method is an abstract method because at the time time of implementing this class we don't know how to handle a request we determine or implement this in our concrete handlers which are in our case validator authenticator and logger so
web server has a reference to the first Handler in the chain okay and that is the validator okay so when when the web server receive the sees the request it can pass the request to the first Handler in the chain which in our case would be the valid data Handler so you should also note that web server is not talking directly to the concrete handlers it's talking to a Handler interface so it's completely decoupled from the concrete implementations of handlers and this satisfies the open close principle
because if we want to for example remove login we don't have to go to the handle method on the web server and change its implementation also if we want to add a new process we can create a new class that extends Handler then add it to our chain we extend the code but we don't modify any existing source code so here is the gang of for implementation of the chain of responsibility patter so we can see here we have our abstract Handler class which has a next field of type Handler okay so which is the same um
same type as itself and we also have a set next method which takes a Handler and this is how we can set the next uh field and we also have a handle method which takes a request object and in this handle method we can see that we check if next is not null then we call the next handlers handle method and pass the request we then have our concrete handlers which um inherit from this Handler abstract class and then we have our client here so this is how our client can create a chain using this uh solution so we can
see here we're creating a Handler one Handler two Handler three and these are concrete handlers that it's creating here so Handler one Handler two Handler three uh you can see we're using the new keyword and then we can uh set up our chain so we can call H1 so handle one. set next and what comes happen after Handler one it will be Handler two so we pass Handler two and then for Handler two we call set next and pass Handler three and then to initiate the request we get our first Handler and call the handle method and
pass the request object so let's now implement this solution in code so first of all let's create the abstract Handler class so first of all let's create the abstract Handler class and this needs to be an abstract class and we need to store a reference to uh the next Handler in the chain so let's create a field of type Handler and we'll call this next Handler okay so let's create our set next uh um method as well and this is going to return a Handler as well as accept a Handler and we're just going to set the
next Handler equal to this Handler so why would we actually return a Handler from this set next function or method I should say well the reason for that is because returning a Handler from this set Handler method allows us to link handlers in a convenient way so for example we could call a Handler one so H1 uh and if it lets me do it let me just do it as a string so H1 and it will be set next and we could pass H2 in here so Handler 2 and then because this set next method is returning the Handler we can then simply just keep on chaining the
set next methods and and very conveniently can um create our chain of uh responsibility essentially okay so it's you can do it all sort of on one line rather than having to you know do it on multiple lines so it's nice and convenient and that is why we return Handler from set next and if that doesn't make sense it will make more sense when we actually use this solution in the program.
cs file so bear with me for now uh so next up we want to create our sort of handle template plate method so let's go ahead and create that and this is going to take a HTTP request so what we want to do now is we want to uh have an if statement so we're going to say if do handle request and this should be do hand handle and we're going to create this method in a second so if do handle request then we can return from this handle method so what this essentially means is if do handle returns true we return early and the request processing
H ends here uh otherwise we are going to check if uh if the next hand is not equal to null then we are going to um call the next handler do handle method and pass along the request object so now let's actually uh create this do handle method so this is actually going to be an abstract method that returns a Boolean and takes a a HTTP request object okay so this uh do handle method is going to be implemented in the concrete handlers so this is going to make more sense shortly so again bear with me uh so let's now create the concrete handler
classes so first of all let's create the validator and this needs to uh extend the Handler class so let's uh implement this abstract class so we need to create this do handle uh method and in here we're essentially doing what we did before so we uh get the username and the password from the request object trim the whitespace and set the um appropriate Fields as we did before okay now this time we also need to return a Boolean value so what should we return here so returning false means that that that we are not done
processing the request so the next handle it in the chain should be called and returning true ends the request processing uh here so um this in this case we should always return false because there's no reason for the request to uh stop processing at this point so here we can simply return um request actually what we can do is we can return um we can return true if the validated username or the validated password or empty uh empty strings so if the user provides an empty string for username or password then we will stop the process
in here and the user will not uh re go through to the web page essentially so let's let's go with that so request. validated username equals empty string or request. validated password equals empty string so essentially if we return false here then we are not done processing the request so if the um if the user has provided a username or password uh sorry a username and password then we will continue processing the request otherwise the request ends here if the username or password is not provided okay so now
let's create our authenticator class and this again needs to inherit from the Handler and for this one I'm just going to copy and paste in what we had before uh so you can see here if the username equals Danny and the password equals one 2 3 then this in the brackets will be true however true would mean ending the request so what we actually need to do is stick an exclamation mark to negate or you know make this the opposite of what the result in the brackets is so if the username is Danny and the password
is correct then we actually are going to return false and the request will continue on to the next Handler okay so that's what we want to do here and just to remind you why that is the case it's because in this sort of template method this handle method we are checking if do handle is equal to true and if it is true then we end the request okay so we if we want to continue to the next request uh the next um the next object in the chain then we need to return false from this do handle method so that's how that works and
finally we're going to create our logger object and again we need to extend the Handler class and Implement all of the methods and this is a very simple method all we're going to do is log to the console and just return false to continue with the request so essentially this means that this uh sort of Step In The Chain uh can never fail basically it's a sort of fail prooof um Handler okay so now let's have a look at how we code up the web server class so let's create the web server class okay so in here we need to store a
reference to the first Handler in the chain so let's do that and we can pass the Handler in the Constructor okay so let's also provide a handle method just like we did before it takes a HTTP request and we're just going to call handler. handle and we pass that request object okay so now let's actually use this solution in the client so let's M get rid of all this and we can say v v validator equals new validator let's see I think it should be this one
yeah and let's also create an Authenticator authentic authentic a sorry having some spelling issues there and logger equals new logger okay so now what we can do is if you remember when I mentioned earlier that we are returning the Handler from the uh set next method and because we're doing that we can just chain everything together in one line so we can call validate data now this is going to be our first object in the chain and we're going to set next so the next object needs to be the authenticator so that's
our next step in the chain and because the set next is returning a uh Handler we can just chain on the next Handler and that is going to be the logger okay so we can do that all nice and conveniently in one single line of code okay so now we can create our server and we pass the first um Step In The Chain the first object in the chain which is validator in our case and then let's create a uh HTTP request and that's not what we want let's see I think we actually need to create this uh HTTP request object inside of
our new uh good solution folder so let's actually uh let's create this HTTP request object cuz we forgot to add it to this new uh good solution folder and this is actually going to be the same EX exactly the same as what we had beforehand so let's copy and paste everything that we have inside here and we'll paste it inside of here so hopefully that fixes the issues that we had before and and here we need to provide a username so first of all let's actually pass some uh credentials that are
correct so this will pass uh the validation and authenticator steps so let's handle this request Now by calling the server. handle method and we can pass this request to the uh server handle method so let's just check what happens here and you can see that we validate authenticate and log so it passes through all of the steps no problem and we can return the web page to the user so this is like a successful request so let's actually test what happens if we create create a request with a with an invalid
password okay so if we give it a correct username but the password is incorrect okay so the password needs to be 8123 to pass and then if we call server. handle request two let's see what happens here so let me comment this out just to make it clearer what's going on with this new new request so we can see here that we validate the request no problem and then we authenticate the request but because the password is incorrect the uh chain stops at the authenticating step and it never reaches the log step okay
so that is working perfectly now let's see what happens if we provide an empty username and password so the user hasn't actually provided any credentials as you can see it just goes to the validating step the validating step fails because we have two empty strings and the user is never uh authenticated that we never get to the authenticate uh authentication step in the chain so this is working exactly as we want it to so here we now have a flexible solution that makes it very easy to change the order of processes so as you
can see we can easily change the order of processes in the client we without having to modify any code in the web server class so this is super flexible and easy to change the order of processes and it's also easy to add or remove processes without having to modify any existing code which satisfies the open closed principle the visitor pattern separates the algorithms or behaviors from the objects on which they operate so let's say that you are a developer for a marketing agency that has different types of clients so they
have restaurants law firms and retailers so let's code up a quick solution for this so here I've generated a client class and this is going to be like the sort of parent or base class for each of the different types of clients and you can see here we are storing the name of the client and the contact email of that client so let's go ahead now and create create the uh Law client so we can create a new C class and we're going to call this Law client and this needs to extend the client class okay and then we just need to
generate the Constructor uh Constructor uh to uh satisfy the parent or base client class and you can see here we just pass the name and the email to this client class okay and we can also create a uh a restaurant client and a retailer client so let's go ahead and quickly do that so we have a restorant client and we extend the Base Class generate the Constructor and we can do the same for retailer okay so we now have some very simple uh client classes that all extend this base client class which keeps track
of the name and email of the client so okay so so far everything is just a plain and simple csharp object there's nothing interesting going on so far it's all very very simple straightforward stuff but your manager comes to you and says that they need the ability to send a specialized email with marketing tips for each of the different types of clients for example restaurants need tips on how they can better Market their food but law firms don't so it seems like a good idea to add an abstract method called send email to the base
client class then Implement that method in each of the concrete clients so in the uh client class we can create create an abstract method called send email so let's go ahead and add that in okay and we also need to make this class now abstract okay and now you can see we have errors in each of our uh client classes so we can implement the abstract class here and let's just uh copy and paste this in because it's pretty straightforward stuff so in our law clients we have we are overriding this send email abstract method from clients
and we can just log sending law marketing tips so specialized marketing tips uh to the uh email address of this client okay we can also do the same for restaurant and retail so again I'm just going to copy this in to save a little bit of time because it's very very straightforward just logging uh some basic a basic sentence just to uh simulate sending an email and we need to do the same for our retail client as well so let's implement the abstract class and paste that in okay so this all looks okay so we can now send our
emails uh by using polymorphism so we can see here I'm going to paste this into vs code so what we can do if we go into our program.cs file which is going to be our client we can uh create a list of clients so I just need to import these classes now uh let's see here what do we have going on here and let's see okay these should be uh we need to um add clients onto the end of these class names okay so
basically what we're doing here here is sort of simulating getting a list of clients from a database so let's just pretend this is some sort of database query where we get our list of clients from the database and we have a retail client a restaurant client and a Law client and these are are all of type clients okay so this is a list of clients okay and the reason for that is because all of these classes law restaurant and retail are all extending this base client class okay so back into our program now so now
what we want to do is maybe every week we can schedule to send some sort of marketing email so what we can do is we can Loop through each client and we can actually use polymorphism to send a specialized email okay so our client here needs no knowledge of the actual specific type of client that we're dealing with because the send email method is in the base class which all of these classes are extending uh our our clients can just call this send email class and delegate that to the specific client okay so we're using polymorphism
here we don't need to know the exact client so this appears to be a nice and elegant solution because we're using polymorphism everything looks okay uh but the manager comes back to us and says that they need to uh they need a way to export clients as PDFs and as XML and you quickly realize that your manager is going to keep coming to you and asking you for more and more features for clients so following our current design every time that we want to add new functionality we have to open up our code for modification so we have to
modify our base client class and then actually Implement um any methods uh any specific methods in the client classes um so this is not good because this breaks the open closed principle and we risk breaking uh working tested code and we're also violating the single responsibility Principle as clients are now responsible for storing clients info sending emails and exporting clients as PDFs or XML and also initially the clients were just simple plain old C objects they were very simple objects but adding the
ability to send emails means uh adding thirdparty Library code into these classes that calls email clients like Gmail and Outlook and this can very easily break our previously working code so here is the uml for this current solution we can see that we have our client with name and email fields and then we are adding a a send email method and we have our concrete or our sort of specific client classes such as retail restaurant and law which implements any abstract methods in the client class so to solve the issues that we saw
previously we need to extract the behaviors outside of the client classes on which they operate so if you remember the visitor pattern separates the algorithms or behaviors from the objects on which they operate so so let's implement the visitor pattern so here is the uml where we implement the visitor pattern and we have here an abstract client class and you can see that we've removed the send email method from this class and that will now be in the concrete email visitor class okay so the behaviors have been abstracted into the
concrete visitor classes which uh can then be passed to the objects that they oper operate on like so so here we can see that we are looping through uh our clients and sending an a marketing email so we can see here we call the client. accept method and you can see here that all clients must have an accept method which accepts some sort of visitor and here we have an email visitor which is used to send emails and then within the uh specific uh sort of client classes so for example in retail uh we call visitor
dovisit retail and then that deals with sending a an email specific for uh retail clients okay so we can see before that the send email uh logic was actually on the uh clients themselves whereas now we've separated the the behavior from the objects which they operate on so if we have a look at the gang of fourl here we can see it's pretty similar to what we have up here with a small difference so we can notice that design patterns are not super rigid so for example in our case the element class is an abstract class and not an
interface and this is because we want to provide some common fields and some common methods uh to all of the clients so in our case we have the name and email fields and also the get email method which is common to all clients that's why we're using an abstract class and not an interface where we can't uh sort of store any fields or or actually Implement any methods okay so let's now implement this visitor pattern in code so that it makes more sense first of all I'm going to create a new folder inside of the
visitor folder called good and this is where we're going to put our sort of better solution that follows the visitor pan so first of all let's create uh base client method which will have an accept method that takes a visitor object so let's go ahead and create that and this needs to be an abstract class and here we're going to have the same as before we're going to have uh two Fields one for storing the name of the client and another for storing the email of the client and these are going
to be set within the Constructor of this client class just the same as before and we're also going to have a getter for getting the email of the client okay so this is all similar to what we had before uh but now rather than having a uh abstract send email method we're going to have a an abstract method called accept that um that accepts a a type of visitor okay so let's create that method so this is going to be a public abstract void method called accept and this accepts a visitor object and the visitor object is going
to contain the behavior um that will oper and will operate on a certain uh type of it will operate on a specific client object okay so this is uh hard to understand at the moment so let's keep on going it will make more sense as we uh develop the solution further so next we're going to create our visitor interface and in here we're going to create three methods one called visit retail and this is going to accept a retail client and we don't actually want to import this from the previous solution so let's ignore that for
now okay so let's just um ignore these errors for now they will go away as we actually create these clients and we need one for visit uh law and we also need a method for visiting a restaurant and we need to just rename this to Law client and we need to rename this to restaurant client okay so now we need to create the specific client classes uh so let's go ahead and do that so we'll start with the retail class and this um retail class needs to um extend the client base class and then implement this abstract method which is
the accept method okay so in here what we're actually going to do is we're going to call visitor dot visit retail and I think we also need to implement the con uh generate the Constructor that's it okay so I'm not sure what this problem is here um oh yeah of course we have to pass this object to the retail visitor because the retail visitor is going to operate on this retail client object okay so that is the retail client and now let's go ahead and create the uh restaurant client and this is going to extend
client and we also now again need to implement the abstract methods and also generate the Constructor okay so in this accept uh method we are simply going to call the correct uh method on the visitor and here we are visiting a rest restur client so we need to call visitor dovisit restaurant and then we pass the restaurant that we want to visit which is this object okay so next uh our final uh specific client class is the law clients so let's create the Law client class and again we're going to extend
the client class and we can implement the abstract interface and generate the Constructor and finally we're going to call visitor dovisit law and pass this object okay so this is going to now make more sense because we're going to now create our concrete visitor class for sending uh marketing emails for each specific type of client so let's create the email visitor class and this is going to uh implement the visitor interface okay so and here this is where we implement the specific methods um uh and and we have the
Behavior Uh that is now separated from each of these client uh objects so what we can do is to send an email for law clients we can simply uh log uh sending law marketing tips email to and then we can get the email from the Law client by calling get email so this is pretty nice and if you can remember so let me just try and tie this together a little bit for you now so in the law clients whenever we call the accept method uh we pass the visitor uh which contains the behavior that we want to do so if we want to send an email we can
say law client. accept pass this email visitor and then within this method we are calling visitor. visit law and the visit law method is implemented inside of email visitor and it sends a law marketing tips email to the LW client's uh email address okay so hopefully it's starting to make a little bit more sense for you okay so in here we want to send a restaurant uh marketing tips to email um sorry email to and then we want to concatenate the restaurant client's email and finally for the visit retail I'm
just going to copy and paste this in to save a little bit of time sending retail marketing tips email to retail and this should be retail client. getet email okay so that is the whole solution so let's now use this solution inside of our program.cs file so let's actually use the name space for our good solution and we can see as before we can create our list of clients uh here so we have a retail client a restaurant client and a Law client and we have the name of the clients so deams or Frankie and Benny's
Hamlin Migel for any people that have seen Bal s and we have our email for each client our contact email uh and what we can do now is we can again Loop through each of our clients and now remember that the send email logic is no longer stored on the client objects themselves we've separated the behavior which is send an email in this case from the objects on which they operate which are each of the unique specific client objects so now what we can do is we can say clients do accept and then inside of this accept
method we can pass any type of visitor and in our case we want to pass an email visitor because we want to send an email to each of the clients so we can pass the email visitor and if we now run our program we can see that we are looping through each of the clients and sending them an email uh we send an email uh retail marketing tips email to deams a restaurant marketing tips to Frankin Benny's and a law marketing tips email to Howard uh Miguel Law Firm so this is working perfectly so the let's now take a look
at why this is such a good solution why the visitor pattern is a good solution to this problem so let's say that our manager comes to us asking for new features and uh we can now extend our code and we don't have to modify it beforehand if our uh manager comes to us and say and asks uh if we can add some export as PDF logic then we beforehand we wouldd have to modify the client class or each of the individual client classes we would have to modify our code uh breaking the open close principle whereas now to um
to add a new functionality such as export as PDF functionality we can simply extend our code by creating a new type of visitor so let's go ahead and actually create a new visitor to show you how this works so if we go inside here and create a new class called PDF export visitor and this is going to extend uh sorry implement the visitor interface and now here I'm just going to copy these uh these logs into here to save some time so here we just say that we are exporting a Law client as a PDF and we can just do the same down here this is
going to be a restur client and this is going to be a retail client oops okay so this is our export as PDF uh visitor class and then if we want to export a list of clients as a PDF we can come back into our program class and let's say we want to um send an email and then maybe we want to export as PDF so let's now uh pass this visitor here PDF export visitor and I'm just going to comment this out actually uh so we can see what's going on a little bit easier and we can see we export retail clients
as PDF then the restaurant client and the law clients so this is working perfectly we didn't have to modify any of our existing working code we just extended our code Base by creating a new PDF export visitor and then we can pass that to each of the clients so this is perfect because we are now satisfying the single responsibility principle and the open close principle The Interpreter pattern defines a way to represent and evaluate sentences in a language by using an abstract class for Expressions which concrete subclasses Implement to
interpret specific parts of the language's grammar so The Interpreter pattern is probably the most complex and least used of the gang of for design patterns and most courses on design patterns that I've seen don't actually include this interpreter pattern however at the beginning of this course I promised that I'd teach you all 23 gang of four design patterns so let's give it a go and after the the example that we're going to go through I'll also discuss why this pan is rarely used so
here are some example use cases for The Interpreter pattern so it's used in passing and executing SQL queries where The Interpreter pattern helps to pass the query syntax and execute it against a database it's used in calculators or scientific software that interpret and evaluate complex mathematical formulas entered by users it's also used in web Frameworks that render HTML uh templates with embedded expressions or directives so for example templates in web Frameworks such as laral or Jango and
for example in laral you have the blade templating language where you can sort of write your variables within curly braces it's also uh used in jsx in react and then that is paused by some parer and turned into or interpreted into some sort of HTML template so let's say that we want to build a calculator app that takes some user input string and calculates the result so here we have a user input string so we have 1 + 2 * 3 and an interpreter needs to convert or pass this input or expression into an abstract syntax tree or an expression
tree so you can see here that an expression tree looks something like this it's kind of like a tree of uh tree structure of objects so you can see here 1 + 2 * 3 we can't simply just go from left to right we can't say 1 + 2 and then times three we've got to respect Math's uh rules so the BD Mass rules which mean that we have to perform the multiplication first and then we have to add the one so we have to do 2 * 3 and then add one to that result so 2 * 3 is 6 then we add one to get seven and
that's the result result of this expression so when we build the ab abstract syntax tree um we need to respect bod Mass so we need to get the order of operations correct so you can see here we first of all have an addition expression which contains two more Expressions okay so you can see the first expression we do is the multiplication expression which is the 2 * 3 so we can see here we do 2 * 3 and then finally we add the one onto that result so essentially what we're doing here is we are converting or
passing an input string into a tree of objects according to the grammar rules that we specify and in this case the grammar rules are the sort of maths uh bod Mass rules so the result of the expression that we have here can be found by calling it interpret method so on this expression tree all Expressions will have an interpreted method and we can call this and it will find us the result of this expression which we know is seven so we can essentially use The Interpreter pattern to get from the user input to create this abstract syntax
tree which can then be interpreted or evaluated to get the result so here are the components of The Interpreter pattern so we have abstract Expressions which establish the interface for all Expressions within the L language so the abstract expression is essentially going to be an interface which has an interpret method that all Expressions will Implement so in our case that all the Expressions that we have the concrete expressions are the addition expression the multiplication expression and number expressions and all of these
implement this I expression interface and we'll have an interpret method which defines how these Expressions should be interpreted we then have terminal expressions which represent the fundamental components of a language such as numbers or variables and in this above example number expression is a terminal expression or a leaf that represents integers so you can see here we have number expression where you pass a number of some sort and we can pass either a string or uh an integer in our case and this can be when you call the
interpret method on a number expression object it will just return an integer value directly so in this case if we pass two as a string it will return two as an integer and in this case it will return the integer of three okay so they um can be interpreted directly basically these terminal Expressions we then have non-terminal Expressions which represent more complex Expressions that are composed of other expressions using operators or functions so above the addition expression and the multiplication expression are
non-terminal or composite uh composite Expressions so this means that the non-terminal expressions are built up of sub Expressions so you can see here we have multiplication expression which is built up of uh multiple Expressions it's built up of two number expressions and we can see here the addition expression is also built built up of two expressions we have this multiplication expression and we have this number expression so you can see here if we call the interpretate method on a non-terminal expression then it can't be
directly interpreted because if we look at this multiplication expression it first of all has to interpret this number expression then it has to interpret this number expression so it has a left and a right expression if you will and then it has to multiply these results together and you can see here this addition expression first of all has to evaluate this multiplication expression which has to evaluate these number expressions and then once this is evaluated it has to evaluate this number expression so non-terminal Expressions
can't be directly interpreted like the terminal Expressions uh they essentially have to be recursively interpreted we have to recursively keep on calling uh the sub Expressions interpret method until we finally get to the um results of the terminal expressions and then we also have an interpreter which implements the logic for interpretation and determines how to evaluate different types of Expressions so I'm fully aware right now that you have no idea what is going on so we're going to go through an example
and it will definitely help if you try to code this example out a few times so first of all we're going to create a context class that is going to contain any Global Information needed for interpretation so let's create that context class so in our case for our simple calculator example we don't currently really need this context class but say that we wanted to interpret English language into Spanish and each Spanish-speaking country speaks Spanish slightly differently so this context uh object or
class could contain the country and city that we are currently located in and it could also contain the gender of the person that we are speaking to as that could also affect the interpretation but for now we're just going to leave this as an empty object so next up we need to create the abstract expression interface so we're going to call this I expression and each expression needs to have an interpret method where we pass the context to that method so each expression will have access to any context uh data so next up let's create
uh our first concrete Expressions so first of all we're going to create the terminal expressions and in our case we just need one and that is number expression okay so this needs to implement the expression interface okay so it's going to have an interpret method so in number expression we need to provide an a number when we create a number expression so let's create a number field which is going to be of type integer and then we can create a Constructor so we're going to create a number expression Constructor
which takes in an integer number and we can assign that to our number field and what we'll also do is we'll overload The Constructor so we're actually going to copy and paste this Constructor down and and we can also provide a string number and then what we can do is we can convert this string number so if somebody creates a number expression object and passes a string then we're just going to convert the string into an integer before assigning it to the number field so this just makes this uh
class a little bit more flexible because we can provide both integers and strings okay so finally in our interpret method because this is a terminal expression we can just return the number okay so that's very simply what number expression does okay so next up we can create our non-terminal expression so first of all we will create our addition expression so let's go ahead and create that and this needs to implement the I expression into face okay so if you remember non-terminal expressions are composite
expressions in other words they are built up from multiple sub Expressions so what we need to do here is let's create two fields of type expression and we're going to have a left expression and we're going to have a right expression so in addition for example if we have 1 + 2 then the left expression would be a number expression where we pass one and the right expression would be a number expression where we pass two and then we can interpret both of those expressions and then add them together and that's what
we're going to do in our interpret method but first of all we actually need to create a a Constructor or some way of setting these uh left and right Expressions so let's go ahead and do that and we can assign the fields in the Constructor so next up we need to actually interpret these Expressions so we're just going to say left do interpret and we pass in the context and then we need to add the right expression interpreted so again if these are number Expressions they will just uh interpret to their
integer values and then they will be added together okay so that's what we have there so next up let's create another non-terminal expression which is the subtraction expression so subtraction expression and in here again we're going to have a uh let's see where are we so let's copy and paste these two fields in I'm also going to copy in what we have from addition expression and we're just going to modify things a little bit so this needs to be um subtraction expression so the Constructor we set the
left left and right expressions and then in interpret rather than adding them together we are subtracting them okay so finally we're going to create a multiplication expression so again this is going to be very similar to what we have in the addition and subtraction okay so again we're going to have two fields and we're going to set those expressions inside of the Constructor so let's see let's copy and paste that in change the name of the Constructor and this needs to also imple in fact we forgot to implement the uh
expression interface here so let's Implement that in the subtraction expression and we also need to implement it here in the uh multiplication expression and then implement the interface and then here we're just going to return the left expression and and then we're going to interpret it pass the context and then we're going to multiply by the right expression okay so that's everything that we need for our Expressions so next we need to create The Interpreter or the parer class which needs to convert some
input string for example 1 + 2 * 3 and it needs to convert that into an abstract syntax tree or an expression tree and first of all so let's go ahead ah head first of all and create this interpreter class so The Interpreter is going to hold a reference to the context okay and it's also going to have an interpret method which interprets the expression or builds the uh expression tree so let's create that method and it's going to return an integer in other words the sort of final result from uh passing the expression so
this needs to take a string an input string or some expression string you can call that whatever you want and what we're going to do is we're going to build an expression tree so we're going to create a separate method for building the expression tree so we're going to call this build expression tree and in here we're going to pass the expression that we want to build an expression tree from and then finally we're just going to return the expression tree and we're going to call the
interpret method on that tree and pass in the context Okay so that's going to return an integer value so let's now create this build expression tree um method which is going to return a expression and it's going to take some input I'm going to call it input you can call it expression whatever you want so this is where things get a bit more interesting because building a parer that converts some input strings such as 1 plus 2 * 3 is actually pretty complex because we can't just sort of Traverse this from left to right we have
to perform this 2 * three first and then add the one so building passes are complex which I'm going to show you very shortly and it's very easy to get them wrong so for Simplicity we're just going to skip this building an actual parer for now and we're just going to hardcode in the expression tree for the input 1 plus uh plus 2 + 3 and of course in the real world you would need to build an actual proper parser or download one from somewhere from some package so let's actually uh hard code in a few
things here so we're going to say the input is always going to be 1 + 2 * 3 and we're then going to hard code our expression tree so we'll say expression tree is equal to and what we're going to do is we're going to build an expression tree for this particular input example so first of all we have to do uh the addition expression and inside of here we need to first of all do the multiplication expression which is 2 * 3 so we do a new multiplication expression and in here we can pass in the number
expressions of two and three and we can pass two in here or it can be a string and we do new number expression three okay and then we also need to then add this one so we do new number expression and we say one okay then from here we can return this expression tree okay which is going to be interpreted in this interpret method okay so now let's have a look at how a client would use this solution okay so let's say that we have an input string of 1 + 2 * 3 and in this case it doesn't actually matter what our input
string is because we've hardcoded the result in here we've hardcoded the input and we've hardcoded the result of this uh input example uh I am going to show you how to build well I'm going to show you what an actual parser for this would look like and how it would build this expression tree from this input but for now let's just hard code things in for Simplicity and for a little bit of Sanity so we can then create our context object and we can create our interpreter and we pass in our context
object okay so let's actually get um the result from interpreting this input so we can say interpreter do interpret and we can pass our expression our input expression and we can assign this to a result uh variable and that's let's actually log this result to the console okay so let's log this we should get seven back because 2 * 3 is 6 + 1 is seven so let's see what we get and we will get result equals 7 okay so that is all looking good so far next up I'm going to show you what an actual interpreter class would look
like if we needed if we we actually passed the input string correctly uh programmatically so let me now show you what an interpreter class would look like if it actually passed the input string into an expression tree and for Simplicity and a little bit of my own sanity The Interpreter only handles addition and subtraction as handling multiplication division and brackets in an expression would require quite a bit more complexity for example 1 + 3 plus uh sorry 1 + 3 * 4 requires the 3 * 4 to be executed before adding the one due to
Bod Mass so creating language or grammar parsers is actually very very difficult to get right even for this simple parer that I'm going to show you now it only actually handles uh addition and subtraction I've not actually handled multiplication and division and it's still fairly complex it still takes quite a bit of thought to build out and it's very easy to get wrong so what I'm actually done here is I've already built out this second interpreter which actually passes the input string and
it's exactly the same as The Interpreter that we built before up until this build expression tree method where we're actually now we actually now have an algorithm to pause the input okay so we can see here this only handles addition and subtraction so first of all what we do is we split the string into a list of tokens or an array of tokens so you can think of tokens as like the words in a sentence or in our case the the tokens will be the operands and The Operators so the operands are these numbers and The Operators are like the
addition and subtraction signs okay so we build up a list of tokens by splitting the string via the spaces we then create an output queue and uh an operator stack and this is pretty complex and Way beond Beyond the scope of this course to actually go through what is going on here uh this is a course on design patterns not on algorithms but essentially what we're doing is we're using an algorithm called the shunting yard algorithm to um change the sort of format of our expression so that we can build an expression tree and
you can see here depending on the token we are creating new expressions of certain types so here if it's a plus uh sign then we create we sort of add to the stack and addition expression and we add the left and right Expressions that we need to add okay so it's pretty complex and I don't want to go through all of this and it's Way Beyond the scope of this course but I just wanted to show you that even for just having a parer that handles addition and subtraction it's actually very complicated and if we if we wanted to
actually account for uh multiplication and division and brackets then it would be even more complex so I just wanted to show you basically that building passes is extremely difficult to get right and yeah it's something that you're not going to be doing too often in your life as a software developer at least most of you won't be doing that anyway so let's actually use this in the client now so we're going to change the input we can't do multiplication this one so we're just going to do uh let's see 2 +
3 uh and then we'll minus 4 and we will add 10 so this should give us a result of five one so it should be 11 okay that's what we are expecting and we're now going to use interpreter 2 instead of interpreter one okay so that should all be okay so let's run this and we should get 11 and as you can see we get 11 so that's all working correctly so what is actually going on here so let's sum up what we have so far so that we can better understand what is going on here so first of all we have
the client our sort of program.cs file which initiates the interpretation process by providing first of all an input expression to interpret and it also creates The Interpreter object and the context object with information that is needed for the interpretation process is passed to The Interpreter and in our case we are not providing any context data okay so next of all the passing and building of the abstract syntax tree so the input expression is turned into an array of tokens in The Interpreter so if we go up here we can see we are turning
the input into an array of tokens and tokens are analogous to words in a sentence and these are passed via some algorithm so we have our big algorithm here um that creates an expression tree that res represents the input and if we go into our first interpreter the expression tree will look something like this it builds an expression tree that sort of represents our input okay so each operator and operand so the operators being like the multiplication symbol or the addition symbol and the operands being the numbers themselves are each represented
by a corresponding expression object so the numbers are represented by the addition expression and the operands are um represented by the multiplication expression or the subtraction expression or the addition expression okay and they're they're basically built of sub Expressions okay so let's now have a look and have a think through the expression evaluation so we've built our expression tree from our user input now we need to interpret this uh expression tree okay so the ex The Interpreter so if we
go into this interpret method we first of all create the expression tree then we have to interpret it and The Interpreter traverses the expression tree and in interprets each individual expression or node as it goes so for terminal Expressions the operands or numbers such as 1 two and three that interpret methods directly return their numeric values so if we have a look in the number expression you can see uh sorry number expression is just returning the numeric value and for the terminal Expressions The Operators such
as plus minus and multiply their interpret methods call their left and right sub expressions and then it it calls these left and right sub Expressions recursively and then performs their respective oper operations so either add uh subtract or multiply and what we mean by recursive if we just have a look in here you can see that um we first of all have to call this addition expression we call interpret on this and then from in here we call interpret on this multiplication expression and then we have to interpret this left expression
then the right expression then we multiply them together and then we have to interpret this number expression and then we finally add them together so we're recursively calling the interpret method on each of these expressions as we Traverse the expression tree okay so then we need to combine the interpreted results so The Interpreter combines the results of the sub Expressions according to the defined grammar rules that should be represented by the expression tree and in our example following bod Mass 2 * 3 should
be performed or evaluated first and then followed we then follow uh we then add on the uh the one so that the final output is then returned to the client so here is the gang of 4L for The Interpreter pattern so you can see here we have our abstract expression interface with an interpret method that takes the context object which contains some sort of data that is relevant to the in interpretation and then we have our two groups of Expressions we have terminal Expressions which basically kind of return the building blocks or
these kind of fundamental um sort of words or digits in our language so in our case that was just integers and then we have our non-terminal Expressions which are built up of sub Expressions okay so let's now have a look at some commonly stated justifications for when to and when not to use The Interpreter pattern so if you need to interpret and execute expressions or commands in a domain specific language The Interpreter patent offers a flexible and extensible method for implementing the languages grammar
and semantics if your task only involves calculating simple operations that can be handled by general purpose programming languages or by a library then using The Interpreter pan adds a lot of unnecessary complexity so most of the time a general purpose programming language or Library will do the job for you and if the grammar of your language is too com is complex then The Interpreter pattern could lead to having a large number of classes and increased code complexity and in this case a dedicated parser generator or compiler would be a
better option so now we're going to take a look at why The Interpreter pattern is rarely used so Steve yay a software developer and blogger says that the ganga 4 book contains 22 patterns and a practical joke and The Interpreter pattern is that practical joke so the problem with The Interpreter pattern is that you must turn your language into an abstract syntax tree and as you saw earlier with our calculator example creating a parser or an algorithm for converting some input into an abstract syntax tree is a very difficult task to
get right and is very timec consuming and for anything other than the simplest of languages creating a parser is very difficult and likely to fail so how did the gang of four book deal with this they basically ignored the paring problem alog together and said that it was a separate problem to The Interpreter pattern so I've actually copied and pasted a paragraph from the ganga for book about what they say about this kind of problem so The Interpreter pattern doesn't explain how to create an abstract syntax Tree in other words it
doesn't address passing the abstract syntax tree can be created by a TBL driven parer by a handcrafted usually recursive descent parer or directly by the client but when we use The Interpreter pattern we have to somehow generate this abstract syntax tree we can't just ignore the complex problem of paing and this is why yay characterized the chapter as a practical joke and why other programming techniques and patterns are almost always preferred to The Interpreter Pat and in your life as a software developer most of you will
rarely have to develop your own languages so the other 22 design patterns will be of much greater use to you however there will of course be some specific good use cases for this pattern in the real world okay so that's enough of this pattern we're now going to move on to structural design patterns structural design patterns focus on the composition of classes and objects to form larger structures and systems these patterns primarily deal with how classes and objects can be combined to form larger more complex
structures while keeping these structures flexible and efficient the key objective of structural design patterns is to provide solutions to design problems related to object composition and structure allowing for better organization and management of code so structural design patterns help to achieve several important goals in software development they promote code reuse ability and modularity by defining clear and standardized ways to compose and organize classes and objects and this makes the codebase more
maintainable and scalable over time as changes or additions to the system can be made more easily they enhance flexibility and extensibility by allowing the system structure to evolve without requiring major changes to existing code and this is achieved by decoupling the components of the system and promoting loose coupling between the different parts uh and structural design patterns also improve performance and resource utilization by optimizing the way objects interact and collaborate within the system thereby enhancing
overall system efficiency so overall these patterns contribute to building robust adaptable and well organized software systems that are easier to understand maintain and extend over time so let's now learn some structural design patterns the composite design pattern is a structural design pattern that enables the creation of tree likee structures to represent collections of objects where both individual objects and groups of objects are treated in a unified manner so to understand what this means let's
create a scenario then code up a simple naive solution then fix it with the composite pattern so let's say that we get an Amazon delivery of a large package that contains multiple items so as you can see the boxes can contain groups of other boxes and items and the above this diagram shows how a package of items can be represented as a tree structure so at the top we have the the big main Amazon box that you would receive and then within this box we have two more smaller boxes and then within the smaller box we have a microphone so
our first item that we open and then the second box contains two smaller boxes and this box contains a mouse and this box contains a keyboard okay and you can see that this is represented as a sort of tree structure uh so say that we need to find the total price of the items within any package so for example the total price of all the items in this top uh main package would be the cost of the microphone plus the mouse plus the keyboard where the price of the items within this uh package would be just the mouse or the keyboard and the total
price within here would be the keyboard the total price of this package is the mouse okay so the solution that naturally pops into the head is to create an array of boxes and items then Loop through them recursively to find the total price of the package so here is The Simple Solution so we can see here that we've created a keyboard cloud class with a price a microphone class with a price and a mouse class with a price we can then have a box which is just a list of any type of object and we call this items and within this box class we have
a method for adding an item and we just add it to the list of items and then we have a calculate total price class which um first of all has a field called total price which we set to zero it Loops through all of the items in the items list and it checks what type of object the item is so if item is a keyboard then we cast the item to a keyboard uh object uh which means that we can then access its price uh field okay then we have have to do the same for Mouse we cast it to a mouse and access the price field on the mouse class add it to total
price and then we do the same for microphone else if the item is a box then we cast the item to a box and call calculate total price so we're calling this uh method recursively then we just return the total price of the uh box so you can see that this method is ugly because we're having to check the type of object and then cast the object to that type to be able to access its price field so this is very uh very ugly solution first of all it's very hard to read this method is going to already bloated with just three types of items
so the more items we add it's going to become even more bloated and if we add more items or remove items then we have to modify this class breaking the open closed principle so if we use this solution to create the package demonstrated in the uh previous tree diagram we can see here that we first of all create the uh big package to deliver containing box one and box two and then box one contains a microphone box two contains box three and four uh and then box three contains a mouse box four contains a keyboard and
then we're just adding the boxes to the correct box and adding the packages to the correct boxes and then we can call calculate total price so you can see that this solution calculates total price correctly but it has some obvious flaws that we have already discussed so we have lots of conditionals which is very hard to read and we're violating the open close principle because whenever we add a new item we have to modify the Box class whenever we have lots of conditionals that are checking the type of an object and and casting it to
another object type it's often a good sign that we need to use polymorphism and we can use polymorphism by treat uh by creating an interface called item and extracting common methods or logic between the objects into that interface like so so here we have an item inter interface with a G price method and we can see that both box and each of the product uh objects or classes are EXT extending this item interface meaning that they will all have this Gap price method so a box is essentially composed of a group of items so you can see here
this is represented by the diamond arrow and you can see this field here a box is composed of a group of items uh but a box is also an item itself represented by the arrow so a box is simply just a group of items uh a box and its contents can be treated the same way as items thanks to polymorphism so now let's go ahead and create the code solution okay so I've created a new folder for our structural design patterns and in here I've created a composite folder for this example so first of all let's create an
interface called item and items are going to have a single method uh called Gap price which returns a float and we can now create our specific item classes so first of all let's create a keyboard class and this needs to implement the item interface so each class will need to have a field to store for its price so let's go ahead and create a private float called price and I'm just going to set this uh for now as a constant in a uh real application it would be much more sensible to uh create a Setter method
for this or uh set the price in the Constructor but for now we're just going to hardcode a value in for the price and then within this Gap price method we need to return the price okay so let's now create go ahead and create our other items so we're going to need to create a microphone and this needs to extend or implement the item interface and again we're going to have a private float for the price and again let's just hard code this in for now and we just return the price okay let's create our Mouse
class and I'm actually just going to copy and paste this in to save some time as it follows the exact same structure as we have with our keyboard and microphone okay so now let's create our box class and a box remember is just a a sort of um class that stores a group of items and a box is also an item itself so let's implement the item interface and now box needs to actually have a field for storing a list of items okay let's also provide a method uh for adding items to the list okay now we need to implement the
Gap price method so what we're going to do is we're going to Loop through the items in this items list and we're going to add it to a total variable so let's create a float called total and then we're going to Loop through each item in the items list and we're just going to add it to the total and here we can call item.
 get price okay and we know that each item is going to uh have a gap price method because all items are implementing this item in uh interface so we no longer need to check the type of item object we can just treat them all as items and we here we basically using polymorphism because this item um this item object can take many forms it can be a keyboard it can be a microphone or it can be just another box okay so polymorphism is allowing us to uh giving us a lot of flexibility here and then at the end we just need to return this
total so let's now actually uh use this solution in a in our program.cs file and what I'm going to do is rather than code all of this out it's a pretty uh Hefty bit of code so we're just creating the uh tree structure that we had beforehand basically so what I'm going to do is just copy and paste this all in and then let's actually import the correct name space so it is this one okay so this all looks okay so just to remind you of the tree structure that we are creating here um let's see if I
go over here so if I just scroll up so we're essentially creating this tree structure so we have one big package that contains two boxes then box one contains a microphone box two contains two more uh boxes and then we have a mouse and a keyboard okay so that is what we have there and let's see so let me go back over here okay so let's run this file to see what we get and I think actually we've messed up the copy and paste in here so let me just re copy and paste this in okay so that should hopefully be
correct and the total price of the package is $87.99 so if we quickly check what we have in the packages we have a keyboard a mouse and a microphone so we have 40+ 29 which is $ 69.99 and then we have a mouse so that's $87.99 so the total price of the package has been calculated correctly okay perfect so you can see that there has been no change in the way that the client would actually use this solution compared to what we had beforehand uh the biggest change in uh using this uh solution is that it calculates the price
um is in the way it calculates the price using the Gap price methods uh because we can now treat all objects in the Box uh in the same way as they all implement the item interface and this means that we don't need uh conditionals to check the type of each item and this satisfies the open close Principle as our code is open for extension but closed for modification so we can create a new item class uh extending our code without needing to open any existing classes for modification so here is the gang of fourl for the composite pattern so you
can see that we have our component interface at the top and then we have our composite class so a composite meaning that it contains uh sort of multiple components so you can see here that a a composite has uh some children or it contains uh some other components so it has a list of components and then it has a method for adding components to the list and it also has an execute method to execute some sort of logic and then we have uh our leaves which are are the sort of individual products themselves okay so the composite patter
is useful for representing tree structures for example folders and files uh and we can see here that a folder is like a composite it contains either other folders or individual files and you can see here this folder contains two files as well as another folder which contains three files and the composite pattern is very useful for representing these kind of tree structures and another example is a graphical editor that allows you to group shapes together and group groups of shapes together as well so when you
drag a group all shapes should move together in the same way so you can see here we have a group which contains a circle triangle and another group and this group contains two groups and this group contains two squares and this group contains two circles okay so you can see that this can be represented as a tree structure and this is where you might start thinking that the composite pattern could be a good way to uh represent this in code the adapter pattern is a structural design pattern that allows incompatible
interfaces between classes to work together by providing a wrapper that translates one interface into another so let's create a scenario that will help you to understand this pattern and the pattern use cases so say that we have a video editing application that allows users to upload a video and change the color of the video the application provides preset color options for the user to select such as black and white or midnight purple so as you can see here we have the original video with color it then goes through some sort of
black and white algorithm and we finally get the edited video uh with all of its color removed in this case uh the video is made made black and white so the classes that change the color of the application are built by us they are sort of our own uh part of our own code base our own custom code and these classes Implement a color interface so some sort of common interface so that we can use polymorphism to treat these classes in uh in the sort of same way so here's how the application looks so we just have a sort of BAS
uh basic video class here we have no uh methods and Fields but let's just pretend this class uh represents some sort of video we then have a color interface which has an apply method and each apply methods takes a video class and this is the video that we are going to work on so we're going to apply a color to this video so we then have our sort of con rete color classes so here we have a public class called black and white color which implements the color interface and therefore has an apply method which accepts a video to apply
this black and white color too and in a real application this would be some complex code to apply a a black and white color to a video but here we're just log in applying black and white color to the video we also can have other color uh color classes of course so here we have a midnight color which implements color and has an apply method uh which takes a video that we can apply the color to we then have our video editor class which take which has a video field and we pass a video to this video editor via
the uh Constructor and we then have a method called apply Color which takes some sort of color object and then calls color. apply and passes the video that we want to apply the color to okay so using this solution in a client we first create a video editor by calling new video editor we pass the video editor a video that we want to edit and we then call video editor.
 apply Color and we can pass any color object that we want to apply to the video so in this case we are applying black and white color to the video so this is all looking good so far uh but we then decide to install a thirdparty library into our into our application that allows users to apply more types of colors to their videos so more complex uh color options uh to the videos so the problem is that all of the concrete color classes are expected to implement our custom color interface and have an apply method but the concrete color classes from the installed Library
don't uh implement this color interface meaning that we can't pass them to our video editor. apply Color method like this so you can see here that this rainbow class is a color class from the installed third party library and we don't have access to this code and you can see here we can't just pass it to this apply Color method because this is expecting an object which implements our color interface and of course this third party class doesn't Implement our third our Uh custom color interface so as mentioned we cannot
modify the thirdparty library code to make the color classes Implement our color interface so how do we solve this so we can solve this by converting the interface of the thirdparty color classes to a different form using the adapter pattern so so far we can't use this third party rainbow class because it doesn't Implement our color interface and we can't make it Implement color because it's inside of a thirdparty package so here's the sort of situation drawn out in your uml where we have a
video editor with an apply app color method where we can apply some sort of color uh so any color that implements this color interface and we have our own sort of custom color classes such as midnight purple and black and white which implement this color interface we then have our sort of third party uh uh color classes such as rainbow and these have some sort of update method which um needs to receive a video however we can't uh pass these to the apply Color method because they don't Implement our color interface so let's
take a look at how we can solve this issue so we can create a rainbow color class that implements color and is composed of the third party rainbow class we can then call the apply method in rainbow color and inside the apply method call whatever methods that we need to call from Rainbow to apply the filter so we essentially adapt the class to a different form so let's explain that again so here we have our video editor so again we just as before nothing different here we apply a color and pass it some sort of color so any
object that implements this color interface and this color interface has an apply method which accepts a video so now this is the new class that we've created we've created this rainbow color class this is our own custom class which um implements color has of course an apply method which takes a video and then within the apply method we can actually call the Rainbow class or the rainbow object do update and then pass the video and this rainbow color class that we've created is composed of so it has a field of type rainbow
so essentially we've adapted this third party rainbow class into a different form we've adapted it into a a color um object okay so rainbow color uh this class that we've created is the adapter it's converting the interface of the rainbow class so the adapter into a different form and that form is color so let's now implement M this in code okay so just a quick reminder of what we have so far so we have a video class um which is just a class that represents some sort of video we then have a color interface which describes
what a color class or a concrete color class should look like and me and all colors should have an apply method that accept a video object we then have our concrete color classes such as black and white color which implement the color interface have an apply method that takes a video then the uh apply method applies the color to the Past video and midnight color is also a uh concrete color uh similar to black and white color that implements the color interface we then have our video editor class which has a field which stores a
video to edit with pass the video via the Constructor and we have a method called apply Color where we can pass a color that we want to apply to the video so that's what we have so far so let's now um create the video class um from the third party Library so I'm just going to create um let's actually create a folder so this is kind of uh going to represent a third party Library so I'm just going to call this package and in here I'm going to create a uh rainbow class okay so let's say that um let's
say that colors from this third party Library require some sort of setup so we have to call a setup method before we can actually use the color okay and uh maybe this would be uh some sort of method that we could pass some configuration options such as I don't know the brightness of the color or I don't know anything like related to um uh the color of a video but we're just going to leave this as a simple method called setup and I'm just going to log setting up rainbow filter okay and then I'm also going to
create a method called update and this is going to be basically the a similar s of um method to our apply method so we're currently calling the method apply the third party library is going to call the method update okay and this takes a video and it applies the uh the color to the video so I'm just going to say applying uh rainbow uh filter to video okay so this sort of represents uh what our third party rainbow color class looks like and currently we can't use this because it doesn't implement the
color interface so what we can now do is we can create an adapter class that adapts this rainbow class to use our color interface so that it can be used by our video editor class without having to modify this source code okay so let's create a rainbow color class and the rainbow color class is one of our our own classes it's not part of this sort of installed package so inside of the adapter folder we're going to create a class called rainbow color and this is going to implement our color interface and if you're a member from
the uml we need to uh store uh a or uh store a field of type rainbow and this is composition so rainbow color is composed of or has a rainbow object so let's also create a Constructor and we can pass the rainbow object in here okay and then in our our apply method we can actually um uh interact with our sort of third party rainbow uh object now so we can call Rainbow do setup so this is something that the third party Library requires us to do so we call setup and then once we've set up the uh rainbow uh object we can call the
update method and pass the video so now we have a rainbow color class which implements color that we can uh now pass to our our video editor uh apply Color method and use this uh rainbow color now as we would any other of our color classes so uh we can now apply rainbow color to our videos just like the other colors so let's now go into our program.
cs file and let's see if we can apply a rainbow color so let's call this rainbow color and inside of rainbow color we need to pass the uh rainbow um uh object so let's see and this is part of the third party package so there we go so now we can apply our rainbow color just like we would our um just like we would our um custom colors so you can see here that rainbow color is a wrapper that translates one interface into another so now to use any other color from this third party Library we can create a new rapper or adapter class
to make it compatible with video editor satisfying the open closed principle so we actually created our adapter via composition so you can see here our rainbow color adapter class is composed of a rainbow object and this is our third party color that we have adapted into an object of type color so um we can also use uh inheritance to create our adapter classes so let me show you how we can use inheritance instead of composition to create an adapter class so let's create a new class called rainbow adapter
and what we're going to do here is we're going to inherit from the third party rainbow class and we're also going to implement the color interface so let's Implement that by pressing uh command and Dot and implement the interface uh so what we can do here is let's just have a look what we did before so we can see here because rainbow color our sort of previous rainbow adapter is composed of rainbow we have to call the methods on this rainbow object that we passed into rainbow color whereas here we can call
the methods directly because they've been inherited uh by the rainbow class because you can see here this third party rainbow class has a setup method and an update method and we are inheriting them so we can just call them Direct L like this okay so this does exactly the same as what our rainbow color adapter uh did so these do these adapters both do the same thing but one's using inheritance and one is using composition so with inheritance the rainbow methods can be called directly now the problem with this inheritance
approach is that it's not as flexible as using composition because in C A Class can only extend one class and in this case the rainbow adapter is extending this rainbow class and in this case this is okay it's okay to use inheritance here because uh color is an interface but you can see that inheritance is less flexible than composition uh and therefore uh composition should be preferred and that is because um if color wasn't an interface and and it was some sort of class that we'd need to extend then you
can see that c would give us an error because this rainbow adapter would then need to extend two classes which is not allowed in C so as you can see composition gives us more flexibility than inheritance and therefore should be prefer the preferred option the bridge pattern is is a design pattern that separates a large class or a set of related classes into two separate hierarchies so that they can be developed independently from each other so say that we have a remote for controlling radios and there are multiple different brands of radio and
there are multiple different types of remotes so in this diagram we have an abstract class for what a remote should look like and then uh extending remote or inheriting from remote is is the LG remote and the Sony remote and LG and Sony are different brands of radium and then we have another different type of remote called Advanced remote which extends or inherits from this remote class and underneath here we can see that we have an advanced LG remote and an advanced Sony remote we then have another different type of remote called
a mega remote which will have uh some additional function functionality that extends from remote and then we can see that we have the brands LG and Sony for um the mega remote so here we can see that every time that we add a new brand for example Samsung we'd have to create three new classes so we'd have to create Samsung remote Advanced Samsung remote and mega Samsung remote and if we create a new type of remote for example radio and TV remote for controlling both a radio and the TV then we'd have to
create a new class for every uh brand of radio so we'd need to create a radio and TV LG radio and TV Sony and radio and TV Samsung so you can uh very easily see that this is not a maintainable solution so let's have a look at how this looks in code we have our base remote control class which is an abstract class with four methods for controlling a radio so we have a method for turning the radio on turning it off uh for turning the volume up and turning the volume down so let's now create our Advanced remote
abstract class and this is going to extend the remote control class and as you can see we're getting an error here uh because it's not implementing the inherited abstract methods from remote remote control but we can solve that by making this an abstract class and now we're just going to add a an extra method called set channel which takes an integer of the channel number that we want to set the radio to okay so this is now our Advanced remote with one extra bit of functionality uh let's now create our uh
radio and TV remote so this is another type of remote control that can control control both a radio and TV so let's call this um let's see yeah sorry radio and TV remote okay and this needs to again extend or inherit from remote control and this needs to be an abstract class okay so then what we're going to do is we're going to add a couple of extra methods uh in here and we're going to have a control TV and a control radio method so we can select which device we want to control so if we uh call this
method we're controlling the TV if we call the control radio method then we will control the radio so now what we're going to do is we're going to implement these remote control types uh for LG devices so the LG brand okay so we're not going to implement them for all of the brand types because that will take way too long so for brevity we will just Implement these remotes for LG devices for now and not worry about uh Sony or Samsung so what we will do is we will create the basic LG remote and this needs to inherit from remote
control we then need to implement this abstract class with all of these methods and to save a little bit of time I'm just going to copy and paste these in for now to save some time so let's see okay so I'm just logging the um some different stuff here so if we call turn on we just say turning ALG radio off and we also need to add the volume up uh method okay so we're now implementing all of the abstract methods from remote control so now let's create our Advanced LG remote and this is going to
uh inherit or extend the advanced L um Advanced remote class and then again I'm just going to copy and paste to save us some time here because it's all very basic stuff we just need to implement all of the methods from Advanced remote control so it's all the same as the regular ALG uh remote but we also have this additional set channel method and finally let's create the alga radio and TV remote so let's create that and this needs to inherit from radio and TV remote and we can then implement the
methods so we have control radio and we have all of the methods that we had before okay so we just have an additional two methods here for controlling the radio or controlling the TV okay then we can use this solution in a client so if we go to our program.cs file and let's empty this out so first of all let's create a LG remote and let's just uh turn the uh radio on and then turn the radio off okay that's all working correctly and
then if we create an ALG radio and TV remote okay so this needs to be ALG radio and TV remote and then we can control the TV and turn it on and then turn the volume up okay so we control the TV now controlling lgtv we turn the um TV on and then we turn the volume up so let's check that all check that that is working correctly okay so that's solution is all working correctly however this solution is very inflexible because every time we add a new remote type we need to create a new class for every brand of TV and
every time we add a new brand we need to create a new class for every remote type and the reason that we ended up with this structure is because our hierarchy is growing in two Dimensions so we have the abstract Dimension or the remote type and an implementation Dimension which is the brand of the device so we saw before that we have a structure that is growing in two Dimensions both the remote type and the brand Dimension so to simplify this hierarchy we can break it down into two separate hierarchies so here we have a
sort of remote type hierarchy on the left and on the right we have a sort of device or brand hierarchy so you can see that these uh two hierarchies are connected via a bridge so you can see here that remote control is actually composed of a uh some sort of device and it talks to each device via the device interface so you can see here the remote control has a turn on method and within this turn on method it just calls the device.
 turnon so it uses polymorphism to turn on the device and it doesn't require any knowledge of the specific device that it is turning on because it's coded to this device interface okay so whenever we have an hierarchy growing in two separate Dimensions we need to split them in half and connect to them using a bridge so that the two hierarchies can then grow independently from each other uh meaning that we don't have to create a subass for every combined remote type and brand so let's now implement this solution in code so that it makes more sense okay so
first of all we're going to create our device interface and this is going to contain uh three methods we're going to have turn on turn off and set channel and the device interface uh defines all of the methods that a device should have and currently we're just going to have these three methods we're not going to worry about any other method such as turning the volume up or turning the volume down we're just going to keep it simple for now so next up we're going to create our remote control class this is like our
base remote control class and remote control needs to be composed of a device so we're going to say private device device and then we're going to pass a device into this remote control Class via the Constructor okay so now we can Define what a basic remote control should do so a basic remote control uh just like beforehand if we go into our remote control on before uh um a base remote control can turn a radio on or it can turn a radio off uh we're not going to worry about volume up and down for now
just to uh keep things a little bit more simple and short so let's um create uh first of all the turn on method and in here we can just call device. turn on because we know that all devices will have a turn on method uh we can then create a turnoff method and simply call device. turnoff okay so this doesn't matter what the brand of device is whether it's LG Sony or Samsung because it's coded to this device interface uh we can just simply call these methods on the device without checking what the brand of um
devices okay so we're using polymorphism here which makes our solution nice and flexible okay so let's just leave it as that for now keep things simple so let's now also create our Advanced remote control class uh let's see and this needs to inherit from our base remote control and uh this should be uh we need to generate the Constructor and pass the device up to our base remote control class okay so the advanced remote is going to do everything that a remote control uh can do so it's going to
inherit our turn on and turnoff methods but an advanced remote can also set the channel so let's add a set channel method okay so you can see that an advanced remote can do everything a remote control can do but it can also set a channel um uh by passing an in integer of the channel number okay so let's now go ahead and create our uh device um our devices our sort of concrete devices so first of all we're going to create an LG radio device so we're going to call this LG radio and this is going to implement the device
interface so let's inter Implement all of those methods and you can see here that in LG radio we need to implement all methods from device and it doesn't matter we're not actually worrying about whether this is going to be an advanced uh device or a regular base sort sort of remote uh the remote type isn't is no longer related to the device we control the sort of limitations of what we can do Within These remote control classes so in remote control we can uh specify that if we have a remote control we can only
turn on or turn off the device whereas if you have an advanced remote control you can turn on turn off and also set the channel uh and Within These LG Within These concrete device classes we just Implement all of the methods possible for any different type of remote so now what I'm going to do is I'm just going to copy and paste these methods in to save some time because all we're doing is well we're doing exactly as what uh uh as what we did previously so we're just logging a few things out
when we call these methods so let's also create a Sony radio now so phy radio device and again this is going to implement device and I'm just going to copy and paste these in to save some time okay so you can see that Sony devices can be turned off on turned off and we can also set the channel okay so now let's have a look at how a client would use this solution so you can see previously if we wanted to uh control an LG radio uh with and with a radio radio and TV remote we had to create this very specific uh subass uh so this solution
is going to be a lot different so let's actually create an LG remote control in fact let me just comment this out so you can see the sort of differences a little bit more clearly so first let's create an LG remote control and this should be a structural dot bridge. good okay so a remote control you need to uh pass the device uh that we want to control so the brand of device that we want to control is an alga radio so we're going to pass an algae radio into here and now if we call alga remote control dot turn
on and we can also turn the device off so let's actually run this program and you can see that that works correctly so now we can see that we have two separate hierarchy is we have the remote type which is separate from the brand or device type okay whereas beforehand we were sort of combining them into subclasses here we have an LG sort of radio and TV remote so radio and T TV remote is the remote type and LG is the brand whereas now we are uh creating a new remote control object so the remote type we specify here and then we
pass the device that we want to control Okay so we've separated the two hierarchies and we've connected them using this bridge this device Bridge Okay so let's also now have a look at how we could create an advanced uh Sony remote control so uh let's do that so here we specify Advanced remote we're not saying Sony Advanced remote and then to make uh this an advanced Sony remote we just pass uh the Sony radio device or the sort of brand that we want to control and then we can pretty much do what we did
before so we can turn on we can turn off and we can also let's see set the channel to some channel uh number so if we run this we can see that that is all working correctly so now as remote control uh our remote control class is now delegating okay you can see here it's delegating the work to the device via the bridge and uh and the bridge is is is using is basically composition so the device hierarchy and the remote type hierarchy can now grow independently from each other so now if we add a new brand of radio we only need to create
one new class so our code is now more flexible and easier to maintain the proxy pattern is a structural design pattern that provides a proxy or agent object to control access to another object allowing for a add functionality such as caching logging lazy loading or access control without changing the client's code so you can see here we have some sort of client object which is trying to reach a Target object but it has to go through this proxy object before getting to the Target so you can see that this proxy is like a sort of in
between object so let's say that we have an application that fetches a list of YouTube videos from YouTube's API and displays those videos in a list in our application we are using a thirdparty YouTube package to handle fetching the YouTube videos from the YouTube API and then we render the video on the screen with the video controls so the problem is that every time a request is made to our application our server has to redownload the videos from the YouTube API and this takes a long time especially if lots of requests are made
to our application at one time so here is the interface for what a video object would look like from our third party video library from YouTube so this is an interface called video and we have a render method as well as a get video ID which Returns the string ID of the video and we also have in this third party package a YouTube video class which is is a class again from the third party YouTube Library which um essentially creates YouTube video objects by fetching the video from the YouTube API via its video ID uh so in the
Constructor you can see here that we pass the video ID that we want to fetch from the YouTube API and then the video starts to download So as you can see whenever we create a new YouTube video object it downloads the whole video as you can see here we just log downloading video with ID video ID from the YouTube API and then we also have a render method for rendering the video onto the uh UI and we also have a method for getting the video ID okay so that is basically the uh sort of third party package that we would be dealing with
for YouTube uh so let's actually now create the code that would be uh part of our source code so we're going to create a class called video list and this is outside of the YouTube third party package this is our own uh sort of custom code now and we're going to have a dictionary um to store a list of videos and then we're going to have an add method for uh adding a video to this list and this should be
video. getet video ID so it looks like I've imported the wrong type of video here so let me import the correct one so it should be from proxy bad example and the third party package okay so now we should be able to get the you the uh ID there we go and we're going to pass in the video okay so as you can see this dictionary has a key uh a string key and the string key is going to be the video ID and the value for that key is going to be the actual video object itself so next thing we want to do is we're going to create a method called
watch and this is going to take a video ID it's going to get the video from the video list and we can do that by accessing the uh video ID value so we're getting the video at this key and we can then call video. render okay so that's everything we need to do in our video list so we store a list of videos with a string uh key which is the video ID and then we store the value as the actual video object itself so let's now take a look at how we could use this solution in side of a client so first of all let's create a
video list and then let's create a uh sort of list of video IDs and let's call this video IDs okay so just some random strings there and then let's Loop through these uh video IDs and add them to our video list okay so here we Loop through all of our
video IDs and for each ID we are adding to our video list a new YouTube video and we pass the video ID to the YouTube video class and if you remember this class will download the YouTube video whenever we create this YouTube video object so it automatically downloads okay so then what we can do is let's actually uh watch a video so let's say we want to watch the video with ID AB CDE e so we can say video list doat and we can pass the ID of the video that we want to watch so let's run this now to check that it's all working
correctly and we can see that uh we are downloading all of these videos so uh 1 2 3 4 a bcde e and Java SC c123 all been downloaded and then we render the video with ID AB CDE e so this one is ready to watch on the screen okay so just adding a video to our video list causes that whole video to be downloaded so even if the user doesn't want to watch that video it's still going to be downloaded and the user uh here uh the user here only wants to watch the video with ID a b CDE e so it will be much more efficient to
download the video only after the user has selected a video from the video list and this is called lazy loading or delaying the loading of something for when it's actually required so the problem is that our YouTube video class is from a third party Library so we're unable to modify its source code so the solution to this is to use a proxy object which we create ourselves so you can see here that the video list our video list is no longer going to be talking directly to these third party uh YouTube video objects instead it's going
to be talking to these Video Proxy objects which we are going to create and these Video Proxy objects are going to Lazy load these uh YouTube video objects so here is the uml for the solution that we are going to come up with so as you can see our video list objects will now talk to Video Proxy objects instead of these third party video objects and this uml shows that our Video Proxy object will implement the third party libraries video interface which is this interface here so this comes from our third party
package and this means that we can add these Video Proxy objects to our video list and video list won't care whether it's a third party video or a Video Proxy as long as it is of type video so so you can see here that Video Proxy which we're going to create and the third party YouTube video class both uh implement this thirdparty uh video interface meaning that they can be treated the same in our video list so now in inside of our video list we can add Video Proxy objects instead of our third party YouTube video objects which
gives us some control over when the uh video is downloaded so uh inside of the render method of a Video Proxy object we can see here we can check if the video field is equal to null and if it is we then create a new YouTube video and then render the video so now uh a third party YouTube video is only going to be created when the render method is called which means that when the user actually wants to watch the video so no videos are going to be downloaded until the you uh the user actually wants to watch them so here is the gang of 4 uml for
the proxy pattern and as you can see we have our client which is talking to a subject and we have a real subject and our proxy object and you can see that uh the proxy object uh both uh implements the subject just like the real subject does meaning that it can be treated the same as the real subject in our clients but but it means that we can also run some custom code uh before we call the real subjects request method and some things that we might want to do or lazy load or cash and or uh log some information
before we call this request method on the real subject so let's now implement this proxy patent solution in code so the first thing that we're going to do is we are going to create our YouTube video proxy class so we're going to come into uh we're not going to make this inside of the package by the way because this is our own uh code whereas this package remember is our third party Library code that we wouldn't actually have access to in a real application so let's go ahead and create the YouTube
video proxy class and uh this class needs to uh implement the video interface from our thirdparty library so we have a lot of videos here so I believe it could be any one of these let's try this one and okay is this correct okay I think that's correct so yeah we are implementing the video class from our third party YouTube package and then we need to actually implement the interface okay so inside of this class we need a couple of fields so first of all we need a a video ID field and we also need a field for
storing a reference to the actual YouTube YouTu video and this is going to be of type YouTube video from our third party Library so I've been a little bit inconsistent here with uh capitalizing the t's but it'll be okay so let's now create a Constructor so we can pass in the video ID for the video that we want to download and watch so we're going to create a public Constructor called YouTube video proxy and we're going to pass in the video ID okay we're not passing in a video okay so now what we need to do is
let's actually uh return the video ID here and then Implement our render method so inside of render we want to actually lazy load the YouTube video so if I just quickly show you what a YouTube video looks like from our third party Library you can see that the YouTube video is downloaded as soon as we create one of these YouTube video objects and we want to Lazy load the video so you can see here when whenever we create a YouTube video proxy we just pass the video ID and we don't actually create one of
these YouTube video objects because if we do it's going to download the video and we only want to download the video once this render method is called which means that when the user uh clicks on the video to actually watch the video so what we can do here is we can check to see if the YouTube video is equal to null so let's check if video equals null and if it does we can then set YouTube video equal to a new new YouTube video and in here we pass the video ID that we want to watch okay so this means that if the
render method is called multiple times then it's still only going to download the YouTube video once it's only going to create uh this new YouTube video one time uh because once this has already been called YouTube video will no longer be null Okay so uh finally we can call YouTube video. render okay and that's going to render the YouTube video so we are now lazy loading YouTube videos with this YouTube video proxy so now that we have these Video Proxy objects that Implement video we can now in our in our clients we can add
these proxy objects in place of the real YouTube video class so here we are adding YouTube videos but instead what we can do now is add YouTube video proxy objects instead so let's do that and what we want to do now is get rid of our previous uh example code okay so this all looks okay so that's all we've done we've just changed this from YouTube video to YouTube video proxy and our video list doesn't care whe whether we had YouTube video proxies or whether we had real YouTube videos because as far as the video list is
concerned they both implement the third party video interface and it can treat them uh as the same using polymorphism so now let's see what happens okay so when we watch the video we can see that the video is downloaded from the YouTube API and the video is rendered but if I comment this app out let's see what happens so you can see nothing is logged to the console when we add videos to the list whereas beforehand if you remember uh let's actually show you what happened beforehand so YouTube video and let's play this run this you
can see that even before the so even if the user doesn't click on one of these videos to watch them whenever we add them to the list or create one of these new YouTube videos the video had to be downloaded from the YouTube API so this would take potentially quite a long time whereas Now using the uh V YouTube video proxy you can see that no videos are actually downloaded until one of those videos is clicked on or the user wants to actually watch one so the video that we want that the videos are now laid
easy loaded so the only video that is actually downloaded is this ABCDE e video uh because the user actually wants to watch that one the flyweight pattern is a structural design pattern that aims to minimize memory usage by sharing common state between multiple objects allowing for efficient handling of large numbers of lightweight objects with shared characteristics so say that we have a farming game that includes different types of crops such as potatoes carrots and and wheat and each crop is represented by a crop object
that includes it its X and Y coordinates the crop type and an icon for that crop so here is the uml with its x uh x-axis position y AIS the type of the crop and an icon and the crop type you can see here is an enum which will have type of either potato carrot or wheat in our example and we have an icon and icons can can be represented by an array of bytes okay so here we have our crop type enom which can take the value of either a potato a carrot or wheat so these are the these are the three crop types that
we have in our game so let's now go ahead and create the crop class and a crop has a position on the screen so an x and y coordinate it also has a crop type field and it also has an icon which we can represent as an array of bytes okay so let's now create a Constructor for this crop class this needs to be of type crop type and then we can set the values set the fields and finally this crop class needs a render method for uh rendering the crop onto the
screen so I'm just going to log drawing the crop type at the position of X and Y okay so that's everything we need to do for this crop uh class so let's now create a crop service class which is essentially going to be used to fetch our crops and the are going to be stored in probably uh some database okay so let's create a method called get crops and this is going to return a list of crop objects okay so let's first of all uh create a crop list
and then let's uh simulate fetching our crops from a database so here what we can do is we can create some uh crops so I'm going to say V carrat equals new crop and we can say it can be at position one four and it can be a crop type of carrot and I'm just going to pass null for the icon uh just for convenience rather than creating uh an actual array of bites so let's also create a few more carrots so let's just call this carrot 2 and carrot three and let's just change uh the position that it will be rendered
on on the screen okay so that will do so that's kind of like simulating uh fetching our crops from a database so next thing we can do is we can add these crops to this crop list so we can call Crop list dot add and then we can add a carrot and then we can also add carrot 2 and carrot three and then we can return earn this crop list okay so you can see this kind of crop Service uh get crops method is just sort of simulating what we would do in a real application which is probably fetch the crops from the database and then
return the sort of list of crops and each crop knows its position that it should be rendered its type of crop and also the um icon for that crop type okay so using this solution in a client now so if we go into our program.cs file we can first of all create a crop service and we can then Loop through our crops and render them on the screen so we can say V crop in crop service doget crops and then we can just call CR crop dot uh oops sorry that should be crop dot render okay so now if we run this program we can see that we are drawing
all of our carrots at the correct position on the screen so the problem with this solution is that for every carrot or crop that we create we are storing a new object with all of the information about a carrot stored within that object so this means that if we create 1,000 carats then we'll be storing 1,000 karat icons in Ram and that's going to take up lots of memory and many mobile devices will struggle to handle that so if we actually have a look at the uh crop uh object uh we can see that this takes up
uh four bytes so integers take up four bytes this is 4 bytes the crop type is also uh 4 bytes and the icon will be around 40 kilobytes so if we if we actually create a new icon for every single crop that we create if we have say a th crops in the game that will be 1,000 * 40 kilobytes which is uh uh 40 uh megabytes for 1,000 crops and that is a lot of RAM for um smaller devices such as mobile phones and the game may slow down lag or crash so this is not ideal so so what if we could share icons between crop objects of the same type so
if we have say three 100 carrot objects what if all of those carrot objects could share one single uh carrot icon rather than creating uh 300 of the same icons so if a carrot is created with the crop class then its icon and crop type Fields will remain constant for the lifetime of the object but its X and y-coordinates will vary as the crop can be harvested and moved around so State That Remains the Same throughout the object's life is called the internal state of the object and state that can be changed is called extrinsic state so
you can see within our crop object the X and Y coordinates are dynamic they can change throughout the crop's life cycle so these are called extrinsic State and the crop type and the icon are constant throughout the crops life cycle so a a carot is never going to become a potato and a carrot is also never going to look like a potato so this is constant therefore we call it the intrinsic state of the object so if we can extract the intrinsic or constant state out of this crop object or crop class and place it into a new object
called crop icon then we would only need to create three crop icon objects for potato carrot and wheat TW in our application even if there are thousands of crops in the game we only need to create three of these crop icon objects and this is going to save a lot of memory so we can then for example just have one carrat icon object stored in memory then all crops of type carrot can reference or reuse that carrot icon object throughout the game so you can see here we have a crop with its X and and Y uh Dynamic uh fields and it's
composed of a crop icon object and only one of these crop icon objects are going to be created per crop type so uh carrots or are going to all share a single crop icon uh object for carrots and potatoes will also share a single crop icon object for potatoes Etc so an object again an object that contains only intrinsic State uh is actually called a flyweight object okay so let's just remind ourselves the intrinsic state is the constant state and you can see here an object that contains only intrinsic state is called a flight weight so this
crop icon object is going to be our flyweight object but it should be noticed that we shouldn't create crop icon objects directly so we can create a factory class that creates creates an icon depending on the icon type and caches that icon in memory ensuring that it's only stored in one place and ensuring that it's only created once so here is the overall structure following the flyweight pattern so we have our crop with its extrinsic State we have our crop icon with the um with the intrinsic state so the um the uh con
States we then have a crop icon Factory which is essentially going to ensure that crop icons are only created once per crop type and stored in a single place in memory and then we have our crop service which is going to sort of simulate getting our crops from the database and creating a list of crop icons so here is the gang of four representation for the flyweight pattern we can see that we have our flyweight object with some sort of repeating State we then have our flyweight Factory which caches flyweight objects ensuring
that they are only created once and then we then have our context uh which in our case is like our crop object with its unique state or its Dynamic State that's going to change it stores a reference to the flyweight object and and we then have some operation so Flyway do operation uh with its unique State okay so let's now implement this flyweight pattern for our uh farming game so we are now going to refactor our code to follow the flyweight pattern and we're going to basically store these uh Fields inside of a separate class so
that it can be cached in memory and we don't have to create multiple icons for the same crop so we still have our crop type enum so nothing's going to change there but inside of our crop class we no longer need these fields okay so we're actually going to instead reference a crop icon object which we haven't created yet so vs code is going to give us an error and let's call this crop icon and inside of our Constructor we can again remove these fields cuz we're not going to pass these anymore we're
instead going to pass a crop icon and vs code is going to give us again an error and we can set this crop icon equal to crop icon okay so in here we no longer have direct access to this crop type field so instead we can call Crop icon. getet type because we are going to provide that method on the crop icon object okay so that's everything that we need to do in our crop uh class and we now have some errors that we need to fix so let's go ahead and create the crop icon object okay so this is going to be our
flyweight class that stores intrinsic or constant state the state that remains constant throughout the object's life whereas our uh crop glass is storing our extrinsic state or our Dynamic State um that is going to change throughout the object's life so in here we can store two Fields so we're going to store the uh crop type and we are going to store the icon which is going to be again an array of bytes and what we can do is we can actually make these fields read only to ensure that once they are constructed
they can not be changed so let's create make those read only okay so let's create our Constructor now okay and remember we also need to create a geta for the crop type so that we can get the crop type inside of our crop icon uh inside of our crop object okay so I think that is everything we need to do here so now we need to create our crop icon fact class so this class is going to ensure
that each unique crop icon object is created only once it is cached and then reused or shared between the crop objects so first of all let's create our crop icon uh cache so this is going to be a dictionary and in here the key for the dictionary is going to be crop type and the value is going to be the uh the crop icon okay so now let's create our get crop icon class which is going to uh essentially ensure that icons are only created once per crop type so here we are going to return a crop
icon uh that should be crop icon and we're going to call this get crop icon and it's going to take a crop type that we want to get the icon for so if we want to get the icon for a carrot we can pass crop type. karat into this get crop icon uh method so first thing we need to do is we need to check if the icon already exists inside of our cache so I'm just going to make a little uh a little comment here to say that this is our cache um so what we can do is we can say that if I icons and this needs to
be uh negative so if icons does not contain key of the crop type then that means that the icon does not exist in our cache which means that we need to create one and add it to our cache so let's create an icon so V icon equals new crop icon and we can pass the crop type and for the icon uh I'm actually just going to pass null um and I'm just passing this again for convenience but this could be for example a reference to uh some file location of the image but just to keep things simple I'm passing null for now
to not make things too uh complicated so once we've created our crop icon class we can add this icon to the dictionary so the key is going to be the crop type and the value is going to be this crop icon object okay so finally uh if we get to here we know that the icon exists so the icon e either already existed so this wasn't necessary so this uh conditional uh we just skipped this bit here or if the icon didn't exist we created a new one so if we get to here we know that we have uh this icon so we can
return icons and access the crop icon object via its crop type key okay so this all is looking good so we now have our crop icon Factory which is ensuring that each crop icon object is only created once per crop type okay so finally we can come into our crop service class and we can now do some refactoring in here so crop service needs to store a reference to the crop icon Factory so we can create a field called crop icon Factory and we can call this icon Factory and we need to pass this via the Constructor okay so let's have a look at our G crops
method so we are storing a list of crops so we don't need to change this and then we simulate fetching the crops from the data base so this is where we need to make uh some modifications so we can see here that now in our crop uh class we are no longer passing the uh the sort of a constant state okay because this is now stored in our flyweight object so instead of passing um the crop type and the um and the icon we now use our uh icon Factory to create a uh crop icon object so we can say icon Factory dot uh get crop icon and then we pass
the crop type that we want to get so we can we can say crop type do carrot okay and all of these carrots now are going to be sharing the same crop icon object which is stored in Cache uh due to our icon Factory so this is exactly what we want and then here we add our crops to the crop list and return the crop list okay so now let's go into our program.
cs file or our sort of client and let's see how we now use this new solution using the flyweight pan so here we create our crop service and we can see we have an error here so there is no argument given that corresponds to the required parameter icon Factory of crop service. crop service crop icon Factory so you can see here that we need to pass a crop icon Factory so let's let's go ahead and pass that in and we are now doing exactly what we did before we are lipping through our crops and we're calling crop. render so
as you can see there's not much difference in the way clients use this class we just uh sorry the way the client uses this solution we just now need to pass a crop icon Factory to the crop service to ensure that uh uh so that this is actually handling the creation of crop icons okay so now if we run this file uh run this program you can see that we get exactly the same as what we did before which is perfect so to summarize we have created three carrot crop objects but only one carrot crop icon object so this solution will
save lots of ram when rendering many crops at one time the facade pattern is a structural design pattern that provides a simplified interface to a complex system encapsulating the complexities of multiple subsystems into a single unified interface for clients so say that we have an e-commerce application that allows users to submit orders here are the steps involved in that process so we have a user that is submitting an order and then we have a server which has multiple steps for handling this order so first of all we
have to authenticate the user check inventory so make sure that we have enough of the items that the user wants to purchase we then connect to some payment service such as stripe we then fulfill the order which might involve uh something like reducing the inventory uh then we charge the user and send them a response which can either be successful or if any of the steps fail then we can send some sort of fail response so as you can see there are five main steps involved in processing and order so let's first of
all implement this roughly in code so I've created some classes to simulate the steps involved in processing and order so let me show you what we have here so we have an order request class and this is going to be the request object containing the User submitted data so say that the user has some form they enter their name their card number uh we also send the amount for the order the address of the user and the item IDs that the user wants to order okay so this is like the order request object uh we then go through uh some
authentication steps so I've just created an empty class for now to keep things super simple but this might check uh the user's session checks whether the session is valid uh that their username all checks out and then we have an inventory uh class with a couple of methods so we can check the inventory for the item IDs and we also have a method which can reduce inventory by a certain amount for the specified item id okay so um and check inventory we're just going to return true so we we're always
going to say that we have an item in stock and then we have a payment uh class for handling the payment uh step within the order process and here we can uh set the name c number and the amount that the user owes for the order um and then we have a method called pay which is going to simulate um you know maybe connecting to some payment service and charging that users's card and then next up we have an order fulfillment um class which is going to Che uh check the inventory that we have sufficient inventory uh so we can see here we have
a fulfill method which is going to uh loop through the items in the item list so the items that the user wants to use and it's just going to reduce the inventory of of those items in the loop and we also have like we've also logged inserting the order into the database so uh that we have record of um this order in our database a sort of permanent record so these are just sort of classes that are simulating the steps involved in the order process just sort of some rough code that we can uh use to sort of
demonstrate this example so this is now the sort of important bit so I'm going to show show you how a client would actually use this solution so first of all we can create an order request object and this is going to be equal to a new order request we can then create our authentic uh authentication object we then need to create our inventory object and in here what we can do is we can Loop through our order request item IDs so you can remember in our order request object just for convenience I've sort of
hardcoded these values in obviously a real order request wouldn't have these values hardcoded in I've just done that for convenience so what we can do is we can Loop through uh all of the item IDs in the order so we can say order request do item IDs and then we can check the inventory for each um Item ID and this is always going to return true so we don't have to worry too much about that this is just a quick rough example then we can create our payment object so we can say VAR payment equals new payment and in here we can pass the
uh some information from the order request object so we can pass the name um the card number and the amount for the order okay then we can call payment. pay and finally we need to do the order fulfillment so let's create our order fulfillment object and this should be lowercase and in here we need we just need to pass our inventory object okay then we can call order fulfillment.
fulfill and we can pass the uh some information again from the order request object so then we pass the address and finally the order items so the item IDs okay so that's everything that we need to do for processing and Order okay so let's run this program to see that everything is working directly and we can see that we are uh charging the card with the name Dany we insert the order into the database and we are reducing inventory uh of all of the items that the user has ordered by one so we are fulfilling the
order so as you can see every client that needs to make an order has to go through all of these steps to make a single order so you can see here every time we want to make an order we have to go through all of these steps and every client uh that needs to make an order becomes coupled to or dependent on four concrete classes the authenticate class inventory payment and Order fulfillment so if we had 10 classes that needed to make an order then we'd have 10 classes dependent on these four classes so that's a lot of
coupling so if one of these four classes changes then that's going to be 10 10 classes that need to be updated and this is not good this is not maintainable so each client that needs to make an order will depend on four classes so here's the client it's going to depend on these four classes so let's now take a look at how we can solve this issue using the facade pattern so clients making an order don't actually care or they don't actually need to know about the steps involved in making an order they just
want to make an order so let's introduce a new class called order service with a single method called order that abstracts all of the logic so that all other classes that need to make an order only have to depend on this one class so you can see here we've created an order class which has an order method that accepts and order request object now this order service class uh depends on these four classes which are the sort of steps involved in making an order so this order service is essentially containing all of the steps that we had
here all within this one method so that now all classes that need to be able to make an order only need to depend on this one order service class and not all of these uh individual sort of steps involved in making an order but let's now go ahead and make our order service class so this class is going to act as our facade that encapsulates all of the complexities and steps involved in making an order so clients can then make orders without having to know about all the details or steps involved in the order process so let's create a single
method called order that takes an order request object and in here we can simply uh go through all of the steps in creating an order and these are actually going to be exactly the same as what we have in our client over here so let's copy and paste those in okay so this is everything we need to do to make an order uh and now inside out of our clients we can remove all of this stuff so all we need is our order request object so this is a sort of incoming order request from the user which contains all of the users sort of
uh inputed uh data such as their name card number address Etc we can then create an order service object and we can can then call order service do order and quite simply just pass this order request object and now that's all we need to do to make an order so let's run this and we should get exactly the same as what we got before so we can see here exactly the same as what we had previously so now clients can make orders without having to to without having to depend on many classes and without having to know about
all of the complexities uh involved in making an order as all of these complexities have been abstracted away and encapsulated within this order service class so now you can see it's much more simple for clients to make orders by using a facade class The Decorator pattern is a structural design pattern that allows Behavior to be added to individual objects dynamically enhancing functionality with without altering the objects structure and it's used to extend or modify the behavior of objects by wrapping them with additional
functionality through composition so say that we have an application that allows users to store data in the cloud the data can be sent to the cloud as it is without any processing or it can be compressed Andor encrypted before it's saved to the cloud so here's a uml diagram for a basic uh sort of of almost naive solution to this problem so here we have our cloud data class with a URL for the location where this data is going to be stored in the cloud we have a Constructor where we pass and set the URL and we have a save method uh where
we pass the data that we want to save to this URL location in the cloud we then have some extra classes that extend this cloud data class and add some extra functionality so we have an encryption class which also has a save data uh method and here we are overriding the method in cloud data and adding some extra uh functionality to encrypt the data before it is saved we also have a compression class which compresses the data before it saved and then we have a an encryption and compression class which both encrypts and
uh and compresses the data before it's saved to the cloud so so far everything looks okay but then the boss says that we need to create a new validation class to validate and clean the data before it sent to the cloud and we can see below that our code starts to look bloated as we need to make lots of new classes just to add one extra feature so you can see here our sort of class library is becoming very very quickly bloated so to add one new feature this new validation feature we have to create four new
classes and uh class library is actually growing here exponentially so this is not good maintainable or flexible so let's see what this looks like in code so first of all let's create our base cloud data class and this cloud data class needs have a URL field and we're making this a protected field so that the classes that inherit cloud data will have access to this URL field if we made it private then it wouldn't be accessible to all of this uh classes subclasses so next up we will create a Constructor
where we can pass the URL uh location of where we want to store the data in the cloud so finally we need to create a save method and we're going to make this a virtual method so that it can be overridden in sub classes and we're just going to make the data some sort of string to keep things simple for now and we're going to log saving data to Cloud at the URL location okay so that all looks okay so now we're going to create our compress data class and this needs to extend the cloud data CL uh class cuz we're adding some
extra functionality and here we can generate the construct uh Constructor for cloud data so we pass the URL location and we can then override the save method uh inside of this class okay so what we want to do here we are let's remove this for now so what we want to do is first compress the data so I'm going to say for compressed equals compress and then I'm going to pass the data to this method so let's create this compressed uh sorry let's call this compress and let's create a method
called compress and we can pass the data and what we're going to do is we're just going to tr trim or sort of create a substring from the data so we're going to return data do substring and then we're going to go from the first character up to the ninth character in the uh well this will be the eighth character so from index0 to index 9 in the uh string okay so we're just trimming the string down basically and this is uh our way of sort of pretending or simulating comp pressing the data so next
up let's create our encrypted data class which will encrypt the data before it is sent to the cloud and again we need to inherit from cloud data and we need to generate the Constructor for the cloud data and again we're going to override the uh save class and again we're going to call base.
 saave so base is going to be the base class which is cloud data and we're calling the save method on cloud data and passing the data but what we need to do is pass some encrypted data so we can say VAR encrypted equals encrypt and we're going to pass the data so then we can pass this encrypted data to our save method so let's actually create this encrypt method now so this is going to be a public method that returns a string it's called encrypt it takes some string data and we're just going to return uh some random strings so we're going to pretend
to encrypt the uh data okay so this is like simulating encrypting the data basically okay and we're going to pass that to our uh cloud data save so here we encrypt the data then we save it okay so essentially we've added some functionality to this cloud data class by extending it okay so finally let's create our compressed and encrypted data class so let's create that so we're going to say compressed and encrypted encrypted uh data and again we extend cloud data generate the Constructor and we're going to
override the save method okay so in here what we want to do is we want to get the compressed data and we want to pass the URL which we have uh inherited from cloud data and we want to call compress and we need to pass the data to this method so now we have the compressed data let's now uh encrypt this uh compressed data so we can say and uh encrypted and compressed equals new encrypt data and we pass the UR URL and then we can call encrypt and pass the data and then we can pass this encrypted and compressed data to our
base cloud data save method so so that we store it to the cloud okay so this is everything that we need so let's now go ahead in our program.cs file and use this solution so I'm just going to copy and paste a few things in here to save some time so here we have a URL for the location to store the data so I've just put Google Cloud for now we have our data that we want to save and we have a bu Bull in here that says compress equals true and we have encrypt equals true so here we want to store some data to this URL location in
the cloud and we also want to compress and encrypt the data and this can essentially sort of simulate some sort of user input data okay so the user might uh specify the location and the data they want to save and whether they want to compress and compress uh encrypt the data before saving it so now that we have um the user uh this input data uh we have to select the correct cloud storage object so first of all we can create our cloud data object and we pass the URL and then what we can do is we can check we can add some conditionals to
check whether we should compress and uh or com uh encrypt the data so we can say if compress and encrypt then we can reset uh reassign cloud data to uh a compressed and encrypted data object so we can say new compressed and encrypted data and we can pass the URL and then we can say else if uh else if compress then we want to set cloud data equal to compressed data and we pass the URL okay and finally we want to check if we are just encrypting the data and then we can say uh cloud data [Music]
equals encrypted data and pass the URL and that should be new encrypted data okay so as you can see in the client we have to check whether we should compress and encrypt or just compress or just encrypt and then we set the cloud data object equal to the appropriate uh uh class type so finally we uh now we have now that we know that we have the correct uh way of storing the data we can simply just call cloud data do saave and then we pass the data to this method so let's run this okay so this seems to be working
correctly the data is being uh compressed and encrypted because these are are both true so as we discussed our total number of classes is going to increase exponentially with this solution but another issue is that we have to perform lots of conditional checks in the client um whenever we use this solution so for example if we add a validated data class then we'd have to add conditionals for encrypt and compress and validate and also press and validate uh encrypt and validate and also just validate by itself so we'd
have to have four extra conditional uh statements uh just to add one new feature and this is really not good and this is actually going to continue to get worse and worse uh exponentially as we add more classes uh or features so this is a really bad solution so let's now now use a design pattern to solve this mess so the solution to this is to move away from inheritance and use composition instead so you may have noticed by this point that a lot of design patterns are based on moving away from inheritance and towards composition
so with composition one object has reference to another object and delegates that object some work and this allows you to use polymorphism and switch between objects at runtime making your code more flexible whereas with inheritance the object itself is able to do that work inheriting the behavior from its superclass so with inheritance we have to create lots of new classes with composition we can wrap or decorate existing objects to add new functionality so here we have the uml for the decorated patent solution so we
can see here we have a data interface with a save method that accepts the data we then have our cloud data class which has as before the URL location for storing the data in the cloud and we pass this via the Constructor and it has a save method uh which we have to implement from this data interface we then have a data decorator class and this also implements the data interface and you can see here that we have a wrappy field and the wrappy is essentially the object that is going to be wrapped and in our case that's going
to be our cloud data object because we're essentially what we want to do is add additional functionality or at least have the option to add additional functionality to this cloud data class so uh we want to be able to uh add the ability to encrypt or compress or both compress and encrypt so here we can essentially wrap this cloud data uh object in in a uh encryption decorator or and or a compression decorator so you can see here we can pass the um wrappy into the Constructor and we also have our save uh method because we are
implementing this data interface and then we have our sort of specific uh decorators so this dat decorator class CL is kind of like a little bit of a helper class that contains some sort of common Logic for uh what decorators should be able to do so if I just read this paragraph here so above and this uml we're making the encryption and compression objects decorators because they are decorating the cloud data object with some additional Behavior Uh because decorator classes have some common logic uh for example referencing a data source
object uh we have created a data decorator class where this logic can be inherited to prevent code repetition so this means that encryption decorator and compression decorator will share some common fields and logic and for example in our case uh both of these classes need to wrap the cloud data object and this should probably be uh referencing a cloud data object so essentially our decorator classes are composed of or are decorating or wrapping a cloud data object or any object that implements the data interface to add extra
functionality so let's take a look at the gang of four uml for The Decorator pattern and as you can see it's basically the same as what we have in our solution uh the only difference being the names of the classes so if this isn't making much sense then don't worry because things will become a lot clearer as we code out this solution so now we're going to implement our solution using The Decorator pattern so first up let's create the data interface and this needs to have a single method for saving the data
okay so next let's create our cloud data class and this is going to be the class that we are going to wrap or add functionality too in other words decorate so we're going to decorate this class with additional functionality but first of all let's actually create this cloud data class and this needs to implement the data interface so let's implement the interface and in here again just as before we need to um store reference to the URL that we want to save to so I'm actually just going to copy and paste
what we had beforehand because it's exactly the same so you can see here that we have um uh a Lo a URL location for storing the data we passed that by the Constructor then we have a save method for actually saving the data so this is exactly the same as what we had before the only difference is that we are now implementing this data interface so now let's create our data decorator abstract class and again this needs to implement the data interface okay so this needs to store reference to uh some sort of data object
so this is going to be the wrappy object or the object that we are decorating or adding functionality too so let's create a protected field of type data and the reason it's protected is because the encryption decorator and the compression decorator need to have access to this data field so that's why we are making it protected and not private so next up let's create the Constructor so that we can pass a data object to wrap and then we can set the data object in the Constructor and then we have our
save method so we actually don't want to implement this method inside of the data decorator class itself we want to make this method abstract so that it can be uh overridden or implemented in the uh compression and encryption sub classes so we can make this an abstract method and then we need to make this class abstract and that is everything we need to do inside of this data decorator class so now we can go ahead and create our compression decorator and this needs to extend data decorator uh we then need to generate
the uh or we need to implement the class and also generate the Constructor so we're passing the wrappy object again to this base dat data decorator class and we're also overriding this abstract save method from data decorator so this is where we're going to add our compression logic so this is going to actually be the same as what we had beforehand in our compressed data class so we can copy and paste the save and compress methods from what we had before and that is all okay we just have an issue here because we um actually need
to say base dot data so we're now using uh composition here so we call base. data to get the data field and then we call the save method on that data field and we can press the compressed data okay so that's all we need to do there um so I'm also just going to uh log whenever we call the save method so that it's easy to see what's going on so I'm just going to put compressing data okay so I think that's everything we need in our compression decorator class so let's now go ahead and create
our encryption decorator and this needs to extend the data decorator and let's now implement the abstract class and also generate the Constructor so you can see here that this data decorator is just a kind of class that makes it easier to uh to create the different uh decorators it's just basically a kind of helper class where we have uh some basic setup for a decorator which is uh essentially just passing some sort of wrappy object uh into uh the class and it saves us from having to write this logic inside of
both of these classes we don't have to uh bother recreating this okay so it's just presenting a little bit of repetition basically um so here we have our encryption decorator we have our Constructor so now we can implement the logic for encrypting and saving some data so let's copy what we had before because it's not going to be uh any different in terms of the uh logic so let's copy and paste those methods and again instead of calling base.
 saave what we need to do is call base. dat. Save and then we pass the encrypted data okay so that is everything we need to do so now let's actually use this solution in the client so what I'm going to do is I think I'm going to remove all of this and I think I'll also remove this and let's reimport these objects okay so first of all let's create our cloud data object so this is going to be called cloud data and it's going to be equal to new cloud data and in here we need to pass the URL that we are saving to okay so next up we can add our
conditional statements so we can say if encrypt uh if encrypt is true so if the user wants to encrypt the data before saving then we can reset uh cloud data equal to uh new encryption decorator so let me show you actually this is going to be easier to just show you so cloud data equals new encryption decorator so we create a new decorator and we pass the cloud data to this class okay so you can see here that we are wrapping or decorating the cloud data with an encryption decorator okay so we're adding some additional
functionality by wrapping this object inside of a decorator okay rather than creating a new specific subass okay we're wrapping using composition instead of using inheritance and creating a new uh encryption uh data class like we were before and now what we can do is we can say if we want to compress so if we want to also compress or just compress alone we can call uh we can wrap this cloud data in inside of a compression decorator okay so that's all we actually need to do those are the only conditionals that
we need we only need to add one extra conditional uh for every type of feature that we have so then at the end we can call cloudd data. saave and then we can pass the data and then let's run this program and we can see that we are compressing the data and then saving data uh to the cloud at google.
com so we are compressing and encrypting the data if we make compress false let's see what happens uh we can see that we are just encrypting the data if we make both of these false let's see what we get we just save the data as it is and everything seems to be working uh as it should be okay so this is perfect because now if we for example want to add a new feature say a validation uh step then we just have to add one more uh conditional we just have to say if validation equals is true then we can wrap in a validation
decorator we don't have to create um a load of new sub classes we just create one new decorator Class A validation decorator and we just just have to add one new conditional to the client we don't have to create a validation plus compression a validation plus encryption validation Pro Plus compression plus encryption subass we don't have to create all those subclasses and then add conditionals for all of those new combinations of uh steps so this is a much much more maintainable solution using The Decorator pattern so so far
we've looked at the behavioral and structural design patterns but last but not least we need to look at the group of creational design patterns so first of all massive congratulations on getting this far into the course and your award is that creational design patterns are probably the easiest group of design patterns to learn and understand so if you feel like giving up at this point please don't the hardest work has been done so creational design patterns are a category of design patterns that to focus on object
creation dealing with the best way to create objects while hiding in the creation logic and making the system independent of how its objects are created composed and represented so some benefits of creational design patterns are that they uh help to encapsulate object uh creation uh object creation logic uh hiding it from clients and this promotes loose coupling and allows the system to be more flexible to changes in how objects are instantiated and they enhance flexibility and extensibility by promoting uh by
providing ways to create objects dynamically based on varying requirements or conditions and this makes the system more adaptable to changes and new features so we also have um improved code reusability uh by encapsulating object creation logic in reusable patterns such as factories or Builders developers can leverage existing patterns to create similar objects in different parts of the application promoting code reuse we also um they help these design patterns also help to promote the separation of concerns so creational patterns helps to
separate the responsibility of object creation from the rest of the systems logic and this separation of concerns improves code maintainability and readability uh creational pattern also uh Provide support for depend dependency injection so they often play a crucial role in supporting uh dependency injection by providing mechanisms to manage the creation and injection of dependencies promoting modularity and testability and if you've never uh if you're not really sure what dependency injection is we will cover it uh
throughout the design patterns and it's a very very common uh term that you'll come across in software development and it's used in backend Frameworks such as larabel spring boot or net and uh creational patterns help to centralize the control over how objects are created allowing developers to apply consistent instantiation strategies across the application and uh creational patterns also encourage adherence to important design principles that we've covered earlier such as abstraction and capsulation and separation of concerns
contributing to a more robust and scalable a architecture so in summary creational design patterns offer numerous benefits that contribute to the overall quality flexibility and maintainability of software systems by providing effective solutions to object creation challenges and promoting best practices in software design each pattern addresses specific aspects of object creation catering to different scenarios and requirements in software development so now let's learn all of the ganga four creational design
patterns the Prototype pattern is a creational design pattern that allows objects to be copied or cloned providing a mechanism to create new instances by copying existing objects without explicitly invoking their Constructors and it's used to efficiently produce new instances with identical properties to existing objects so say that we have a guey a graphical user interface that allows the user to create new shapes on the screen such as circles and rectangles when the user right clicks on a shape an actions menu opens up and the
user can then select duplicate to clone the shape so you can see here we have the original shape on the left if the user right clicks and then clicks on duplicate from the actions menu the shape is duplicated and rendered on the guey so let's come up with a solution to this problem so you can see here we have a shape interface with a draw method and then we have our concrete shape classes that implement this shape interface and then we have a shape actions class that contains the logic for duplicating each
shape and this uh duplicate method uh and this shape accents class is dependent on all of the shapes that can be duplicated so you can see it see here that um we can see that this class depends on all of these concrete shapes by and that's represented by this dotted so can you see the issue with this solution and can you also spot what solid principle we are violating and as we code out this solution um the issue here is going to become very obvious so let's go ahead and do that so first of all let's create a new folder for our
creational design patterns part of the course and then we'll create a new folder for this prototype pattern okay so first of all let's create the shape interface and this is going to have a single method called Draw now let's create uh a few concrete shapes so let's first of all create a circle and this is going to implement the shape interface SP okay so we have the draw method here and let's just uh log here drawing circle okay so we also need to give the circle a property for its radius CU all
circles need to have a radius so we'll say public int radius and then we'll give it a getter and seter okay so the nice and simple and I think what we'll do so whenever the user sort of creates a circle on the uh screen so if they click you know a little circle icon that produces a circle to appear on their canvas then I think it would be nice to give it a default radius so let's give it a default radius of five for all newly created circles okay so next up let's create the concrete rectangle shape
and again we implement the shape interface and all rectangles have a width and a height so let's go ahead and give it a width and height property and also a height and again let's give it a default height of 10 and a def sorry a default width of five and a default height of uh 10 actually no we'll go with 10 and five okay okay so let's uh just log drawing rectangle here okay so that's all we need to do for our shapes so now we can create our shape action class which uh is going to depend on all of these concrete
shapes okay so let's create our duplicate method which is going to accept a shape so it has a shape parameter now in here what we need to do is we need to duplicate any shape that's passed into the duplicate method so first of all we need to actually check what the type of shape uh what type of shape has been passed in so we can say if shape is circle first of all and let's see what's going on here the type name space Circle could not be found let's see ah I've misspelled Circle here so let me correct
that okay and that fixes the issue so let's see so first of all let's um cast this shape object into a circle so we'll call this copied shape so the shape that we are copying and we'll cast it into a circle and that's how we cast and again I spelled Circle wrong there we go okay so now we will create our new shape which is going to be the Clone so I'm just going to make a note this is the uh copied shape and then we will have our uh new shape the duplicated shape okay so we create a new Circle and
this is the Clone and then what we can do is we can set the new shapes radius equal to the copied shapes radius okay and then we can draw this shape onto the canvas by calling the draw method and then we also need to check um if the shape is a rectangle and if it's a rectangle again we're going to create um we're going to cast the uh shape into a rectangle okay so now we can uh treat this shape as a rectangle so we also need to create our new shape or our clone so this is going to be a new rectangle
and then we can set the new shapes width and height equal to the Past shape the past in shapes uh width and height so we can say uh new shape dot width equals copy shape do width and we can say new shape. height equals copied shape do height and then we can draw the new shape onto the canvas okay so it would also be a good idea to um check at the end here so if the shape or is not a circle or a rectangle then you know we could prevent uh we could just throw an error so let's do that so we'll throw a new argument
exception and we'll say invalid shape provided okay so we can't duplicate uh a shape that that isn't a circle or rectangle in our current implementation okay so here's how a client would use the solution so let's go ahead and show you how this solution would be used so we can create a circle and I cannot spell circle today so let's create a new Circle and let's draw that Circle so render it onto the canvas and then let's simulate uh the user clicking the um clicking the circle and dragging
to resize so this is like user clicks and drags to resize so we can say Circle do radius equal 12 so we increase the uh radius and let's say that a user uh adds a new rectangle to the guey so I'm just going to copy and paste this in for now to save a little bit of time so we can see here we create a new rectangle draw it onto the guey so this is like the user adding a new rectangle to the guey and then the user clicks and drags the rectangle to resize the width and height so now let's take a look at how
we could duplicate these shapes so let's simulate the user uh right clicking and uh clicking and selecting duplicate okay so we can simulate that so shape actions equals new shape actions and then we can call shape actions. duplicate and pass the shape that we want to duplicate so if we want to duplicate the circle we can do that if we want to duplicate the rectangle we can do that okay so let's run this program to see if everything is working correctly and as you can see we are drawing the circle and rectangle onto
the uh guey so that's these two uh methods here so Circle do draw and rectangle do draw and then we duplicate the circle so we draw the circle again and then we duplicate the rectangle so we draw the rectangle again so this is all working correctly so hopefully by now you have spotted the main issue with this solution and the uh it should be pretty obvious that the issue is in this duplicate method so here are some of the obvious issues that I can spot so first of all we are violating the solid open close Principle as we need to modify
this shape actions class every time we add so that means extending our code base a new shape so whenever we add a new shape we're going to have to add add uh modify uh our existing code because we're going to have we're going to have to add a new conditional uh block of code to check for this new shape and add the logic for duplicating that particular shape and you can also see that shape actions is coupled to the concrete shape classes and so far that's Circle and uh rectangle so you can see
it's coupled because we're calling the new keyword here and uh so shape actions has to know about or depend on all kinds of shapes and their specific fields and methods so you can see here that this shape actions CL actions class has to know that circles have a radius field and it has to know that rectangles have a width and height so it has to know about the specific implementation details of each of these concrete shapes and at the time of writing code shape has actions has to know about all the shapes that we support so what if we
wanted to make this app extensible so that other developers or other people can build plugins for this uh application so that they can Define other types of shapes that can be added to the guy and that can't be achieved with this current implementation because at the time of writing code or at compile time they this shape actions class has to know in advance about all of the types of shapes so this is not a flexible solution and it currently depends on concrete implementations of shapes so let's now take a look at how
we can solve the issues that we found previously so the logic for duplicating a shape can be moved to each concrete shape class rather than having it all in the shape actions. duplicate method so in other words we can move uh all of this duplication Logic for a circle and add it into the circle class and we can do the same for rectangle put it all into the rectangle class okay so we can then decouple shape actions from all the concrete shapes and have it talk to the shape interface which is much more flexible and
maintainable so note how the shape actions class has been sort of lifted up to talk to the single shape interface rather than having it talk to many concrete classes so you can see beforehand it depended on the many concrete classes because we had to check uh what the type of shape was before duplicating it where now it's been lifted up to talk to the shape interface and we've added the duplication Logic for each shape into its own uh into its own class class okay so let's have a look at the gang of four representation
of the Prototype pattern so here you can see we have the Prototype interface with the Clone method and then the concrete prototypes implement this clone method so each concrete prototype knows how to clone itself rather than having this clone logic inside of some sort of client or other class as we had previously and this means that the client can use polymorphism and talk directly to to the Prototype interface rather than talking to the many concrete prototype classes so let's now implement this solution in
code okay so now let's refactor our code to use the Prototype pattern so the first thing I'm going to do is I'm going to change uh well I'm just going to add an extra method to the shape interface so that all shapes can be duplicated and you can see the dup liate method is going to return a shape so next up we need to solve a few errors that we're now getting so you can see here that Circle does not Implement imple interface member shape.
 duplicate so we need to implement this duplicate method so we've already created the duplication logic beforehand in our shape actions class so what we can actually do is we can copy uh this here so we can can say New Circle and shape. radius equals copied shape. radius so let's add that into Circle and you can see here that we don't need to reference this copied shape anymore we can just uh use the radius field directly on Circle okay then finally we need to return this new shape like so so here we create the new shape
to clone and then we just set the radius equal to the current Circle radius and return that new shape okay so New Circle and let's actually re rename this now to New Circle okay so next we need to do the same thing for rectangle so let's implement this shape class so we need to add the duplicate method and then we can uh copy and paste the logic for um copying a rectangle so let's add that in and we actually need to create a new rectangle okay so we create a new rectangle and then we set the width and
height equal to the current rectangle width and height okay so let's again change uh the name of this to something a little bit more specific so new rectangle and then we need to return this new rectangle from the duplicate method to satisfy the uh method signature okay so that's everything we need to do in the concrete shapes so now we can go to our shape actions class and we can see here this very bloated oakly method can now be uh refracted into something much much cleaner now what we have to do it's
called is return shape do duplicate okay and we're actually going to return a shape this time from the duplicate method so I'm just changing the kind of implementation details a little bit here so rather than drawing the shape onto the screen we're just going to return the shape and allow the client to decide what they do with with that duplicated shape okay so I'm just also going to log uh just so it's clear uh duplicating shape just so it's clear what's going on when we run the program okay so now
let's go into our client and see what happens if we run this as you can see everything seems to be working correctly okay so what I want to do here is because now duplicate is returning the new duplicated shape let's see if we can um uh let's see New Circle equals that so now we can um store this return shape in a variable uh so let's say shape uh new rectangle equals that and then we can decide in the client whether we want to draw it on the screen or do whatever we want with this new uh cloned uh or
duplicated uh shape so let's actually draw it so this is basically now doing exactly what we had beforehand we duplicate and draw the shape on the screen but we're now controlling whether we draw it or not in the client so it's just a slightly different implementation detail that gives the client a little bit more control over what they do with this duplicated shape so let's run this now and I think what I'm going to do is actually duplicate uh create the new Circle then draw it just so it's a
little bit more clear okay so we can see here we first of all draw a circle just the same as before we then draw a rectangle we then duplicate the uh Circle we then draw this new duplicated circle on the screen then we duplicate the rectangle and draw the rectangle on the screen okay so this is all working perfectly and we can now also add new shapes without having to modify existing code in the shape actions class so the great thing about this prototype pattern is we are now satisfying the open close principle because we can create a new
shape such as a triangle and we don't have to modify any existing code the Singleton pattern is a creational design pattern that ensures that a class only only has one instance and provides a global point of access to that instance the single instance is commonly used for managing shared resources configuration settings or logging functionality within an application a common use case of the Singleton pattern is to use a single Global instance of a database object throughout an application this means that all clients that need to connect to
a database will retrieve the same database object and will not be creating new separate database objects the database object is only created once the first time it is needed and then all of the clients that need to connect and query the database will use the same database object so here's a user making a request uh to fetch some products there are two classes user authentication and products both require fetching things from the same database notice that we we are not using the new keyword to get the database object we
are using a method called get instance that Returns the exact same database object throughout the application ensuring that we always use a single database instance so you can see here we have our user which goes through uh two classes so first of all we authenticate the user and to get the database object we are calling db.
 get instance we are not calling DB equals new database uh whatever okay so we're not using the new keyword we're using this sort of factory to get the same instance of the database object so it's going to be cached somewhere in memory so you may be wondering why we can't just create a new database object every time we need to connect to a database so here are some good reasons to use a single Global database object in all clients so you can see here we have two clients the authenticate user class is a client of
the database uh object and this products class is also a client okay so here are some good reasons to use a single uh Global database object so first of all uh for resource efficiency so database connections and resources are typically limited and can be expensive to establish so by using a single instance of a database object you minimize the over head of creating and managing multiple connections optimizing resource utilization also consistency and State Management so having a single database instance ensures consistent State
Management and transaction handling across different parts of the application changes made to the database state are visible universally within the application avoiding inconsistencies that could arise from multiple database instances so we also simplify configuration and management so with a Singleton database instance configuration settings such as connection parameters credentials and initialization logic are centralized and managed in one place and this simplifies application setup and maintenance we also have performance optimization by
reusing a single database instance you can optimize database query performance and reduce latency associated with establishing new connections or reinitializing database resources so the singles and patter is great for storing app configuration settings uh well it's also great I should say for storing app configuration settings login configuration session information authentication tokens and making this information available globally via a single instance ensuring that it is the same throughout the app so you can see um there are many reasons
why we would want to keep a single instance of an object throughout the application rather than creating new versions of that object in multiple clients and we can see here some more specific reasons why we would want a single database instance so say that we need to keep an app settings object that stores Global variables such as the name of the application the database configuration for example what database type we're using whether it's postgrad SQL uh mongodb the username and the password and also logger settings such as the
file location for our log file the format whether it's text versus Json Etc and we need to create only a single instance of this object throughout our application to ensure that it only needs to be configured once in one place and to ensure consistency throughout the application so first of all we're going to create a PO solution to this problem so first of all let's create a new folder for our Singleton pattern example and that is a creational design pattern so let's create it in there and this is called single
ton okay so first of all let's create our app settings object or class I should say so app settings and in here we're going to create a dictionary field and each dictionary uh the dictionary is going to have keys which are strings and the values are going to be objects okay and this is where we're going to store our settings okay and each setting is going to have some key such as app name and then some object and the app name could be um design patterns Mastery for example okay so first of all we need to create a method
called get for getting uh values from our settings uh object so here we first need to check if the setting with this key name actually exists in our settings dictionary so here we can say if the settings and contains key so if the settings does not contain the key provided then we're just going to return null otherwise we can return the settings object corresponding to the provided key okay so next up we can create a sept method and this is for setting uh settings values so we provide a key and an object value and here we can simply
call settings key equals value okay so we set a settings um uh value with this key and this value so next up let's have a look at how we can use this solution in a client so what we can do is first of all create a settings uh object so we'll create new app settings equals new app settings and then let's actually set a few settings so we can call settings.
set and then we'll say app name is is uh design patterns Mastery and let's also set um a another setting for app creator and I'm just going to put my name so Danny okay so then let's actually console log um one of the settings just to check that it's working correctly so we can say settings.
 get and let's get the app name okay so this should be design pattern Mastery so let's run this and we can see that it's been set correctly and we are are retrieving it from the settings uh object without any problems so next up let's actually test um getting a setting from a different client so this is here a client a class that is using this app settings object so let's now create a test class and in here I'm just going to create a uh method called run so run the test and let's see so first of all we need to get our settings object so let's
get our uh settings object here and then what I want to do is retrieve this app name okay so as you can see in program.cs we are setting the app name and then we get the app name here and then in a different class in a different client a client has some class that's using this app settings object or class and we are trying to get the app name which was set in program.
cs so now let's actually run this test so maybe if we make this static we can just access it directly just for convenience and let's run this program and we can see we get null so null is returned here because in test the app name does not exist okay so you can see here that we need to use the Singleton pattern to ensure a single instance of app settings is maintained throughout our application because here we can see we are creating a new a completely new app settings objects and this is kind of fine if this is the first time we're doing doing it
but then we're also creating another app settings object a separate different settings object and then we're trying to access app name on a different object to what we created in here so we're going to need to use the Singleton pattern to solve this issue because every time we need to use the app settings object currently we are using the new keyword and so creating a new object so the solution is to use the Singleton pattern so to ensure that we have only a single instance of this app settings class we
first have to make the Constructor private so notice in this uml diagram that the Constructor so this app settings Constructor has a negative symbol in front of it meaning that it's private and this means that we won't be able to use the new operation uh or the new keyword with this app settings class and and also notice that we have a private static so static is being symbolized by this underline here in the uml so notice that we have a a private static instance field that holds an instance of the app settings class in
other words this class is responsible for maintaining a single instance of itself and we also have a get instance method and this again is a static method for getting that single instance and the reason that this method is static is because it's static um Fields so this static field here for example and static fields are only visible to static methods so if this wasn't static it wouldn't be able to access this instance field because static Fields belong to the class itself rather than the objects that are
instantiated from it so let's have a look at the gang of four representation here we see it's very similar to what we have up here we have a class called Singleton with an instance uh a static private instance of itself we have a private Constructor so that the new keyword cannot be used uh outside of the class itself and then we have a get instance method which basically um returns uh uh a sing the instance of itself so to implement the Singleton pattern you have to do a few things so first of all we need to make the
Constructor private so that the new keyword can't be used to create multiple instances of this class okay so we can only create an instance of the class inside of the class itself so another point is that we have to create a private static instance field to keep reference to the single instance that is created inside of the class and we have to create a public a public static get instance method for creating that single instance the first time the method is called in the application then returning that very same instance every time the
method is called so let's now implement this solution in code so let's now refactor our app settings uh class to AA to the Singleton pattern so first of all we need to create a private static fi bu for holding a reference to the instance so let's create that so private static app settings so this is going to be an instance of itself we're going to call this instance and we're going to leave it as null initially so next up we need to make the Constructor private this is a very important step in the Singleton
pattern to ensure that um instances of absent settings cannot be created outside of the class itself so this means that the clap class itself will be able to create and maintain a single instance of itself throughout the application uh globally so let's make the con The Constructor private so private Constructor and it's just an empty body so next up uh we have a we need to create a method for creating a single instance of the this class and we're going to call this method get instance so this is going to be a static method
called app settings and we're going to call it uh get instance and what we're going to do here is we need to check if the instance is null and if the instance is null so the first time that this method is called the instance is going to be null so we need to create a new instance okay otherwise we just return the instance so the second time that this get instance method is called instance will be set to an app settings object and therefore this will not run and we will just return that very same instance
as we returned previously okay so I believe everything else should be the same as before so we have our get method for getting um certain settings via their key and we have our set method for setting different settings so I believe that's everything that we need to do so now what we can do is we can go into our program.
cs file and I'm just going to change the name space to this uh new um solution and let's see what is the error we get here so app settings is inaccessible okay so now we can see that because we were previously using the new keyword to create an app settings object it's now giving us an error because app settings do app settings so this is the Constructor is inaccessible due to its protection level so if we look in app settings The Constructor is now not accessible outside of the class so we're going to get an error so now to create
the settings object we need to call app settings dot get instance and this now returns an instance of the settings object and we can use the settings object just as we did before so we set some values here and then we um we log the app name at the bottom so let's test that this works correctly as it did before and we can see that we get design patterns Mastery just as we should okay so that's perfect so now let's actually test out um getting this instance any different client somewhere else in our
application so if we go into our new example folder and create a test class and in here I'm going to create a public static method called run and what we're going to do is we're going to again get our settings instance and I'm going to try to retrieve the app name so let's actually see if this works so now if we run test.
 run we should get design patterns Mastery because here we get the instance from settings from our app settings and this creates a new instance and caches or um uh stores this instance in the instance variable on the class so you can see that this is a static field meaning that it's stored on the class itself and not within new objects created um um elsewhere in the program so let's see if this works and as you can see we get design patterns Mastery logged twice so this is perfect we now have a global um instance uh object for our
settings the factory method pattern is a creational design pattern that defines an interface for creating objects but allows subclasses to alter the type of objects that will be created providing a way to delegate the instantiation logic to subclasses enabling flexibility in object creation without changing the client code so say that we are developing a new model view controller backend framework or MVC framework to rival the popular PHP framework laravel so let's code out a a basic solution so I've created a view engine interface
with a render method and this takes a file name so this is going to be the file location of our template and we are we can pass that template some data and then this view engine is going to render this uh template it's going to pass it the data and turn it into a regular um string of HTML and return that HTML so that um it can be understood by a browser and we also have a couple of template engines so here we have a blue um sorry a blade view engine which implements the view engine interface with a render method and here
we're just returning view rendered from file name by blade and then we have a twig view engine so this is just a different templating engine uh and then we're just saying view rendered from file name by twig and this is all within our MVC framework folder so this is part of our uh framework that we are developing and these view engines will actually be third party code to our framework because we are going to be sort of downloading these view engines um installing them into our application as packages so we would not have access
to the source code to these view engines okay so now let's create a base controller class to handle requests uh made to our application so let's create a controller and in here we're going to have a method called render and this is going to take a file name for the template that we want to render and we're also going to have some data that we can pass uh pass to it okay so first of all let's create a view engine object that we want to use and we're going to use the blade view engine and then let's actually use the
view engine to uh convert our template uh and pass it the data and then convert it into some regular HTML so we can say VAR HTML equals View engine. render and then we can pass the file name and the data and finally what we're just going to do is we're just going to uh log to the console this HTML okay so this is our base controller class uh so remember this is all part of our MVC framework that developers can use to create their own backend uh applications or apis so developers can extend this base controller class to create their own
controllers to handle requests to their application for example a controller that deals with order related requests so let's come out of this MVC framework folder and create a new class called orders controller and this is going to extend the uh base controller from our MVC framework okay so remember this would be uh some developer creating there's some other developer not related to our MVC framework they're creating their own maybe eCommerce application and they're using our MVC backend framework so in here what we can do is
we can create a method called list orders and what I'm now going to do is I'm just going to copy and paste some code in here to save some time okay so this is basically simulating fetching uh some orders uh from a database so we can see here we have a dictionary um and we have the name of the item and the price okay so this is just to uh simulate fetching some sort of order data from a database and then it uh below this we can call the render method which we have inherited from controller and we can then pass the
location of our template file so at the template that we want to R render so this will be our blade template in this case because in controller we are using the blade view engine so this will be a blade view so maybe we can call this for example orders uh. blade. PHP and then uh we can pass the data that we want to uh populate our template file with and that's going to be this orders data okay so um I think that is everything that we need to do for now um I I've also created a method called get order to get a single order by ID inside
of here so I'm just going to paste that in for now just to save again a little bit of time you can see here this is just another controller method that we can use to get a single order okay by ID and here I'm just simulating getting an order by ID we're not actually getting it by ID because we don't have a database set up but it's just to show you a different method that we could add to our controller so our backend framework code where our base controller class is stored uh we can see here will
be downloaded by developers as a third party framework so other Developers will be downloading this MVC framework folder essentially as a package so that they can use our framework to create their own applications and this aord controller is an example of what a developer might create using our framework where they extend our base controller class now uh so developers won't actually be able to modify the code directly in this MVC framework folder so this means that if the developer want wants to use a different view engine or
template engine then this solution is poor because our controller class is tightly coupled to this blade view engine and it cannot be changed by developers we have the developer has no way of switching to a different view engine so for example if they want to use the The Twig view engine to create their templates using the uh twig templating language then we have provided them with no way oft switching a to a different view engine so let's try a different approach what if we allow developers to pass a view engine
as an argument to the controller. render method So currently we have the file name and the data that we want to pass to the view but let's also allow the developer to pass the view engine that they want to use uh whenever they render a uh render a view so let's pass the view engine that we want the the developer wants to use and now we can actually remove this uh view engine we don't need to create the view engine because it's been passed here and then just as before we can call view engine. render and then we can log
it the the resultant HTML to the console so this allows developers to select a view engine every time they can call uh every time they call this base control render so if we come into our orders controller we can see that we now get an error because we are not passing the view engine that we want to use so the developer now needs to pass the view engine that they want to use and if they want to use the twig view engine for example they can pass the twig view engine so here we can pass Again The Twig view engine so this is a more flexible
solution because it allows the developer to choose whatever view engine that they want to use however uh the problem is that we have to now pass or the developer has to now pass the view engine every time they call the render method and usually developers will be using one view engine for all of the templates in their application so it doesn't make much sense to make the developer uh to have to keep passing a view engine every time the render method is called so the solution is to create a template method and we can add a create
view engine template method inside of our base controller class and by default we can return the blade view engine but if the developer wants to switch to a different view engine such as twig then they can use our alternative controller class twig controller that overrides the create view engine template method so here is the uml and you can see here we have our Bas controller class which is part of our MBC framework package and we have our render method just as before and we also have our create view engine method which
by default returns a new blade view engine so if the user doesn't um specify any differ view engine then they will get the blade view engine and also within our uh MVC framework package so this is part of our package back framework code we're going to create a twig controller which extends the base controller and overrides the create view engine method and in instead it Returns the new twig view engine instead of a blade view engine so if the developer wants to use uh The Twig template engine then they can extend the twig controller
instead of the regular Bas controller so create view engine is is our template method uh let's show this in code so let's now refactor our code to follow the template method pattern so let's actually remove this view engine parameter from the controller's render method and we're actually now going to use a template method to create our view engine so this is going to be a protected virtual method that returns a view engine and it's going to be called create view engine and by default the default
implementation is that we return a new blade view engine so now up here we can create our view engine by calling this create view engine method okay so by default the view engine for our framework will be blade okay so now we can actually create our uh alternative controller that the developer can use so we're going to create a twig controller so this is going to extend our base controller class and we're going to override the create view engine template method so we're going to say protected override
view engine so it's going to return a view engine and it's called create view engine okay so what we're going to do here now is return The Twig view engine whoop okay so now if the developer wants to switch to The Twig view engine they can extend our twig controller class rather than the base controller class so if we go into our orders controller uh we can see here what we get we are getting an error because we no longer have a three uh parameters in this render method so we can remove this last uh argument because we no longer
need to specify the controller type in the render method and if we want to use uh The Twig template language now we can just extend the twig controller and our render method will use the twig template language because this create view engine is a template meaning it can be overridden and it will affect the behavior of the render method because we are calling it in here and this can return uh different types of view engines depending on whether it is being overridden or not so essentially um yeah as we've said this create view
engine is acting as our Factory method as it returns a new object okay and it can be a different type of object uh depending on if we override it or not so essentially what we've done is we've deferred the creation of an object the view engine to a subass and in this case the subass is Twig controller because because it's a subass of the base controller class and another option would be to make this create view engine um method an abstract method and force subclasses to implement it so in this case we have made it just a regular
method and we've provided the virtual keyword meaning that it can be overridden but we could also make it an abstract method with no default implementation so no body essentially and Force subclasses to implement it so in that case we'd need to create a blade controller that um implements this create view engine method and returns a blade view engine so that it would force the developer to select either blade view engine controller or The Twig view engine controller here is the gang of four representation for the factory method
pattern so we have some Creator class which has an operation method that calls the factory method and you can see that a factory method returns some object and then we have our concrete Creator classes which can override the factory method from the Creator uh class and you can see here each Factory method can return a different type of object and you can see here the uh Factory method is called inside of the operation so essentially we can change the behavior in the Creator class by overriding this Factory method so the objects return
from Factory methods are referred to as products in the gang of four book and uh the factory method pattern is often misunderstood it relies on inheritance and polymorphism to add flexibility to the design inheritance allows methods to be overridden in subclasses and polymorphism allows different object to be returned from the overridden methods and many people implement the factory method pattern incorrectly for example using a static method such as this so V engine equals view engine Factory do create view engine but static methods
cannot be overridden so there's actually no flexibility when using a static method as it and it isn't correct uh because we cannot change the implementation of the create view engine method so using the factory method pattern we can defer the creation of an object to its subass or subclasses and this is possible through inheritance the abstract Factory pattern is a creational design pattern that provides an interface for creating families of related objects without specifying their concrete classes promoting encapsulation and allowing for
the creation of object families that can vary independently so say that you have an application for Windows and Mac the UI components such as buttons checkboxes and text boxes are different for each operating system but each type of UI components will have the same behaviors for example a chatbox will have an onselect method uh no matter whether it's on Windows or Mac so our application needs a way of knowing what the current operating system is and then selecting the appropriate family of UI components for that operating system so
first let's Implement a more obvious solution in code okay so inside of an abstract Factory folder for this example I've created an enome for the different types of operating systems that our application is going to support so so far we have Windows and Mac I've also created a UI comp component interface for the different UI components to implement so all UI components whether they're going to be Windows or Mac need to implement this UI component interface and it has a single method for rendering
a UI component into the uh UI or the GUI so next up I've created uh a checkbox um interface and this extends the UI component interface so all checkboxes are UI components um and I've not actually created any checkbox methods just for Simplicity but we could have for example um um on select uh method or and any other checkbox related methods I've also created an i button interface which also uh extends the UI component interface okay so now for the concrete Windows components so I've also created
a UI Windows folder for all of the actual concrete Windows UI components and here we have a Windows button which implements the I button interface and also implements the render method and we also have a Windows checkbox which again implements the chatbox interface and also implements this render method we also have the Mac components the Mac UI components and we have a Mac button which implements the I button interface the render method which is just logging Mac render button and we have a Mac checkbox which again
implements the I checkbox interface okay so this is the way we are set up here so now for the app that we are actually building so these uh all of these classes so far would be uh probably installed at some sort of package uh so next up let's actually create our sort of application uh class and that's going to be called a user settings form so let's create a new class and let's say we have some sort of form which will have uh a checkbox and a button so what we can do is we can create a render
method which will accept the operating system type so whether we are whether we should render for Mac or Windows and then we can check what the operating system type is so if we can say if OS is equal to operating system type do windows then we can create a new Windows button and render it to the screen so we call the render method and we can also create a new windows chat box okay then we need another uh conditional statement to check if the operating system is Mac and then we can render a Mac button and
a Mac checkbox okay so hopefully you can already start to see what solid principle we are going to be violating using this solution but let's first of all before we discuss that let's go ahead and actually use this solution as a client would so if we go into program.cs first of all let's specify the operating system that our app is running on so this would probably be some sort of environment variable or some sort of system variable uh some sort of uh thing that we could obtain from the system that the application is
running on but but for now we're just going to say for OS is equal to operating system uh type and then we're we're just going to say mac so we're running on Mac okay so then let's render our user settings form so we can say new user settings form and let's then render this form so we can say user settings form do render and we can pass the operating system type which in our case is mac and then let's run this program and as you can see we are rendering for mac and uh the button and
the chck box for Mac if we change to Windows we should render for Windows problems with this solution can be seen in this user settings form class so for every UI that we develop we're going to have to have conditionals to check what the current operating system is and render the correct concrete UI components for that particular UI and this is a maintenance nightmare as every time we add or remove a type of operating system we have to modify a load of classes which is going to violate the open closed principle and
another issue is that we have to conditionally render concrete UI components so you can see here we're having to uh render these concrete UI components and it is in this case it's easy to make mistakes such as accidentally rendering a Windows checkbox on the Mac operating system because we're going to have lots of different UI components this is just an uh sorry different UI um so different pages or different forms uh maybe um like homepage and about page um a a different window for um giving some
information uh after a user has clicked a button uh lots of different UI Elements which are going to be built from these base UI components and we can see that as the application grows it's going to become easier to accidentally render the wrong type of UI components for a certain particular operating system and our program isn't going to know if we've actually done that by accident it's only going to result in an error when the application runs on that particular operating system so the solution to the issues that we faced
previously are to create an abstract Factory class to create families of UI components such as the family of Windows UI components or the family of Mac UI components so here you can see we have an interface called UI component Factory which has a create button method and a create checkbox method and we then have our concrete component Factory so here is the Mac UI component Factory and this create button method will return a Mac button and the create checkbox method will return a Mac checkbox and we also have a Windows UI component Factory
which will do the same but for Windows components so essentially we're going to be able to create families of UI components from these component factories so here is the gang of four representation of the abstract Factory pattern and you can see here we have our abstract Factory interface with create uh which with methods to create different products and then we have our concrete factories which actually Implement these methods so rather than discuss the advantages of using this method here I think it's going to be
better to implement this in code and then discuss as we uh code so continuing on from our previous code we can create uh the abstract Factory interface so I'm going to create this in the abstract Factory folder and this is going to be called I UI component Factory and here we just need to create two methods one for creating a button and another for creating a chat box okay so now we can create our concrete factories so first of all let's create our Mac UI component Factory and this needs to implement the
um the our UI component Factory so UI component Factory and then we need to implement this interface so here we very simply just have to return a Mac button okay so let's import this correctly so there we go and then here we just need to return a Mac uh chat box okay so that's everything we need to do there so let's create our Windows UI component Factory for creating families of Windows UI components and again we need to implement the UI component Factory interface and very simply we just have to return a Windows button
here and that should be Windows button and then let's import use the correct namespace and here we just have to return a Windows chat box okay so now in our form class so let's go to our user settings form we can see here that beforehand we were or currently we're checking we're having to check the operating system type before rendering the operating system specific UI components so now what we can do is we can actually use polymorphism so that this client requires no knowledge of the uh specific uh of the operating system
basically it can just call uh the uh it can just use the UI component Factory to create a uh button or check box and then render it to the screen and it can do that because we're going to pass the UI component Factory into this render method so now rather than having to perform all of these checks we can simply use polymorphism uh so we can call UI component Factory doc create button and we can render that to the screen and then we can do the same thing for the create chat box okay so here you can see that we're using
polymorphism by talking to a factory interface uh to create relate Ed UI components and this client requires no knowledge of the specific operating system okay so this is much cleaner uh we no longer need to perform all of these checks in every single um UI that we create such as this user settings form so let's now have a look at how this solution would be uh used so if we go into our program.
cs file we now need to do a few extra things here so first of all let's create the uh UI component factory and we're not going to uh assign this any objects initially because what we now need to do is we have to perform our operating system checks uh inside of the program.cs file so we can say if operating system equals operating system type.
 Windows then we can assign the UI component Factory equal to a new windows UI component Factory and then we can do another check here for Mac then we can assign it to a new Mac UI component Factory and if the operating system doesn't match any of the supported operating systems for our application then we can throw an exception and here we'll just say unsupported operating system okay so now here I'm just going to do this on one line actually so rather than calling render on a separate line I'm just going to create the user settings
form and then call render directly on this line and then we can pass into this render method the UI component Factory okay so that should be everything that we need so let's run this program okay so you can see here that it's rendering our user settings form correctly and if we switch to Mac then we should render for Mac okay perfect so this is all working correctly just as it was beforehand um but here you might be wondering what is the advantage of using this abstract Factory pattern uh compared to what we
did previously because we're still having to have all of these conditional statements to check the operating system type we're just doing it now in a different place rather than within our settings form class and the advantage of this is that these checks now only need to be done just once upon app initialization then throughout the application the UI component Factory can be used to ensure that the correct family of UI components are used for the current operating system all throughout the application so here we we
once we've um uh assigned the correct uh UI component Factory it can be used all throughout our application and we know longer need to check um what the operating system is in every single sort of UI class that we create so if we create uh a different uh class such as I don't know maybe um orders uh orders page for example which lists uh all of the orders that a user has made from some e-commerce store then we wouldn't have to do all of these checks inside of that class and every other class that we
create we can just pass the correct UI comp component Factory that has been initialized here just once so that is the advantage of using the abstract Factory pattern the Builder pattern is a design pattern used to construct complex objects step by step providing Clarity and flexibility in the creation process so let's say that we have a class called car uh and we use this to create car objects and we also have a manual class that is used to create core manuals for certain cares so you can see here that a
manual has a set of fields and a car also has the same set of fields here so you can see that a car or a manual is composed of these fields and we can see we have the car type and if I just go into this components folder where I've stored all of these kind of components to make up a car or manual we can see that car type can either be Sports SUV or Saloon uh the dashboard can be configured to either have a rev counter or not uh we have an engine class here which we could provide methods and Fields for the speed model Etc a GPS
navigator class and also a class to represent wheels and I've just put the dynamet of the wheels in inches as a sort of example field so we can see here in car and manual they share a lot of common fields and currently we have Seven Fields that are shared between car and manual and also in car we have a uh field here which is specific to this class so it's not relevant in the manual class and this CL this field is called Fuel and this sort of represents the amount of fuel that is in the car uh and then in manual we also have a
print method which is used to print the text or create the manual from the fields or information that has been set on the object so let's take a look at how a client would use this solution to create cars and their corresponding manuals so first of all let's try to create a sports car so we can say sports car equals new car and this needs to come from the Builder pattern and now we have to Ty uh provide the sort of configuration options for a sports car so first of all we need to provide the type of the car and we can use the car
type enome for this so we can say car type do Sports and then we need to provide the number of seats so sports car will have two seats we then need to provide is convertible so we're going to say false this is not a convertible sports car uh we need to provide an engine and that's everything we need there uh we need to provide a dashboard and we can provide uh whether this has a rev counter or not so and what I'm going to do is I'm going to type out the name of the field just so it's nice and clear and put
true okay so then we need a Wheels object and then we need to provide the diameter of the wheels in inches so let's say 20 in and then we need a new GPS navigator so let's provide GPS navigator and finally I think actually that is everything that we need to provide okay so that is our sports car and then we can also specify uh the amount of fuel in the sports car so let's just say it's full 100% uh filled okay so then we could also create an SUV so rather than type out all of those configuration options again let me
just copy and paste an SUV so we have the car type SUV uh so I believe this is the uh number of seats so I guess it would make sense here to again provide the name of the field and then is convertible so we could do that okay so you can see that there are a lot of configuration options that we have to provide every time we create a sports car or a car I should say and also I just noticed that we don't need this or this okay so let's also now create a sports car manual and again we have to provide some configuration options lots of
configuration options and then I'm just logging out uh the sports cor manual uh print so we print the sports cor manual and log it to the console and we can also do the same for SUV and you can see that um when we create a manual and when we create a sports car so a sports car and a sports car manual we're actually providing the same fields to create these things but they are two separate objects that are not really related okay they don't share a common interface because a car is different from a
manual so let's run this to see what we get and you can see we have the two different manuals so we have a manual for sports car here and we have our manual for our SUV so as you can see here with there is a large number of configuration variables that we have to pass to the Constructor of core or manual when creating them so as you saw with the example there are a large number of configuration variables that we have to pass to the Constructor every time that we create a car or car manual object and this is pretty ugly and also a large
number of the configuration options are not needed most of the time for example most cars are not convertibles and therefore we have to just keep on providing false um for all of our cars or car manuals for many of the fields so one way way of not having to specify all of the configuration options when creating a new object will be to create sub classes for each type of car or manual so here we can see we have our original base car class and we have some sub classes to create specific types of cars and we also have the same thing uh
for the manuals here to create the manuals for these cars so the problem with this solution is that our library of subclasses is likely to grow very large as more configuration variables are added to car and also if we for example change the wheel size on a sports car then we'd also have to change the sports car manual class to uh correspond to this changed uh wheel diameter so the above Solutions here are ugly and difficult to maintain so let's now introduce the Builder pattern to solve these issues so here is the uml
solution for the Builder pattern so we can see here we have a builder interface with a few methods so we have here set C type set seats and we'll also have the rest of the methods such as set engine set dashboard Etc so these methods kind of represent the steps involved in building either a car or a manual and then we have the sort of concrete Builder classes so we have one for building a car and one for building a manual and you can see here in this car builder that we store a a reference or a field of a car object and then we
use these methods so such as set car type we'll set the car type on this car object and then we have set seats and we'll also Implement all the other methods that we need from this Builder interface and then finally at the end we have a get core method which will just return this builtup car and then we have the same thing for manuals where we have a manual field so in this manual Builder we're going to be building up a manual using these methods that we have implemented from this Builder interface
and then again finally we have a sort of geta method where we can return this builtup manual object so a car and its manual are two different objects that don't share a common interface however they can be constructed using the same steps as each specific component in a car needs to be documented by its manual so by abstracting the object creation logic into Builder class we can create cares and manuals by only specifying the steps required to build that specific core or manual so let's take a look at how we can implement this
in code so let's now solve this problem using the Builder pan so first of all let's create or recreate our car class so you can see beforeand that we The Way We Were creating cars is that we pass all of these values into the Constructor uh now what I'm going to do is I'm just going to provide um I'm going to change these from fields to C Properties just for convenience and you don't have to do this we could still have car uh exactly the same as we had it beforehand uh as we had it in here uh we could pass all
of the fields into the Constructor however I'm now just going to build up a car by um setting the uh properties with gets and sets so uh let's now uh import these components and then let's create our manual in the same way so we're going to move away from passing the values into the Constructor and we're just going to use properties to set the fields uh within the Builder classes that we are going to create so let's create a manual class and I'm just going to copy and paste this in because it's pretty much what we
had before but we're now using C Properties rather than setting the values in the Constructor as we did before so we just need to import these components so we're going to use this namespace okay so now we can build uh our Builder interface that will contain all of the possible steps for building a car or a a manual so let's call this I Builder and in here we're going to have some methods so first of all I'm going to provide a reset method and this is going to essentially in our concrete Builders it's going to
reset the kind of object field so for example if we have a car builder the car builder has a field of car and it builds up that car with the methods that we provide in here and the reset method is basically just going to kind of reset that core object to a brand new object so this is just a common method that is often included in the Builder pattern and it'll become more clear when we actually use this method so next up I am going to create a set core type method and this is going to return an i Builder
and the reason we're actually returning uh a builder from this set core type is because it will allow us to chain methods onto each other when we are creating a core so again hang on this will become much more clear if you don't understand when we actually use this solution so I'm just going to copy and paste in the other methods now to save some time because it's pretty obvious what we are doing so we're just adding in the other methods so as you can see we have um all the steps that we need
here to build a car or manual so we can set the engine we can set the wheels we can set the dashboard and pass a dashboard in ETC so now let's build the concrete Builders so first of all let's create the car builder and this is going to implement the I Builder or the Builder interface so let's Implement that interface so let's see so the core build if you remember needs to store a field of a car of type car so let's go ahead and do that and then in the Constructor we can uh call the reset method okay so
essentially whenever we create a new car builder object we are going to set this car equal to a new blank core object a fresh core object so to do that we can first of all create a Constructor and we don't need to pass anything to this Constructor we just want to call the reset method and inside of the reset method I'm actually going to move this up so it's a little bit more clear we're just going to set the car field equal to a new car okay so next up let's Implement some of these methods so first of all let's implement
the set call type method so where is that okay so in here we pass the car type that we want to set the car to and so the way we can do this is we can just call car do type equals type okay and then remember we need to return an i builder at the end of this method so we can just return this Builder because this is a car builder which is a a builder because we're implementing the Builder interface and again this will become clear why we're doing this shortly so what I'm going to do is I'm just going to copy
and paste the rest of these methods in because it's again very obvious and a little bit laborious so let me just copy and paste those in so I'm just going to copy and paste the whole class in actually okay so that should be everything we need so let's just go through what we've done here so again we have a car object which we are setting to a blank object upon the Builder's construction we then have our methods which are the steps involved in building a car so here we can set the car type we can set the
dashboard and we pass the dashboard in uh we can set an engine the GPS navigator the seats is convertible set wheels and then finally we have our get core method which will return the car at the end and we can see here that we store the car in a variable and then we call reset so that we are essentially resetting our car as a new car object once we get the car and this isn't um necessary in the Builder pattern but it's just something that's commonly done um so it's it's kind of like an optional
step whether you reset the object when you get the uh object or whether you just leave it as it is okay and then maybe call reset from the client so that's just um an implementation option I guess so next up let's build the core manual Builder class and we need to implement the Builder interface okay so what I'm going to do again is I'm just going to copy and paste these methods in to save us some time so it's going to be exactly the same as what we have in our car builder because it's implementing the Builder interface
the only difference is that we are storing reference to a manual rather than a car that's the only difference that we have here and we just need to import uh or use this namespace for the components folder okay so that's everything that we need to do here and as you can see it's exactly the same as what we have before so if I just go through one method we have the set core type method here where we pass the core type and then we call manual.
 type which is a property on this manual object we set the type and return this core manual Builder so that we can chain the methods onto each other whenever we are building a car manual and again that will become clear when we use these classes and finally we have our get manual method which sets um store the manual in a new variable calls reset to reset the manual field to a new manual so a new blank uh Manu uh manual and then we return the manual okay so that's everything that we need to do here so let's take a look now
how we would use this class in the client so I'm actually just going to Let's comment this out and let's go down here and first let's let's create a car builder okay so then we need to import this okay so next up let's actually uh build a car using the car builder so we can say core Builder do set core type and then we can set the core type to core type do Sports so we're going to build a sports core again exactly the same as we did beforeand we can then set the number of seats let's see set
seats H do we not have a set seats method here H maybe we're missing a method okay so it looks like we didn't actually include our set seats uh method in here so let's add that in and we're going to set it to and okay so we pass in an integer for the number of seats and then we actually need to add this method into our car and car manual Builders so let's just come down here and we'll say public I Builder set seats and then we'll say int seats and we'll set the seats and return the Builder Okay so let's see
what have we done wrong here Caril already defined set seats with the same Okay so we've actually provided this method already ah okay so we didn't have it in the Builder interface but we did have it in the in the Builder itself the concrete Builders okay so we we just needed to add it here okay so let's go back into our our client and we can now set seats hopefully there we go so this is going to have two seats and we can set the engine to a new engine and let's see set dashboard to a new dashboard see what do we need to provide
here uh has rev counter we'll say true and let's see so we've got a dashboard set the wheels and it will have four wheels actually we need to provide the wheels components and then we set the dynamite in inches to 20 and uh that I believe is everything we need to do to create a sports car so now we should be able to get the sports car so we can say car builder dog uh car and let's see we then should be able to set the fuel on the car so let's car do Set uh maybe it's Fuel and then we'll
say 100 okay so let's run that to make sure that we've got no issues here and I believe believe that's all okay so let's now create our manual builder for a sports car so here you can see we're using the car manual Builder and then we are calling all of the same methods as we did previously and then we get the sports uh the sports car manual by calling manual builder.
getet manual and then we are logging the printed manual ual to the screen so let's see if that logs correctly okay so that all looks good so this is a nicer solution as we now only need to specify the core or manual properties that we need for example we don't need to specify if the car is convertible like we did beforehand when we were uh when we had had to provide all of the data in the Constructor of a car or a manual when we're creating those objects and also notice how we can conveniently chain methods onto each
other because we are actually returning the current object from each method call so if we check set seats you can see in this interface we have to return the Builder which means that we can keep on chaining these methods onto each other and we could also return void from each of these methods and then call each method line by line so for example car builder.
 set car type and then we'd say car builder. set seats but it's just nice and convenient to be able to chain these methods onto each other so the problem with this solution here is that we still have to specify a large number of fields when creating cars and manuals and also because car builder and car manual Builder both implement the same I Builder or Builder interface we can now use polymorphism to create cars and manuals as producing a manual for a specific type of car for example a sports car requires the exact same steps so for example if a car has a GPS then
it also needs to be documented in the manual so we can Implement uh this using a director class which I will show you next so you can see here we still have the exact same Builder pan that we had beforehand we can see we have the Builder interface and then our concrete Builders which imp lement the Builder interface but we've now added this director class to our pattern and you can see this director class has two methods here one for constructing sports cars and one for constructing SUVs and you can see that we pass the Builder
that we want to use into each of these methods so for example if we wanted to construct a sports car this method would contain all of the steps in this sequence for producing a sports car and if we wanted to produce a sports car uh you know a sports car car then we would pass the car builder if we wanted to produce a sports car manual then we would pass the manual Builder and because the steps for producing a sports car and a sports car manual are the same we can just pass the Builder and it will construct um the sports car or sports
car manual correctly and we could also do the same for different types of cars different uh such as SUV or um any other type of car um so we can see here that we have this uh dependency relationship between the director and the Builder and that's because we're passing the Builder into as an argument into each of these methods so the director class is actually optional in the Builder pattern as the build steps can be specified in the client and that's what we did here but it's often useful for putting common
construction routines into this director class so that they can be easily reused throughout your application so let's now take a look at the ganga for representation of the Builder pattern so you can see here we have our direct uh director class which has methods that contain commonly used routines and we can pass the build that we want to use into each of these methods we then have our Builder interface with a reset method for uh resetting the uh object that we are constructing to a new object we will and then we have our build steps we then
have our concrete Builders which implement the Builder interface and each concrete builder needs some sort of method for getting the result of the uh Builder after the product has been built so note that above we are passing a build that to each method in the director class but it's also fine to store a reference to a builder and then use methods for changing the builder at runtime like so so here you can see we have a different way of implementing the director class so rather than passing the Builder to each of the methods we
can actually pass the Builder to the director's Constructor when we are creating the director object and then we provide a method for changing the Builder um so for for example let's say we first of all want to build a sports car we pass the car builder then we call construct sports car and then if we wanted to produce a sports car manual we can call the change Builder pass the manual Builder and then construct the sports car again and this time it will produce a sports car manual so as you can see both ways of implementing the
director class are totally fine um I just wanted to show you a couple of different ways of of uh implementing this class so let's now build the director class in code so let's create a new class called director and we're going to give this class two methods one for constructing a sports car and one for constructing an SUV so first of all let's create the construct sport call method and we need to pass the Builder to the method and then we can call the Builder uh well we can call all of the build
steps on this Builder so what I'm going to do is I'm just going to copy them from our client code that we have here and this needs to be Builder and we also need to import our components okay so I think everything should be okay here okay I'm just going to move this in a little bit okay so that should be okay so let's now also create a method for constructing an SUV and again we pass the Builder and then I'm just going to copy and paste this code in that I have here so this time I've actually uh
called the steps on the or the methods on the Builder line by line so just so you can see the difference between chaining the methods and sort of calling them one by one so just two different ways to do it there personally I like chaining it's a little bit more convenient and we don't have to keep on writing the Builder over and over again but both ways of doing things are totally fine so note that we don't actually return the product for so the product being either call or a manual from this director uh well from each
method within this director and that's because each product is returned from its respective concrete Builder and this is because call and manual objects don't share a common interface so let's now go into the client and see how we can use the director class so I think what I'm going to do is I'm going to comment out all of this code here and let's first of all create our core Builder and then let's create our director class and then let's create a sports car so we can call director do construct
sports car and then we want to build a car so we pass the car builder and then we can say sports car is going to be equal to our car builder car builder. Gat sports car actually sorry it should just be G car okay so then we have our sports car and let's just check here so that should be sports car then we can call Sports car.
 Fuel and put it equal to 100 okay so that's pretty nice um so let's also now construct an SUV so we can say director do construct uh SUV and we can pass the car builder and then we can get our SUV uh let's say SUV car equals car builder dog car okay and then we can set the fuel to let's see fuel equals 40 okay so let's now produce some manuals for these cars so we can first of all create a manual Builder and this should be car manual Builder and then we can call director.
construct sports car so just the same as we did here um but instead of passing the core Builder we now pass the manual Builder so that we build a sports car manual so then we can actually get our sports car manual so we can say sports car manual is equal to manual builder. getet manual okay and then we can print the manual to the console okay so you can see that um vs code is giving us no errors here because here we are returning a a car object which has a fuel property and here we are returning a manual object which has
this print method for printing out the manual okay and we can also do the same for an SUV so I'm just going to copy this in to save a little bit of time here so you can see that we are also constructing a manual for SUV so let's run this program to make sure everything is working correctly so let's see what we have here so we have first of all of all we have our sports car manual so we can see the car type Sports the seats the diameter of the wheels Etc which is all correct and then we have our SUV with five seats
a slightly smaller diameter of wheel etc etc so this is all working as it should be so here we have used the Builder pattern to reuse the same object construction code or build steps to build different kinds of products so cars and their corresponding manuals um so other creational patterns focus on producing objects that share a common interface but the Builder pattern differs in that it can construct objects of different types providing that they share a common set of build steps congratulations you have now completed
this design patterns course and you now have all the tools to create readable maintainable flexible and top quality software so I hope you found this course useful and I thank you for watching if you did find this course useful please do like comment and subscribe to my channel it will help a lot thank you very much and I will see you in the next one
